<!DOCTYPE html>
<html lang="zh-hans">

<head>
    
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
<meta name="HandheldFriendly" content="True" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
<meta name="generator" content="Hugo 0.73.0" />



<link rel="apple-touch-icon" sizes="180x180" href="https://cdn.jsdelivr.net/gh/amzrk2/poal-jsdelivr@1.6.0/favicons/apple-touch-icon.png" />
<link rel="icon" type="image/png" sizes="32x32" href="https://cdn.jsdelivr.net/gh/amzrk2/poal-jsdelivr@1.6.0/favicons/favicon-32x32.png" />
<link rel="icon" type="image/png" sizes="16x16" href="https://cdn.jsdelivr.net/gh/amzrk2/poal-jsdelivr@1.6.0/favicons/favicon-16x16.png" />
<link rel="manifest" href="https://cdn.jsdelivr.net/gh/amzrk2/poal-jsdelivr@1.6.0/favicons/site.webmanifest" />
<link rel="mask-icon" href="https://cdn.jsdelivr.net/gh/amzrk2/poal-jsdelivr@1.6.0/favicons/safari-pinned-tab.svg" color="#8aa2d3" />
<link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/amzrk2/poal-jsdelivr@1.6.0/favicons/favicon.ico" />
<meta name="msapplication-TileColor" content="#8aa2d3" />
<meta name="msapplication-config" content="https://cdn.jsdelivr.net/gh/amzrk2/poal-jsdelivr@1.6.0/favicons/browserconfig.xml" />
<meta name="theme-color" content="#ffffff" />


<title>Spring学习笔记 - Kinopio BLOG</title>


<meta name="author" content="Kinopio" />


<meta name="description" content="A minimal Hugo theme with nice theme color." />


<meta name="keywords" content="java, spring" />

<meta property="og:title" content="Spring学习笔记" />
<meta property="og:description" content="1 简介 1.1 历史 Spring框架以interface21框架为基础，经过重新设计，并不断丰富其内涵，与2004年3月24日发布了1.0正式版 作者为Rod Johnson 1.2 理念 使现有的技术更加容易使用 本身包括很多内容，并" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://keichw.github.io/post/study-spring/" />
<meta property="og:image" content="https://keichw.github.io/img/og.png"/>
<meta property="article:published_time" content="2020-07-16T17:57:24+08:00" />
<meta property="article:modified_time" content="2020-07-16T17:57:24+08:00" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://keichw.github.io/img/og.png"/>

<meta name="twitter:title" content="Spring学习笔记"/>
<meta name="twitter:description" content="1 简介 1.1 历史 Spring框架以interface21框架为基础，经过重新设计，并不断丰富其内涵，与2004年3月24日发布了1.0正式版 作者为Rod Johnson 1.2 理念 使现有的技术更加容易使用 本身包括很多内容，并"/>



<style>
    @media (prefers-color-scheme: dark) {
        body[data-theme='auto'] img {
            filter: brightness(60%);
        }
    }

    body[data-theme='dark'] img {
        filter: brightness(60%);
    }
</style>


<link rel="stylesheet" href="/assets/css/fuji.min.css" />






</head>

<body data-theme="auto">
    <script data-cfasync="false">
    
    var fujiThemeData = localStorage.getItem('fuji_data-theme');
    
    if (!fujiThemeData) {
        localStorage.setItem('fuji_data-theme', 'auto');
    } else {
        
        if (fujiThemeData !== 'auto') {
            document.body.setAttribute('data-theme', fujiThemeData === 'dark' ? 'dark' : 'light');
        }
    }
</script>
<script data-cfasync="false">
    
    function browserDetection(ua) {
        if (ua.indexOf('MSIE ') > 0 || ua.indexOf('Trident/') > 0) {
            return true;
        }
        return false;
    }

    var ua = window.navigator.userAgent;
    if (browserDetection(ua)) {
        window.location.href('https:\/\/keichw.github.io\/ie\/');
    }
</script>
    <header>
    <div class="container-lg clearfix">
        <div class="col-12 header">
            <a class="title-main" href="https://keichw.github.io">Kinopio BLOG</a>
            
            <span class="title-sub">(ง •̀_•́)ง</span>
            
        </div>
    </div>
</header>

    <main>
        <div class="container-lg clearfix">
            
            <div class="col-12 col-md-9 float-left content">
                
<article>
    
    <h2 class="post-item post-title">
        <a href="https://keichw.github.io/post/study-spring/">Spring学习笔记</a>
    </h2>
    <div class="post-item post-meta">
        <span><ion-icon name="today"></ion-icon>&nbsp;2020-07-16</span><span><ion-icon name="file-tray"></ion-icon>&nbsp;6459 字</span><span><ion-icon name="stopwatch"></ion-icon>&nbsp;13 分钟</span><span><ion-icon name="pricetags"></ion-icon>&nbsp;<a href="/tags/java">java</a>&nbsp;<a href="/tags/spring">spring</a>&nbsp;</span>
    </div>
    
    
    <div class="post-content markdown-body">
        <h2 id="1-简介">1 简介</h2>
<h3 id="11-历史">1.1 历史</h3>
<ul>
<li>
<p>Spring框架以interface21框架为基础，经过重新设计，并不断丰富其内涵，与2004年3月24日发布了1.0正式版</p>
</li>
<li>
<p>作者为Rod Johnson</p>
</li>
</ul>
<h3 id="12-理念">1.2 理念</h3>
<ul>
<li>使现有的技术更加容易使用</li>
<li>本身包括很多内容，并整合了现有的技术框架</li>
</ul>
<h3 id="13-优点">1.3 优点</h3>
<ul>
<li>Spring是一个开源的免费的框架（容器）</li>
<li>Spring是一个轻量级的、非入侵式的框架</li>
<li>控制反转（IOC）</li>
<li>面向切面编程（AOP）</li>
<li>支持事务的处理</li>
</ul>
<h3 id="14-组成">1.4 组成</h3>
<p><a href="/img/study-spring/spring%e6%a8%a1%e5%9d%97.jpg" target="_blank">
    <img src="/img/study-spring/spring%e6%a8%a1%e5%9d%97.jpg" alt="" />
</a></p>
<h3 id="15-其他">1.5 其他</h3>
<ul>
<li>Spring Boot
<ul>
<li>一个快速开发的框架</li>
<li>基于Spring Boot可以快速开发单个微服务</li>
</ul>
</li>
<li>Spring Cloud
<ul>
<li>基于Spring Boot实现</li>
</ul>
</li>
</ul>
<h2 id="2-ioc">2 IoC</h2>
<p>以前的JavaWeb项目开发流程，比如</p>
<ol>
<li>写UserDao接口</li>
</ol>
<pre><code class="language-java">public interface UserDao {
    //方法
}
</code></pre>
<ol start="2">
<li>写UserDaoImpl实现类</li>
</ol>
<pre><code class="language-java">public class UserDaoImpl implements UserDao {
    //方法实现
}
</code></pre>
<ol start="3">
<li>写UserService业务接口</li>
</ol>
<pre><code class="language-java">public interface UserService {
    //方法
}
</code></pre>
<ol start="4">
<li>写UserServiceImpl业务实现类</li>
</ol>
<pre><code class="language-java">public class UserServiceImpl implements UserService {
    private UserDao userDao = new UserDaoImpl();
    
    //方法实现
}
</code></pre>
<ol start="5">
<li>测试</li>
</ol>
<pre><code class="language-java">@Test
public void test() {
    UserService userService = new UserServiceImpl();
    //调用userService的方法
}
</code></pre>
<p>这种方法的弊端在于用户的需求可能会影响代码，需要根据用户需求去修改代码，代价很大</p>
<p>那么，如果在UserServiceImpl中使用set接口，程序变为</p>
<pre><code class="language-java">public class UserServiceImpl implements UserService {
    private UserDao userDao;
    //利用set进行动态注入
    public void setUserDao(UserDao userDao) {
        this.userDao = userDao;
    }
    
    //方法实现
}
</code></pre>
<p>测试的时候代码变为</p>
<pre><code class="language-java">@Test
public void test() {
    UserService userService = new UserServiceImpl();
    (UserServiceImpl) userService.setUserDao(new UserDaoImpl());
    //调用userService的方法
}
</code></pre>
<p>使用set注入后，程序不再具有主动性，变成了被动的接收对象。主动权转到了用户，用户选择实现类对象</p>
<p>这种思想从本质上解决了问题，程序员不用管理对象的创建，降低了系统的耦合，从而专注业务的实现，这就是IoC的原型</p>
<h3 id="21-ioc本质">2.1 IoC本质</h3>
<p>控制反转（IoC, Inversion of Control）是一种设计思想。在没有IoC的程序中，使用面向对象编程，对象的创建和对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制。而控制反转则是将对象的创建转移给第三方</p>
<p>控制反转是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式，在Spring中实现控制反转的是IoC容器，其实现方法是依赖注入（DI, Dependency Injection）</p>
<h2 id="3-hellospring">3 HelloSpring</h2>
<ol>
<li>编写实体类</li>
</ol>
<pre><code class="language-java">public class Hello {
    private String str;
    
    public void setStr(String str) {
        this.str = str;
    }
    
    public String getStr() {
        return str;
    }
}
</code></pre>
<ol start="2">
<li>配置xml文件</li>
</ol>
<pre><code class="language-xml">&lt;bean id=&quot;hello&quot; class=&quot;com.hjc.pojo.Hello&quot;&gt;
    &lt;property name=&quot;str&quot; value=&quot;Hello, world&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<ol start="3">
<li>测试</li>
</ol>
<pre><code class="language-java">@Test
public void test() {
    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);
    Hello hello = (Hello) context.getBean(&quot;hello&quot;);
    System.out.println(hello);
}
</code></pre>
<p>要实现不同的操作，我们只需要在xml文件中修改。对象由Spring来创建，管理，装配</p>
<h2 id="4-ioc创建对象的方式">4 IoC创建对象的方式</h2>
<h3 id="41-无参构造函数创建对象">4.1 无参构造函数创建对象</h3>
<p>要用无参构造函数创建对象，那么类中就要保留无参构造函数，要么显示写出无参构造函数，要么就不写构造函数</p>
<pre><code class="language-java">public class User {
    private int id;
    private String name;
    
    public void setId(int id) {
        this.id = id;
    }
    
    public void setName(String name) {
        this.name = name;
    }
    
    //其他函数
}
</code></pre>
<p>此时，在配置xml时就如上文那样，数据注入是由set注入的，那么在类中就要写出属性的set方法</p>
<pre><code class="language-xml">&lt;bean id=&quot;user&quot; class=&quot;com.hjc.pojo.User&quot;&gt;
    &lt;property name=&quot;id&quot; value=&quot;1&quot;/&gt;
    &lt;property name=&quot;name&quot; value=&quot;admin&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>用这种方式配置，那么对象是先由类的无参构造函数创建，再由类的set方法进行数据的注入，要注意这个先后顺序</p>
<h3 id="42-有参构造函数创建对象">4.2 有参构造函数创建对象</h3>
<p>如果要使用有参构造函数创建对象，那么在类中就要写出有参构造函数。此时，数据是由有参构造函数注入</p>
<pre><code class="language-java">public class User {
    private int id;
    private String name;
    
    public User(int id, String name) {
        this.id = id;
        this.name = name;
    }
}
</code></pre>
<p>在配置xml文件时就和上文不太一样</p>
<pre><code class="language-xml">&lt;bean id=&quot;user&quot; class=&quot;com.hjc.pojo.User&quot;&gt;
    &lt;constructor-arg index=&quot;0&quot; value=&quot;1&quot;/&gt;
    &lt;constructor-arg index=&quot;1&quot; value=&quot;admin&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<pre><code class="language-xml">&lt;bean id=&quot;user&quot; class=&quot;com.hjc.pojo.User&quot;&gt;
    &lt;constructor-arg type=&quot;int&quot; value=&quot;1&quot;/&gt;
    &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;admin&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<pre><code class="language-xml">&lt;bean id=&quot;User&quot; class=&quot;com.hjc.pojo.User&quot;&gt;
    &lt;constructor-arg name=&quot;id&quot; value=&quot;1&quot;/&gt;
    &lt;constructor-arg name=&quot;name&quot; value=&quot;admin&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>以上三种方法都可以实现相同的效果。以这种方式配置，对象就由类的有参构造函数创建，而数据也是由有参构造函数注入</p>
<p>不管对象是由无参构造函数还是有参构造函数创建的，在配置文件加载的时候，容器中的对象就已经被初始化了</p>
<h2 id="5-spring配置">5 Spring配置</h2>
<h3 id="51-别名">5.1 别名</h3>
<p>Spring中别名的使用和MyBatis中类似，使用别名之后可以省略类的包路径</p>
<h3 id="52-bean的配置">5.2 bean的配置</h3>
<pre><code class="language-xml">&lt;!--
id: bean的唯一标识符
class: bean对象对应的全限定名
name: 别名，可以取多个别名
scope: bean为单例还是多例
--&gt;
&lt;bean id=&quot;user&quot; class=&quot;com.hjc.pojo.User&quot; name=&quot;user2&quot; scope=&quot;singleton&quot;&gt;
    &lt;property name=&quot;id&quot; value=&quot;1&quot;/&gt;
    &lt;property name=&quot;name&quot; value=&quot;admin&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<h3 id="53-使用import">5.3 使用import</h3>
<p>将多个配置文件导入合并为一个配置文件。比如，在applicationContext.xml文件中导入service.xml和dao.xml配置文件，将这两个配置文件合并为一个applicationContext.xml配置文件</p>
<pre><code class="language-xml">&lt;import resource=&quot;service.xml&quot;/&gt;
&lt;import resource=&quot;dao.xml&quot;/&gt;
</code></pre>
<h2 id="6-依赖注入">6 依赖注入</h2>
<h3 id="61-构造器注入">6.1 构造器注入</h3>
<p>参考4.2</p>
<h3 id="62-set方式注入">6.2 set方式注入</h3>
<ul>
<li>依赖注入
<ul>
<li>依赖：bean对象的创建依赖于容器</li>
<li>注入：bean对象的所有属性由容器注入</li>
</ul>
</li>
</ul>
<p>实例</p>
<ol>
<li>编写实体类</li>
</ol>
<pre><code class="language-java">public class Student {
    private String name;
    private Address address;
    private String[] books;
    private List&lt;String&gt; hobbies;
    private Map&lt;String, String&gt; scores;
    private Set&lt;String&gt; games;
    private String nullPoint;
    private Properties info;
    
    //一定要写各属性的set方法，在此省略
}
</code></pre>
<pre><code class="language-java">public class Address {
    private String address;
    
    public setAddress(String address) {
        this.address = address;
    }
}
</code></pre>
<ol start="2">
<li>配置xml文件，使用set方法注入</li>
</ol>
<pre><code class="language-xml">&lt;bean id=&quot;address&quot; class=&quot;com.hjc.pojo.Address&quot;&gt;
    &lt;property name=&quot;address&quot; value=&quot;testAddress&quot;/&gt;
&lt;/bean&gt;

&lt;bean id=&quot;student&quot; class=&quot;com.hjc.pojo.Student&quot;&gt;
    &lt;!--基本类型（包括String）注入，value--&gt;
    &lt;property name=&quot;name&quot; value=&quot;test&quot;/&gt;
    &lt;!--bean注入，ref--&gt;
    &lt;property name=&quot;address&quot; ref=&quot;address&quot;/&gt;
    &lt;!--数组注入，--&gt;
    &lt;property name=&quot;books&quot;&gt;
        &lt;array&gt;
            &lt;value&gt;testBook1&lt;/value&gt;
            &lt;value&gt;testBook2&lt;/value&gt;
            &lt;value&gt;testBook3&lt;/value&gt;
        &lt;/array&gt;
    &lt;/property&gt;
    &lt;!--list注入--&gt;
    &lt;property name=&quot;hobbies&quot;&gt;
        &lt;list&gt;
            &lt;value&gt;testHobby1&lt;/value&gt;
            &lt;value&gt;testHobby2&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
    &lt;!--map注入--&gt;
    &lt;property name=&quot;scores&quot;&gt;
        &lt;map&gt;
            &lt;entry key=&quot;Math&quot; value=&quot;100&quot;/&gt;
            &lt;entry key=&quot;Physics&quot; value=&quot;100&quot;/&gt;
        &lt;/map&gt;
    &lt;/property&gt;
    &lt;!--set注入--&gt;
    &lt;property name=&quot;games&quot;&gt;
        &lt;set&gt;
            &lt;value&gt;testGame1&lt;/value&gt;
            &lt;value&gt;testGame2&lt;/value&gt;
        &lt;/set&gt;
    &lt;/property&gt;
    &lt;!--null注入--&gt;
    &lt;property name=&quot;nullPoint&quot;&gt;
        &lt;null/&gt;
    &lt;/property&gt;
    &lt;!--properties注入--&gt;
    &lt;property name=&quot;info&quot;&gt;
        &lt;props&gt;
            &lt;prop key=&quot;testInfo1&quot;&gt;test1&lt;/prop&gt;
            &lt;prop key=&quot;testInfo2&quot;&gt;test2&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
<ol start="3">
<li>测试</li>
</ol>
<pre><code class="language-java">@Test
public void test() {
    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);
    Student student = (Student) context.getBean(&quot;student&quot;);
    System.out.println(student);
}
</code></pre>
<h3 id="63-其他方式注入">6.3 其他方式注入</h3>
<p>p命名空间，对应set注入，参考<a href="https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/core.html#beans-p-namespace" target="_blank">官方文档</a></p>
<p>c命名空间，对象构造器注入，参考<a href="https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/core.html#beans-c-namespace" target="_blank">官方文档</a></p>
<h2 id="7-bean的作用域">7 bean的作用域</h2>
<h3 id="71-singleton">7.1 singleton</h3>
<p>单例模式，也是Spring的默认模式，不显示写出就表示单例</p>
<p>单例模式表示在容器中对象只会创建一个</p>
<h3 id="72-prototype">7.2 prototype</h3>
<p>原型模式，表示每次从容器中获得对象的时候，容器会创建一个新的对象返回</p>
<h3 id="73-requestsessionapplication">7.3 request、session、application</h3>
<p>这几个在web开发中使用</p>
<h2 id="8-bean的自动装配">8 bean的自动装配</h2>
<p>之前的xml配置都是手动配置的，那么自动装配是Spring会在上下文中自动寻找，自动装配属性</p>
<p>在Spring中有三种装配的方式</p>
<ul>
<li>在xml中显示配置</li>
<li>在java类中显示配置</li>
<li>隐式自动装配</li>
</ul>
<h3 id="81-byname自动装配">8.1 byName自动装配</h3>
<pre><code class="language-java">public class Student {
    private String name;
    private Computer computer;
    private KeyBoard keyBoard;
    
    //set方法
}
</code></pre>
<pre><code class="language-java">public class Computer {
}

public class KeyBoard {
}
</code></pre>
<p>有三个实体类，用byName自动装配配置xml</p>
<pre><code class="language-xml">&lt;bean id=&quot;computer&quot; class=&quot;com.hjc.pojo.Computer&quot;/&gt;
&lt;bean id=&quot;keyBoard&quot; class=&quot;com.hjc.pojo.KeyBoard&quot;/&gt;
&lt;!--
byName: 自动在容器上下文中查找和自己对象set方法后面的值对应的bean id
如：类中setComputer方法，Computer对应bean id为computer
--&gt;
&lt;bean id=&quot;student&quot; class=&quot;com.hjc.pojo.Student&quot; autowire=&quot;byName&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;test&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>这种方法要求bean的id不能随便选择，要和自动注入的属性的set方法的值一致，除了首字母大写变成小写</p>
<h3 id="82-bytype自动装配">8.2 byType自动装配</h3>
<p>还是上面三个实体类，用byType实现自动装配</p>
<pre><code class="language-xml">&lt;bean id=&quot;computer&quot; class=&quot;com.hjc.pojo.Computer&quot;/&gt;
&lt;bean id=&quot;keyBoard&quot; class=&quot;com.hjc.pojo.KeyBoard&quot;/&gt;
&lt;!--
byType: 会自动在容器上下文中查找和自己对象属性类型相同的bean
--&gt;
&lt;bean id=&quot;student&quot; class=&quot;com.hjc.pojo.Student&quot; autowire=&quot;byType&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;test&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>这种方法要求对象中属性类型要唯一，如果有几个相同的属性类型，就不能自动装配</p>
<h3 id="83-注解自动装配">8.3 注解自动装配</h3>
<p>jdk1.5支持注解，spring2.5支持注解</p>
<p>要使用注解</p>
<ol>
<li>导入约束，context约束</li>
<li>配置注解的支持</li>
</ol>
<pre><code class="language-xml">&lt;context:annotation-config/&gt;
</code></pre>
<p>使用@Autowired注解，直接在属性上使用，或者在set方法上使用。另外，使用@Autowired注解可以不写set方法，前提是属性符合byType的要求</p>
<p>实体类</p>
<pre><code class="language-java">public class Student {
    private String name;
    @Autowired
    private Computer computer;
    @Autowired
    private KeyBoard keyBoard;
    
    //set方法
}
</code></pre>
<p>xml文件</p>
<pre><code class="language-xml">&lt;bean id=&quot;computer&quot; class=&quot;com.hjc.pojo.Computer&quot;/&gt;
&lt;bean id=&quot;keyBoard&quot; class=&quot;com.hjc.pojo.KeyBoard&quot;/&gt;
&lt;bean id=&quot;student&quot; class=&quot;com.hjc.pojo.Student&quot;/&gt;
</code></pre>
<p>如果使用@Autowired实现自动装配的环境比较复杂，无法通过一个注解完成的时候，可以配合使用@Qualifier(value=&quot;xxx&rdquo;)来指定唯一的一个bean</p>
<h2 id="9-使用注解开发">9 使用注解开发</h2>
<p>在Spring4之后，要使用注解开发，必须要导入aop的包。另外，需要在xml文件中导入context约束，配置注解的支持</p>
<pre><code class="language-xml">&lt;context:annotation-config/&gt;
</code></pre>
<p>首先，要配置扫描的包，也就是说，在类中配置了注解还要被扫描到才有效</p>
<pre><code class="language-xml">&lt;context:component-scan base-package=&quot;com.hjc&quot;/&gt;
</code></pre>
<h3 id="91-component">9.1 @Component</h3>
<p>这个注解放在类上，表示这个类被Spring管理了，比如</p>
<pre><code class="language-java">@Component
public class User {
    //省略
}
</code></pre>
<p>相当于在xml文件中配置bean</p>
<pre><code class="language-xml">&lt;bean id=&quot;user&quot; class=&quot;com.hjc.pojo.User&quot;/&gt;
</code></pre>
<h3 id="92-value">9.2 @Value</h3>
<p>这个注解放在类中的属性上，表示注入数据，比如</p>
<pre><code class="language-java">@Component
public class User {
    @Value(&quot;test&quot;)
    private String name;
}
</code></pre>
<p>相当于在xml文件中配置bean，并进行依赖注入</p>
<pre><code class="language-xml">&lt;bean id=&quot;user&quot; class=&quot;com.hjc.pojo.User&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;test&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<p>@Value注解也可以放在属性的对应set方法上，但这个注解只能进行简单的配置，复杂的配置还是使用xml文件</p>
<h3 id="93-component的衍生注解">9.3 @Component的衍生注解</h3>
<p>web项目一般有三层，不同层中的注解名称不同，但作用相同</p>
<ul>
<li>Dao层：@Repository</li>
<li>Service层：@Service</li>
<li>Controller层：@Controller</li>
</ul>
<p>这几个注解和@Component是一样的，都表示将类注册到Spring中，装配bean</p>
<h3 id="94-autowired">9.4 @Autowired</h3>
<p>这个注解实现自动装配，参考8.3</p>
<h3 id="95-scope">9.5 @Scope</h3>
<p>这个注解配置类的作用域，是单例模式还是原型模式，比如</p>
<pre><code class="language-java">@Component
@Scope(&quot;singleton&quot;)
public class User {
    @Value(&quot;test&quot;)
    private String name;
}
</code></pre>
<p>总结：</p>
<ul>
<li>xml文件配置更加万能，适用于任何场合，维护简单</li>
<li>注解适用于简单的配置，维护相对复杂</li>
<li>项目中一般<strong>使用xml管理bean，使用注解完成属性注入</strong></li>
</ul>
<h2 id="10-使用javaconfig配置">10 使用JavaConfig配置</h2>
<p>不使用xml文件配置，都由Java代码配置</p>
<p>JavaConfig是Spring的一个子项目，在Spring4之后，称为一个核心功能</p>
<h3 id="101-configurationbean">10.1 @Configuration、@Bean</h3>
<p>要用Java代码进行配置，就要用到@Configuration和@Bean这两个注解，比如</p>
<pre><code class="language-java">@Configuration
public class AppConfig {
    @Bean
    public User getUser() {
        return new User();
    }
}
</code></pre>
<p>这就相当于在xml中配置</p>
<pre><code class="language-xml">&lt;bean id=&quot;getUser&quot; class=&quot;com.hjc.pojo.User&quot;/&gt;
</code></pre>
<p>测试</p>
<pre><code class="language-java">@Test
public void test() {
    ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
    User user = context.getBean(&quot;getUser&quot;);
}
</code></pre>
<p>注意和xml文件配置实例化对象的不同</p>
<h3 id="102-componentscan">10.2 @ComponentScan</h3>
<p>在配置类中使用这个注解表示设置扫描类包</p>
<pre><code class="language-java">@Configuration
@ComponentScan(&quot;com.hjc&quot;)
public class AppConfig {
    @Bean
    public User getUser() {
        return new User();
    }
}
</code></pre>
<h2 id="11-代理模式">11 代理模式</h2>
<p>代理模式是SpringAOP的底层实现</p>
<p>代理模式有两种</p>
<ul>
<li>静态代理</li>
<li>动态代理</li>
</ul>
<h3 id="111-静态代理">11.1 静态代理</h3>
<p><a href="/img/study-spring/%e4%bb%a3%e7%90%86%e6%a8%a1%e5%bc%8f.png" target="_blank">
    <img src="/img/study-spring/%e4%bb%a3%e7%90%86%e6%a8%a1%e5%bc%8f.png" alt="" />
</a></p>
<p>角色分析</p>
<ul>
<li>抽象角色：一般会使用接口或者抽象类来解决</li>
<li>真实角色：被代理角色</li>
<li>代理角色：代理真实角色，代理真实角色后，一般会做附加操作</li>
<li>客户：访问代理对象的人</li>
</ul>
<p>使用静态代理的例子</p>
<ol>
<li>编写接口（抽象角色）</li>
</ol>
<pre><code class="language-java">//租房接口
public interface Rent {
    void rent();
}
</code></pre>
<ol start="2">
<li>编写被代理类（真实角色）</li>
</ol>
<pre><code class="language-java">//房东
public class Host implements Rent {
    @Override
    public void rent() {
        System.out.println(&quot;房东出租房子&quot;);
    }
}
</code></pre>
<ol start="3">
<li>编写代理类（代理角色）</li>
</ol>
<pre><code class="language-java">public class Proxy implements Rent {
    private Host host;
    
    public Proxy() {
    }
    
    public Proxy(Host host) {
        this.host = host;
    }
    
    @Override
    public void rent() {
        findHouse();
        host.rent();
        signContract();
    }
    
    public void findHouse() {
        System.out.println(&quot;找到房子&quot;);
    }
    
    public void signContract() {
        System.out.println(&quot;签合同&quot;);
    }
}
</code></pre>
<ol start="4">
<li>编写客户访问代理角色</li>
</ol>
<pre><code class="language-java">public class Client {
    public static void main(String[] args) {
        Proxy proxy = new Proxy(new Host());
        proxy.rent();
    }
}
</code></pre>
<p>静态代理的好处：</p>
<ul>
<li>可以使真实角色的操作更加纯粹，不用关注一些公共的业务</li>
<li>公共业务交给代理角色，实现了业务的分工</li>
<li>公共业务发生扩展的时候，方便集中管理</li>
</ul>
<p>缺点：</p>
<ul>
<li>一个真实角色就会产生一个代理角色，增加代码量，开发效率低</li>
</ul>
<p>在web开发中，如果要对类中的方法进行增强，直接改类中对应方法的代码比较繁琐，而且实际开发不允许直接改代码，我们可以使用静态代理实现，举个例子加深理解</p>
<ol>
<li>编写service接口</li>
</ol>
<pre><code class="language-java">public interface UserService {
    void add();
    void delete();
    void update();
    void query();
}
</code></pre>
<ol start="2">
<li>编写service实现类</li>
</ol>
<pre><code class="language-java">public class UserServiceImpl implements UserService {
    //实现对应方法
}
</code></pre>
<ol start="3">
<li>编写代理类</li>
</ol>
<pre><code class="language-java">public class UserServiceProxy implements UserService {
    private UserService userService;
    
    public void setUserService(UserService userService) {
        this.userService = userService;
    }
    
    public void add() {
        log(&quot;add&quot;);
        userService.add();
    }
    
    public void delete() {
        log(&quot;delete&quot;);
        userService.delete();
    }
    
    public void update() {
        log(&quot;update&quot;);
        userService.update();
    }
    public void query() {
        log(&quot;query&quot;);
        userService.find();
    }
    
    public void log(String msg) {
        System.out.println(&quot;[debug] 使用了&quot; + msg + &quot;方法&quot;);
    }
}
</code></pre>
<ol start="4">
<li>客户访问</li>
</ol>
<pre><code class="language-java">public class Client {
    public static void main(String[] args) {
        UserServiceProxy proxy = new UserServiceProxy();
        proxy.setUserService(new UserServiceImpl);
        proxy.add();
        proxy.delete();
        proxy.update();
        proxy.query();
    }
}
</code></pre>
<p>这样子就避免修改了原有的service代码，而是通过代理类对service类的方法进行增强</p>
<p><a href="/img/study-spring/%e6%a8%aa%e5%90%91%e5%bc%80%e5%8f%91.png" target="_blank">
    <img src="/img/study-spring/%e6%a8%aa%e5%90%91%e5%bc%80%e5%8f%91.png" alt="" />
</a></p>
<h3 id="112-动态代理">11.2 动态代理</h3>
<ul>
<li>动态代理和静态代理的角色一样</li>
<li>动态代理的代理类是动态生成的，不是直接写好的</li>
<li>动态代理分为两大类
<ul>
<li>基于接口的动态代理：jdk动态代理</li>
<li>基于类的动态代理：cglib</li>
<li>还有基于java字节码实现：Javassist</li>
</ul>
</li>
</ul>
<p>需要了解两个类：Proxy，InvocationHandler</p>
<p>动态代理的好处</p>
<ul>
<li>动态代理有静态代理的优点</li>
<li>另外，一个动态代理类代理的是一个接口，一般对应一类业务，解决了静态代理的缺点</li>
</ul>
<h2 id="12-aop">12 AOP</h2>
<h3 id="121aop定义">12.1AOP定义</h3>
<p>AOP（Aspect Oriented Programming），面向切面编程，通过预编译方式和运行期动态代理实现程序功能统一维护的技术。AOP是OOP的延续，是函数式编程的一种衍生范型</p>
<h3 id="122-aop在spring中的作用">12.2 AOP在Spring中的作用</h3>
<p>提供声明式事务，允许用户自定义切面</p>
<ul>
<li>横切关注点：跨越应用程序多个模块的方法或功能，如日志，安全，缓存，事务等等</li>
<li>切面（Aspect）：横切关注点被模块化的特殊对象，即是一个类</li>
<li>通知（Advice）：切面必须要完成的工作，即是类中的一个方法</li>
<li>目标（Target）：被通知对象</li>
<li>代理（Proxy）：向目标对象应用通知之后创建的对象</li>
<li>切入点（PointCut）：切面通知执行的“地点”</li>
<li>连接点（JointPoint）：与切入点匹配的执行点</li>
</ul>
<p><a href="/img/study-spring/AOP.png" target="_blank">
    <img src="/img/study-spring/AOP.png" alt="" />
</a></p>
<p>SpringAOP中，通过Advice定义横切逻辑，Spring支持5种类型的Advice</p>
<ul>
<li>前置通知
<ul>
<li>连接点：方法前</li>
<li>实现接口：org.springframework.aop.MethodBeforeAdvice</li>
</ul>
</li>
<li>后置通知
<ul>
<li>连接点：方法后</li>
<li>实现接口：org.springframework.aop.AfterReturningAdvice</li>
</ul>
</li>
<li>环绕通知
<ul>
<li>连接点：方法前后</li>
<li>实现接口：org.aopalliance.intercept.MethodInterceptor</li>
</ul>
</li>
<li>异常抛出通知
<ul>
<li>连接点：方法抛出异常</li>
<li>实现接口：org.springframework.aop.ThrowsAdvice</li>
</ul>
</li>
<li>引介通知
<ul>
<li>连接点：类中增加新的方法属性</li>
<li>实现接口：org.springframework.aop.IntroductionInterceptor</li>
</ul>
</li>
</ul>
<p>AOP在不改变原有代码的情况下， 增加新的功能</p>
<h3 id="113-使用spring实现aop">11.3 使用Spring实现AOP</h3>
<p>要使用AOP织入，需要导入包</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
    &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
    &lt;version&gt;1.9.5&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>假设有service接口和实现类</p>
<pre><code class="language-java">public interface UserService {
    void add();
    void delete();
    void update();
    void query();
}
</code></pre>
<pre><code class="language-java">public class UserServiceImpl implements UserService {
    //实现对应方法
}
</code></pre>
<p>那么，要对这几个方法使用AOP进行方法增强</p>
<p><strong>方式一：使用Spring的API实现</strong></p>
<ol>
<li>首先要定义切面和通知，定义类实现对应接口</li>
</ol>
<pre><code class="language-java">public class BeforeLog implements MethodBeforeAdvice {
    //Method: 被代理的目标对象的方法
    //args: 方法参数
    //target: 被代理的目标对象
    @Override
    public void before(Method method, Object[] args, Object target) throws Throwable {
        System.out.println(&quot;执行&quot; + target.getClass().getName() + &quot;的&quot; + method.getName());
    }
}
</code></pre>
<pre><code class="language-java">public class AfterLog implements AfterReturningAdvice {
    //returnValue: 被代理的方法的返回值
    @Override
    public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable {
        System.out.println(&quot;执行&quot; + method.getName() + &quot;返回结果&quot; + returnValue);
    }
}
</code></pre>
<ol start="2">
<li>在xml中配置，把这些类注册到Spring中</li>
</ol>
<pre><code class="language-xml">&lt;!--注册bean--&gt;
&lt;bean id=&quot;userService&quot; class=&quot;com.hjc.service.UserServiceImpl&quot;/&gt;
&lt;bean id=&quot;beforeLog&quot; class=&quot;com.hjc.log.BeforeLog&quot;/&gt;
&lt;bean id=&quot;afterLog&quot; class=&quot;com.hjc.log.AfterLog&quot;/&gt;

&lt;!--配置aop，导入aop约束--&gt;
&lt;aop:config&gt;
    &lt;!--切入点，expression表达式--&gt;
    &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.hjc.service.UserServiceImpl.*(..))&quot;/&gt;
    &lt;!--执行增强--&gt;
    &lt;aop:advisor advice-ref=&quot;beforeLog&quot; pointcut-ref=&quot;pointcut&quot;/&gt;
    &lt;aop:advisor advice-ref=&quot;afterLog&quot; pointcut-ref=&quot;pointcut&quot;/&gt;
&lt;/aop:config&gt;
</code></pre>
<ol start="3">
<li>测试</li>
</ol>
<pre><code class="language-java">@Test
public void test() {
    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
    //动态代理的是接口
    UserService userService = (UserService) context.getBean(&quot;userService&quot;);
    userService.add();
    userService.delete();
}
</code></pre>
<p><strong>方式二：自定义实现AOP</strong></p>
<p>不通过实现Spring的接口来实现AOP，而是自己定义切面类和通知</p>
<pre><code class="language-java">public class MyLog {
    public void beforeLog() {
        //具体实现
    }
    
    public void AfterLog() {
        //具体实现
    }
}
</code></pre>
<p>同样，在xml中配置</p>
<pre><code class="language-xml">&lt;bean id=&quot;myLog&quot; class=&quot;com.hjc.log.MyLog&quot;/&gt;

&lt;aop:config&gt;
    &lt;!--自定义切面--&gt;
    &lt;aop:aspect ref=&quot;myLog&quot;&gt;
        &lt;!--切入点--&gt;
        &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.hjc.service.UserServiceImpl.*(..))&quot;/&gt;
        &lt;!--通知--&gt;
        &lt;aop:before method=&quot;beforeLog&quot; pointcut-ref=&quot;pointcut&quot;/&gt;
        &lt;aop:after method=&quot;afterLog&quot; pointcut-ref=&quot;pointcut&quot;/&gt;
    &lt;/aop:aspect&gt;
&lt;/aop:config&gt;
</code></pre>
<p><strong>方式三：注解实现AOP</strong></p>
<p>使用注解实现AOP，主要是在定义切面类的时候使用注解</p>
<pre><code class="language-java">@Aspect
public class MyLog {
    @Before(&quot;execution(* com.hjc.service.UserServiceImpl.*(..))&quot;)
    public void before() {
        //具体实现
    }
    
    @After(&quot;execution(* com.hjc.service.UserServiceImpl.*(..))&quot;)
    public void after() {
        //具体实现
    }
}
</code></pre>
<p>在xml中只需注册bean，当然也可以使用注解自动装配。还要开启注解支持</p>
<pre><code class="language-xml">&lt;bean id=&quot;myLog&quot; class=&quot;com.hjc.log.MyLog&quot;/&gt;
&lt;aop:aspectj-autoproxy/&gt;
</code></pre>
<h2 id="13-整合mybatis">13 整合MyBatis</h2>
<p>步骤</p>
<ol>
<li>导入相关jar包
<ul>
<li>junit</li>
<li>mybatis</li>
<li>mysql</li>
<li>spring</li>
<li>aop织入</li>
<li>mybatis-spring</li>
</ul>
</li>
<li>编写配置文件</li>
</ol>
<h3 id="131-mybatis">13.1 MyBatis</h3>
<h3 id="132-mybatis-spring">13.2 MyBatis-Spring</h3>
<p>参考<a href="https://mybatis.org/spring/zh/index.html" target="_blank">官方文档</a></p>
<ol>
<li>编写数据源配置</li>
<li>sqlSessionFactory</li>
<li>sqlSessionTemplate</li>
<li>给Dao接口编写实现类</li>
<li>注册实现类到Spring中</li>
<li>测试</li>
</ol>
<h2 id="14-声明式事务">14 声明式事务</h2>
<h2 id="141-事务">14.1 事务</h2>
<ul>
<li>事务涉及数据的完整性和一致性问题</li>
<li>事务ACID原则
<ul>
<li>原子性</li>
<li>一致性</li>
<li>隔离性</li>
<li>持久性</li>
</ul>
</li>
</ul>
<h3 id="142-spring中的事务管理">14.2 Spring中的事务管理</h3>
<ul>
<li>声明式事务：AOP</li>
<li>编程式事务：在代码中进行事务管理</li>
</ul>
<p>一般使用声明式事务，而不是用编程式事务，因为编程式事务会改变代码</p>
<ol>
<li>在xml中配置声明式事务</li>
</ol>
<pre><code class="language-xml">&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
    &lt;property name=&quot;dataSource&quot; value=&quot;dataSource&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<ol start="2">
<li>结合AOP实现事务织入</li>
</ol>
<pre><code class="language-xml">&lt;!--配置事务通知--&gt;
&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;
    &lt;!--给具体方法配置事务--&gt;
    &lt;tx:attributes&gt;
        &lt;tx:method name=&quot;add&quot; propagation=&quot;REQUIRED&quot;/&gt;
        &lt;tx:method name=&quot;delete&quot; propagation=&quot;REQUIRED&quot;/&gt;
        &lt;tx:method name=&quot;update&quot; propagation=&quot;REQUIRED&quot;/&gt;
        &lt;tx:method name=&quot;query&quot; read-only=&quot;true&quot;/&gt;
        &lt;!--配置所有方法--&gt;
        &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot;/&gt;
    &lt;/tx:attributes&gt;
&lt;/tx:advice&gt;

&lt;!--配置事务切入--&gt;
&lt;aop:config&gt;
    &lt;aop:pointcut id=&quot;txPointCut&quot; expression=&quot;execution(* com.hjc.mapper.*.*(..))&quot;/&gt;
    &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;txPointCut&quot;/&gt;
&lt;/aop:config&gt;
</code></pre>

    </div>
</article>


<div class="license markdown-body">
    <blockquote>
        <p>除特殊注明部分，本站内容采用 <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"
               target="_blank">CC BY-NC-SA 4.0</a> 进行许可。</p>
    </blockquote>
</div>



            </div>
            <aside class="col-12 col-md-3 float-left sidebar">
    
    
    
    <div class="sidebar-item sidebar-toc">
        <h3>目录</h3>
        <nav id="TableOfContents">
  <ul>
    <li><a href="#1-简介">1 简介</a>
      <ul>
        <li><a href="#11-历史">1.1 历史</a></li>
        <li><a href="#12-理念">1.2 理念</a></li>
        <li><a href="#13-优点">1.3 优点</a></li>
        <li><a href="#14-组成">1.4 组成</a></li>
        <li><a href="#15-其他">1.5 其他</a></li>
      </ul>
    </li>
    <li><a href="#2-ioc">2 IoC</a>
      <ul>
        <li><a href="#21-ioc本质">2.1 IoC本质</a></li>
      </ul>
    </li>
    <li><a href="#3-hellospring">3 HelloSpring</a></li>
    <li><a href="#4-ioc创建对象的方式">4 IoC创建对象的方式</a>
      <ul>
        <li><a href="#41-无参构造函数创建对象">4.1 无参构造函数创建对象</a></li>
        <li><a href="#42-有参构造函数创建对象">4.2 有参构造函数创建对象</a></li>
      </ul>
    </li>
    <li><a href="#5-spring配置">5 Spring配置</a>
      <ul>
        <li><a href="#51-别名">5.1 别名</a></li>
        <li><a href="#52-bean的配置">5.2 bean的配置</a></li>
        <li><a href="#53-使用import">5.3 使用import</a></li>
      </ul>
    </li>
    <li><a href="#6-依赖注入">6 依赖注入</a>
      <ul>
        <li><a href="#61-构造器注入">6.1 构造器注入</a></li>
        <li><a href="#62-set方式注入">6.2 set方式注入</a></li>
        <li><a href="#63-其他方式注入">6.3 其他方式注入</a></li>
      </ul>
    </li>
    <li><a href="#7-bean的作用域">7 bean的作用域</a>
      <ul>
        <li><a href="#71-singleton">7.1 singleton</a></li>
        <li><a href="#72-prototype">7.2 prototype</a></li>
        <li><a href="#73-requestsessionapplication">7.3 request、session、application</a></li>
      </ul>
    </li>
    <li><a href="#8-bean的自动装配">8 bean的自动装配</a>
      <ul>
        <li><a href="#81-byname自动装配">8.1 byName自动装配</a></li>
        <li><a href="#82-bytype自动装配">8.2 byType自动装配</a></li>
        <li><a href="#83-注解自动装配">8.3 注解自动装配</a></li>
      </ul>
    </li>
    <li><a href="#9-使用注解开发">9 使用注解开发</a>
      <ul>
        <li><a href="#91-component">9.1 @Component</a></li>
        <li><a href="#92-value">9.2 @Value</a></li>
        <li><a href="#93-component的衍生注解">9.3 @Component的衍生注解</a></li>
        <li><a href="#94-autowired">9.4 @Autowired</a></li>
        <li><a href="#95-scope">9.5 @Scope</a></li>
      </ul>
    </li>
    <li><a href="#10-使用javaconfig配置">10 使用JavaConfig配置</a>
      <ul>
        <li><a href="#101-configurationbean">10.1 @Configuration、@Bean</a></li>
        <li><a href="#102-componentscan">10.2 @ComponentScan</a></li>
      </ul>
    </li>
    <li><a href="#11-代理模式">11 代理模式</a>
      <ul>
        <li><a href="#111-静态代理">11.1 静态代理</a></li>
        <li><a href="#112-动态代理">11.2 动态代理</a></li>
      </ul>
    </li>
    <li><a href="#12-aop">12 AOP</a>
      <ul>
        <li><a href="#121aop定义">12.1AOP定义</a></li>
        <li><a href="#122-aop在spring中的作用">12.2 AOP在Spring中的作用</a></li>
        <li><a href="#113-使用spring实现aop">11.3 使用Spring实现AOP</a></li>
      </ul>
    </li>
    <li><a href="#13-整合mybatis">13 整合MyBatis</a>
      <ul>
        <li><a href="#131-mybatis">13.1 MyBatis</a></li>
        <li><a href="#132-mybatis-spring">13.2 MyBatis-Spring</a></li>
      </ul>
    </li>
    <li><a href="#14-声明式事务">14 声明式事务</a></li>
    <li><a href="#141-事务">14.1 事务</a>
      <ul>
        <li><a href="#142-spring中的事务管理">14.2 Spring中的事务管理</a></li>
      </ul>
    </li>
  </ul>
</nav>
    </div>
    
    
    
    <div class="sidebar-item sidebar-pages">
        <h3>页面</h3>
        <ul>
            
            <li>
                <a href="/">Home</a>
            </li>
            
            <li>
                <a href="/archives/">Archives</a>
            </li>
            
            <li>
                <a href="/about/">About</a>
            </li>
            
            <li>
                <a href="/search/">Search</a>
            </li>
            
            <li>
                <a href="/index.xml">RSS</a>
            </li>
            
        </ul>
    </div>
    
    <div class="sidebar-item sidebar-tags">
        <h3>标签</h3>
        <div>
            
            <span>
                <a href="/tags/c&#43;&#43;/">c&#43;&#43;</a>
            </span>
            
            <span>
                <a href="/tags/css/">css</a>
            </span>
            
            <span>
                <a href="/tags/java/">java</a>
            </span>
            
            <span>
                <a href="/tags/jdbc/">jdbc</a>
            </span>
            
            <span>
                <a href="/tags/mybatis/">mybatis</a>
            </span>
            
            <span>
                <a href="/tags/network/">network</a>
            </span>
            
            <span>
                <a href="/tags/servlet/">servlet</a>
            </span>
            
            <span>
                <a href="/tags/spring/">spring</a>
            </span>
            
            <span>
                <a href="/tags/springmvc/">springmvc</a>
            </span>
            
            <span>
                <a href="/tags/web/">web</a>
            </span>
            
            <span>
                <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
            </span>
            
            <span>
                <a href="/tags/%E7%AE%97%E6%B3%95/">算法</a>
            </span>
            
        </div>
    </div>
    
    <div class="sidebar-item sidebar-links">
        <h3>链接</h3>
        <ul>
            
            <li>
                <a href="https://github.com/keichw" target="_blank"><span>GitHub</span></a>
            </li>
            
        </ul>
    </div>
    
</aside>
        </div>
        <div class="btn">
    <div class="btn-toggle-mode">
        <ion-icon name="contrast"></ion-icon>
    </div>
    <div class="btn-scroll-top">
        <ion-icon name="chevron-up"></ion-icon>
    </div>
</div>
    </main>

    <footer>
    <div class="container-lg clearfix">
        <div class="col-12 footer">
            <span>&copy; 2020 <a href="https://keichw.github.io">Kinopio</a> |
                基于 <a href="https://github.com/amzrk2/hugo-theme-fuji/"
                   target="_blank">Fuji-v2</a> & <a href="https://gohugo.io/"
                   target="_blank">Hugo</a> 构建</span>
        </div>
    </div>
</footer>
    
    <script async type="module" src="https://cdn.jsdelivr.net/npm/ionicons@5.0.1/dist/ionicons/ionicons.esm.js"></script>
<script async nomodule src="https://cdn.jsdelivr.net/npm/ionicons@5.0.1/dist/ionicons/ionicons.js"></script>

<script defer src="https://cdn.jsdelivr.net/npm/prismjs@1.20.0/components/prism-core.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/prismjs@1.20.0/plugins/autoloader/prism-autoloader.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/lazysizes@5.2.2/lazysizes.min.js"></script>

<script defer src="/assets/js/fuji.min.js"></script>

</body>

</html>