<!DOCTYPE html>
<html lang="zh-hans">

<head>
    
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
<meta name="HandheldFriendly" content="True" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
<meta name="generator" content="Hugo 0.73.0" />



<link rel="apple-touch-icon" sizes="180x180" href="https://cdn.jsdelivr.net/gh/amzrk2/poal-jsdelivr@1.6.0/favicons/apple-touch-icon.png" />
<link rel="icon" type="image/png" sizes="32x32" href="https://cdn.jsdelivr.net/gh/amzrk2/poal-jsdelivr@1.6.0/favicons/favicon-32x32.png" />
<link rel="icon" type="image/png" sizes="16x16" href="https://cdn.jsdelivr.net/gh/amzrk2/poal-jsdelivr@1.6.0/favicons/favicon-16x16.png" />
<link rel="manifest" href="https://cdn.jsdelivr.net/gh/amzrk2/poal-jsdelivr@1.6.0/favicons/site.webmanifest" />
<link rel="mask-icon" href="https://cdn.jsdelivr.net/gh/amzrk2/poal-jsdelivr@1.6.0/favicons/safari-pinned-tab.svg" color="#8aa2d3" />
<link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/amzrk2/poal-jsdelivr@1.6.0/favicons/favicon.ico" />
<meta name="msapplication-TileColor" content="#8aa2d3" />
<meta name="msapplication-config" content="https://cdn.jsdelivr.net/gh/amzrk2/poal-jsdelivr@1.6.0/favicons/browserconfig.xml" />
<meta name="theme-color" content="#ffffff" />


<title>SpringMVC学习笔记 - Kinopio BLOG</title>


<meta name="author" content="Kinopio" />


<meta name="description" content="A minimal Hugo theme with nice theme color." />


<meta name="keywords" content="spring, springmvc, java" />

<meta property="og:title" content="SpringMVC学习笔记" />
<meta property="og:description" content="1 简介 1.1 定义 首先，MVC是模型（Model），视图（View），控制器（Controller）的简写，是一种软件设计规范 模型（Dao，Service） 视图（jsp/html） 控制器（Servlet） S" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://keichw.github.io/post/study-springmvc/" />
<meta property="og:image" content="https://keichw.github.io/img/og.png"/>
<meta property="article:published_time" content="2020-07-19T00:41:40+08:00" />
<meta property="article:modified_time" content="2020-07-19T00:41:40+08:00" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://keichw.github.io/img/og.png"/>

<meta name="twitter:title" content="SpringMVC学习笔记"/>
<meta name="twitter:description" content="1 简介 1.1 定义 首先，MVC是模型（Model），视图（View），控制器（Controller）的简写，是一种软件设计规范 模型（Dao，Service） 视图（jsp/html） 控制器（Servlet） S"/>



<style>
    @media (prefers-color-scheme: dark) {
        body[data-theme='auto'] img {
            filter: brightness(60%);
        }
    }

    body[data-theme='dark'] img {
        filter: brightness(60%);
    }
</style>


<link rel="stylesheet" href="/assets/css/fuji.min.css" />






</head>

<body data-theme="auto">
    <script data-cfasync="false">
    
    var fujiThemeData = localStorage.getItem('fuji_data-theme');
    
    if (!fujiThemeData) {
        localStorage.setItem('fuji_data-theme', 'auto');
    } else {
        
        if (fujiThemeData !== 'auto') {
            document.body.setAttribute('data-theme', fujiThemeData === 'dark' ? 'dark' : 'light');
        }
    }
</script>
<script data-cfasync="false">
    
    function browserDetection(ua) {
        if (ua.indexOf('MSIE ') > 0 || ua.indexOf('Trident/') > 0) {
            return true;
        }
        return false;
    }

    var ua = window.navigator.userAgent;
    if (browserDetection(ua)) {
        window.location.href('https:\/\/keichw.github.io\/ie\/');
    }
</script>
    <header>
    <div class="container-lg clearfix">
        <div class="col-12 header">
            <a class="title-main" href="https://keichw.github.io">Kinopio BLOG</a>
            
            <span class="title-sub">(ง •̀_•́)ง</span>
            
        </div>
    </div>
</header>

    <main>
        <div class="container-lg clearfix">
            
            <div class="col-12 col-md-9 float-left content">
                
<article>
    
    <h2 class="post-item post-title">
        <a href="https://keichw.github.io/post/study-springmvc/">SpringMVC学习笔记</a>
    </h2>
    <div class="post-item post-meta">
        <span><ion-icon name="today"></ion-icon>&nbsp;2020-07-19</span><span><ion-icon name="file-tray"></ion-icon>&nbsp;4857 字</span><span><ion-icon name="stopwatch"></ion-icon>&nbsp;10 分钟</span><span><ion-icon name="pricetags"></ion-icon>&nbsp;<a href="/tags/spring">spring</a>&nbsp;<a href="/tags/springmvc">springmvc</a>&nbsp;<a href="/tags/java">java</a>&nbsp;</span>
    </div>
    
    
    <div class="post-content markdown-body">
        <h2 id="1-简介">1 简介</h2>
<h3 id="11-定义">1.1 定义</h3>
<p>首先，MVC是模型（Model），视图（View），控制器（Controller）的简写，是一种软件设计规范</p>
<ul>
<li>模型（Dao，Service）</li>
<li>视图（jsp/html）</li>
<li>控制器（Servlet）</li>
</ul>
<p>SpringMVC是Spring Framework的一部分，是基于Java实现MVC的轻量级Web框架</p>
<h3 id="12-设计">1.2 设计</h3>
<p>Spring的web框架围绕DIspatcherServlet设计，DispatcherServlet的作用是将请求分发到不同处理器，整个框架围绕一个中心Servlet分派请求并提供其他功能</p>
<p><a href="/img/study-springmvc/%e6%89%a7%e8%a1%8c%e5%8e%9f%e7%90%86.png" target="_blank">
    <img src="/img/study-springmvc/%e6%89%a7%e8%a1%8c%e5%8e%9f%e7%90%86.png" alt="" />
</a></p>
<h2 id="2-hellospringmvc">2 HelloSpringMVC</h2>
<h3 id="21-xml配置">2.1 xml配置</h3>
<ol>
<li>
<p>导入SpringMVC的依赖</p>
</li>
<li>
<p>在WEB-INF/jsp下创建hello.jsp</p>
</li>
</ol>
<pre><code class="language-jsp">&lt;body&gt;
    ${msg}
&lt;/body&gt;
</code></pre>
<ol start="3">
<li>配置web.xml，注册DispatcherServlet</li>
</ol>
<pre><code class="language-xml">&lt;servlet&gt;
    &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;!--绑定Spring的配置文件--&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
        &lt;param-value&gt;classpath:springmvc-servelt.xml&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;!--启动级别 1--&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
&lt;/servlet&gt;

&lt;serlvet-mapping&gt;
    &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
    &lt;!--
    / 只匹配所有请求，不匹配jsp页面
    /* 匹配所有请求，包括jsp页面
    --&gt;
    &lt;url-pattern&gt;/&lt;/url-pattern&gt;
&lt;/serlvet-mapping&gt;
</code></pre>
<ol start="4">
<li>配置springmvc-servlet.xml</li>
</ol>
<pre><code class="language-xml">&lt;!--配置处理器映射器--&gt;
&lt;bean class=&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;/&gt;
&lt;!--配置处理器适配器--&gt;
&lt;bean class=&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;/&gt;
&lt;!--配置视图解析器--&gt;
&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
    &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt;
    &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<ol start="5">
<li>创建HelloController，实现Controller接口</li>
</ol>
<pre><code class="language-java">public class HelloController implements Controller {
    @Override
    public ModelAndView handlerRequest(HttpServletRequest req, HttpServletResponse resp) throws Throwable {
        ModelAndView mv = new ModelAndView();
        String result = &quot;HelloSpringMVC&quot;;
        mv.addObject(&quot;msg&quot;, result);
        mv.setViewName(&quot;hello&quot;);
        return mv;
    }
}
</code></pre>
<ol start="6">
<li>因为使用了BeanNameUrlHandlerMapping处理器映射器，所以要在Spring中注册bean</li>
</ol>
<pre><code class="language-xml">&lt;bean id=&quot;/hello&quot; class=&quot;com.hjc.controller.HelloController&quot;/&gt;
</code></pre>
<ol start="7">
<li>配置Tomcat，运行，在url输入localhost:8080/hello</li>
</ol>
<p>在实际开发中，一般不会写这么多配置文件，而是使用注解配置</p>
<h3 id="22-注解配置">2.2 注解配置</h3>
<ol>
<li>导入SpringMVC的依赖</li>
<li>在WEB-INF/jsp下创建hello.jsp</li>
</ol>
<pre><code class="language-jsp">&lt;body&gt;
    ${msg}
&lt;/body&gt;
</code></pre>
<ol start="3">
<li>配置web.xml，注册DispatcherServlet</li>
</ol>
<pre><code class="language-xml">&lt;servlet&gt;
    &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;!--绑定Spring的配置文件--&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
        &lt;param-value&gt;classpath:springmvc-servelt.xml&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;!--启动级别 1--&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
&lt;/servlet&gt;

&lt;serlvet-mapping&gt;
    &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;
    &lt;!--
    / 只匹配所有请求，不匹配jsp页面
    /* 匹配所有请求，包括jsp页面
    --&gt;
    &lt;url-pattern&gt;/&lt;/url-pattern&gt;
&lt;/serlvet-mapping&gt;
</code></pre>
<ol start="4">
<li>配置springmvc-servlet.xml</li>
</ol>
<pre><code class="language-xml">&lt;!--配置自动扫描包--&gt;
&lt;context:component-scan base-package=&quot;com.hjc.controller&quot;/&gt;

&lt;!--不处理静态资源--&gt;
&lt;mvc:default-servlet-handler/&gt;

&lt;!--支持mvc注解驱动--&gt;
&lt;mvc:annotation-driven/&gt;

&lt;!--配置视图解析器--&gt;
&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
    &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt;
    &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;
&lt;/bean&gt;

</code></pre>
<ol start="5">
<li>创建HelloController</li>
</ol>
<pre><code class="language-java">@Controller
@RequestMapping(&quot;/hello&quot;)
public class HelloController {
    @RequestMapping(&quot;/test&quot;)
    public String hello(Model model) {
        model.addAttribute(&quot;msg&quot;, &quot;HelloSpringMVC&quot;);
        return &quot;hello&quot;;	//返回结果会被视图解析器处理
    }
}
</code></pre>
<ol start="6">
<li>配置Tomcat，运行，在url输入localhost:8080/hello/test</li>
</ol>
<p><strong>总结</strong></p>
<ul>
<li>不使用注解开发要配置处理器映射器、处理器适配器和视图解析器</li>
<li>使用注解开发只需要配置视图解析器</li>
</ul>
<h2 id="3-controller相关配置">3. Controller相关配置</h2>
<ul>
<li>控制器提供访问应用程序的行为，通常通过接口定义（2.1）或注解定义（2.2）实现，一般开发中使用注解实现</li>
<li>控制器负责解析用户的请求并将其转化为一个模型</li>
<li>一个控制器可以包含多个方法</li>
</ul>
<h3 id="31-controller">3.1 @Controller</h3>
<p>这个注解和@Component、@Service、@Repository作用相同，只是为了区分不同的类。@Controller将类注册到Spring容器中，并声明类的实例是一个控制器</p>
<ul>
<li>@Component：组件</li>
<li>@Service：service</li>
<li>@Controller：controller</li>
<li>@Repository：dao</li>
</ul>
<h3 id="32-requestmapping">3.2 @RequestMapping</h3>
<p>这个注解可以写在类名上或者方法名上，在类名上的注解和方法名上的注解是一种上下级的关系，内部写访问的域名</p>
<h3 id="33-方法返回string">3.3 方法返回String</h3>
<p>因为配置了视图解析器，Controller内部的方法只要返回String，返回结果会被视图解析器处理</p>
<p>比如</p>
<pre><code class="language-java">return &quot;hello&quot;;
</code></pre>
<p>视图解析器会根据配置的内容</p>
<pre><code class="language-xml">&lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt;
&lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt;
</code></pre>
<p>去寻找/WEB-INF/jsp/hello.jsp文件</p>
<h2 id="4-restful风格">4 RESTful风格</h2>
<h3 id="41-概念">4.1 概念</h3>
<p>RESTful是一个资源定位及资源操作的风格，不是标准也不是协议，只是一种风格。基于这个风格设计的软件可以更加简洁，更有层次，更易于实现缓存机制</p>
<h3 id="42-功能">4.2 功能</h3>
<ul>
<li>资源操作：使用POST、DELETE、PUT、GET等不同方法对资源进行操作</li>
</ul>
<p>传统方式</p>
<pre><code class="language-java">@Controller
public class HelloController {
    @RequestMapping(&quot;/add&quot;)
    public String add(int a, int b, Model model) {
        int res = a + b;
        model.addAttribute(&quot;msg&quot;, &quot;answer is &quot; + res);
        return &quot;hello&quot;;
    }
}
</code></pre>
<p>那么，向这个控制器发送请求，我们需要在url中输入localhost:8080/add?a=1&amp;b=2，最后在页面上能显示“answer is 3”</p>
<p>RESTful风格</p>
<pre><code class="language-java">@Controller
public class HelloController {
    @RequestMapping(value=&quot;/add/{a}/{b}&quot;, method=&quot;RequestMethod.GET&quot;)
    public String add(@PathVariable int a, @PathVariable int b, Model model) {
        int res = a + b;
        model.addAttribute(&quot;msg&quot;, &quot;answer is &quot; + res);
        return &quot;hello&quot;;
    }
}
</code></pre>
<p>使用@PathVariable注解，使方法参数的值对应绑定到URI模板变量上。用@RequestMapping来限制请求方法，可以直接用@GetMapping(&quot;/add/{a}/{b}&quot;)来代替。此时，需要在url输入localhost:8080/add/1/2，且请求方法为get才能访问到。如果将method改为RequestMethod.POST，或者注解改为@PostMapping(&quot;/add/{a}/{b}&quot;)，那么url不变，请求方法为post才能访问到</p>
<h3 id="43-优点">4.3 优点</h3>
<ul>
<li>使路径变得更加简洁</li>
<li>获得参数更加方便，框架会自动进行类型转换</li>
</ul>
<h2 id="5-结果跳转方式">5 结果跳转方式</h2>
<h3 id="51-modelandview">5.1 ModelAndView</h3>
<p>在控制器方法内部，要设置ModelAndView对象，根据view的名字和视图解析器跳到指定的页面</p>
<ul>
<li>页面 = 视图解析器前缀 + viewName + 视图解析器后缀</li>
</ul>
<h3 id="52-servletapi">5.2 ServletAPI</h3>
<p>我们也可以通过ServletAPI，不设置ModelAndView和视图解析器来进行页面跳转</p>
<ul>
<li>通过HttpServletResponse进行输出</li>
<li>通过HttpServletResponse实现重定向</li>
<li>通过HttpServletResponse实现转发</li>
</ul>
<p>这种方法实际项目中不推荐使用</p>
<h3 id="53-springmvc实现转发和重定向">5.3 SpringMVC实现转发和重定向</h3>
<ul>
<li>通过SpringMVC实现转发和重定向，不经过视图解析器</li>
</ul>
<pre><code class="language-java">@Controller
public class TestController {
    @RequestMapping(&quot;/tc/t1&quot;)
    public String test1() {
        //实现转发
        return &quot;/WEB-INF/jsp/hello.jsp&quot;;
    }
    
    @RequestMapping(&quot;/tc/t2&quot;)
    public String test2() {
        //实现转发
        return &quot;forward:/WEB-INF/jsp/hello.jsp&quot;;
    }
    
    @RequestMapping(&quot;tc/t3&quot;)
    public String test3() {
        //实现重定向
        return &quot;redirect:/index.jsp&quot;;	//重定向无法直接访问到WEB-INF目录下的文件
    }
}
</code></pre>
<p>没有视图解析器，我们在写页面路径的时候要写其对应的全限定名</p>
<ul>
<li>通过SpringMVC来实现转发和重定向，经过视图解析器</li>
</ul>
<pre><code class="language-java">@Controller
public class TestController {
    @RequestMapping(&quot;/tc/t1&quot;)
    public String test1() {
        //实现转发
        return &quot;hello&quot;;
    }
    
    @RequestMapping(&quot;/tc/t2&quot;)
    public String test2() {
        //实现重定向
        return &quot;redirect:/index.jsp&quot;;
    }
}
</code></pre>
<p>有了视图解析器，控制器方法返回字符串默认就是转发的情况</p>
<h2 id="6-数据处理">6 数据处理</h2>
<h3 id="61-数据从前端到控制器">6.1 数据从前端到控制器</h3>
<p>控制器要接收前端的数据进行处理，那么有这么几种情况</p>
<ol>
<li>提交的域名称和处理方法的参数名一致</li>
</ol>
<p>url：localhost:8080/hello?name=test</p>
<p>处理方法</p>
<pre><code class="language-java">@RequestMapping(&quot;/hello&quot;)
public String hello(String name) {
    System.out.println(name);
    return &quot;hello&quot;;
}
</code></pre>
<ol start="2">
<li>提交的域名称和处理方法的参数不一致</li>
</ol>
<p>url：localhost:8080/hello?username=test</p>
<p>处理方法</p>
<pre><code class="language-java">@RequestMapping(&quot;/hello&quot;)
public String hello(@RequestParam(&quot;username&quot;) String name) {
    System.out.println(name);
    return &quot;hello&quot;;
}
</code></pre>
<p>或者</p>
<pre><code class="language-java">@RequestMapping(&quot;/hello&quot;)
@RequestParam(&quot;username&quot;)
public String hello(String name) {
    System.out.println(name);
    return &quot;hello&quot;;
}
</code></pre>
<ol start="3">
<li>提交的是一个对象</li>
</ol>
<p>要求提交的表单域和对象的属性名一致，方法的参数使用对象</p>
<p>url：localhost:8080/hello?name=test&amp;id=1&amp;&amp;age=18</p>
<p>在User实体类中要保证有属性name，id，age</p>
<p>处理方法</p>
<pre><code class="language-java">@RequestMapping(&quot;/hello&quot;)
public String hello(User user) {
    System.out.println(user);
    return &quot;hello&quot;;
}
</code></pre>
<p>如果前端传递的参数名和对象属性名不一致，结果会输出null</p>
<h3 id="62-数据从控制器到前端">6.2 数据从控制器到前端</h3>
<ol>
<li>通过ModelAndView
<ul>
<li>可以在存储数据的同时，进行设置返回的逻辑视图，进行控制展示层的跳转</li>
</ul>
</li>
<li>通过Model
<ul>
<li>只有几个方法用于存储数据，简化操作</li>
</ul>
</li>
<li>通过ModelMap
<ul>
<li>继承自LinkedHashMap</li>
</ul>
</li>
</ol>
<p>大部分情况下，一般使用Model</p>
<h2 id="7-乱码问题">7 乱码问题</h2>
<p>从前端提交的数据到控制器会出现乱码问题，我们使用过滤器解决，直接在web.xml中配置SpringMVC提供的过滤器</p>
<pre><code class="language-xml">&lt;filter&gt;
    &lt;filter-name&gt;encoding&lt;/filter-name&gt;
    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;encoding&lt;/param-name&gt;
        &lt;param-value&gt;utf-8&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;encoding&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
</code></pre>
<p>当然，我们也可以用自己编写的过滤器，只要实现Filter接口</p>
<h2 id="8-json">8 JSON</h2>
<p>前后端分离，后端部署后端，后端提供接口，前端独立部署，渲染后端数据，前后端通过json格式来交换数据</p>
<h3 id="81-概念">8.1 概念</h3>
<p>JSON（JavaScript Object Notation，JS对象标记）是一种轻量级数据交换格式，采用完全独立于编程语言的<strong>文本格式</strong>来存储和表示数据</p>
<h3 id="82-语法">8.2 语法</h3>
<ul>
<li>对象表示为键值对，数据由逗号分隔</li>
<li>花括号表示对象</li>
<li>方括号保存数组</li>
</ul>
<p>JSON是JavaScript对象的字符串表示法，使用文本表示一个JS对象的信息，本质是一个字符串</p>
<pre><code class="language-javascript">var obj = {a: 'Hello', b: 'world'};	//这是一个对象，键名也可以使用引号
var json = '{&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;world&quot;}';	//这是一个JSON字符串
</code></pre>
<p>JSON和JavaScript对象互转</p>
<pre><code class="language-javascript">var obj = JSON.parse('{&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;world&quot;}');
//结果为 {a: 'Hello', b: 'world' }
var json = JSON.stringify({a: 'Hello', b: 'world'});
//结果为 '{&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;world&quot;}'
</code></pre>
<h3 id="83-controller返回json数据">8.3 Controller返回JSON数据</h3>
<p>使用JSON解析工具Jackson或者fastjson</p>
<ol>
<li>导入Jackson的包</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;
    &lt;version&gt;2.11.0&lt;/version&gt;
&lt;/dependency&gt;

</code></pre>
<ol start="2">
<li>配置web.xml（DispatcherSerlvet、CharacterEncodingFilter）</li>
<li>配置springmvc-servlet.xml（自动扫描包，视图解析器）</li>
<li>编写User实体类</li>
</ol>
<pre><code class="language-java">public class User {
    private String name;
    private int age;
    private String sex;
    
    //省略get/set方法和构造函数
}
</code></pre>
<ol start="5">
<li>编写UserController</li>
</ol>
<pre><code class="language-java">@Controller
public class UserController {
    @RequestMapping(&quot;j1&quot;)
    @ResponseBody
    public String json1() throws JsonProcessingException {
        ObjectMapper mapper = new ObjectMapper();
        User user = new User(&quot;test&quot;, 18, &quot;male&quot;);
        String str = mapper.writeValueAsString(user);
        return str;
    }
}
</code></pre>
<p>使用@ResponseBody，方法返回值不会走视图解析器，会直接返回字符串。在url输入localhost:8080/j1，页面上显示json字符串 {&ldquo;name&rdquo;: &ldquo;test&rdquo;, &ldquo;age&rdquo;: &ldquo;18&rdquo;, &ldquo;sex&rdquo;: &ldquo;male&rdquo;}。除了使用@ResponseBody，还可以在类上使用@RestController，而不使用@Controller，那么类中的所有方法都会返回字符串</p>
<p>如果出现乱码问题，我们可以在springmvc-serclet.xml文件中配置</p>
<pre><code class="language-xml">&lt;mvc:annotation-driven&gt;
    &lt;mvc:message-converters register-defaults=&quot;trued&quot;&gt;
        &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;
            &lt;constructor-arg value=&quot;UTF-8&quot;/&gt;
        &lt;/bean&gt;
        &lt;bean class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&gt;
            &lt;property name=&quot;objectMapper&quot;&gt;
                &lt;bean class=&quot;org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean&quot;&gt;
                    &lt;property name=&quot;failOnEmptyBeans&quot; value=&quot;false&quot;/&gt;
                &lt;/bean&gt;
            &lt;/property&gt;
        &lt;/bean&gt;
    &lt;/mvc:message-converters&gt;
&lt;/mvc:annotation-driven&gt;
</code></pre>
<p>如果使用fastjson，使用方法和Jackson类似</p>
<h2 id="9-拦截器">9 拦截器</h2>
<p>拦截器类似于过滤器Filter，用于对处理器进行预处理和后处理</p>
<p>过滤器和拦截器的区别：拦截器是AOP思想的具体应用</p>
<ul>
<li>过滤器
<ul>
<li>servlet规范中的一部分，任何JavaWeb都可以使用</li>
<li>在url-pattern中配置了/*之后，可以对所有要访问的资源进行拦截</li>
</ul>
</li>
<li>拦截器
<ul>
<li>拦截器是SpringMVC框架的，只有使用了SpringMVC框架的项目才能使用</li>
<li>拦截器只会拦截访问的控制器方法，如果访问的是jsp/html/css/image/js是不会进行拦截的</li>
</ul>
</li>
</ul>
<h3 id="91-自定义拦截器">9.1 自定义拦截器</h3>
<p>想要自定义拦截器，只要编写的类实现HandlerInterceptor接口</p>
<pre><code class="language-java">public class MyInterceptor implements HandlerInterceptor {
    
    //return true: 放行，执行下一个拦截器
    //return false: 不放行
    public boolean preHandle(HttpServletRequest req, HttpServletResponse resp, Object handler) throws Exception {
        System.out.println(&quot;处理前&quot;);
        return true;
    }
    
    public void postHandle(HttpServletRequest req, HttpServletResponse resp, Object handler, ModelAndView modelAndView) throws Exception {
        System.out.println(&quot;处理后&quot;);
    }
    
    public void afterCompletion(HttpServletRequest req, HttpServletResponse resp, Object handler, Exception ex) throws Exception {
        System.out.println(&quot;请理&quot;);
    }
}
</code></pre>
<p>配置拦截器</p>
<pre><code class="language-xml">&lt;mvc:interceptors&gt;
    &lt;mvc:interceptor&gt;
        &lt;!--/**代表这个请求下的所有请求--&gt;
        &lt;mvc:mapping path=&quot;/**&quot;/&gt;
        &lt;bean class=&quot;com.hjc.config.MyInterceptor&quot;/&gt;
    &lt;/mvc:interceptor&gt;
&lt;/mvc:interceptors&gt;
</code></pre>
<p>只要访问任一控制器，拦截器的三个方法都会执行，首先执行preHandle，再执行控制器方法，最后执行postHandle和afterCompletion方法。如果preHandle方法返回false，那么访问控制器时，只会执行preHandle方法，不会执行后续方法</p>
<h3 id="92-拦截器实现登陆判断验证">9.2 拦截器实现登陆判断验证</h3>
<p>编写LoginController</p>
<pre><code class="language-java">@Controller
@RequestMapping(&quot;/user&quot;)
public class LoginController {
        
    @RequestMapping(&quot;/main&quot;)
    public String main() {
        return &quot;main&quot;;
    }
    
    @RequestMapping(&quot;/goLogin&quot;)
    public String goLogin() {
        return &quot;login&quot;;
    }
    
    @RequestMappint(&quot;/login&quot;)
    public String login(HttpSession session, String username, String password) {
        //省略判断username, password的代码
        session.setAttribute(&quot;userLoginInfo&quot;, username);
        return &quot;main&quot;;
    }
}
</code></pre>
<p>在首页index.jsp中放置两个超链接，分别跳向“/goLogin”和“/main”，方法分别返回登陆页面login.jsp和main.jsp（放置于WEB-INF/jsp/目录下）</p>
<p>编写一个拦截器，使得未登录时无法访问main.jsp</p>
<pre><code class="language-java">public class LoginInterceptor implements HandlerInterceptor {
    public boolean preHandler(HttpServletRequest req, HttpServletResponse resp, Object handler) throws Exception {
        HttpSession session = req.getSession();
        if (req.getRequestURI().contains(&quot;goLogin&quot;)) {
            return true;
        }
        if (req.getRequestURI().contains(&quot;login&quot;)) {
            return true;
        }
        if (session.getAttribute(&quot;userLoginInfo&quot;) != null) {
            return true;
        }
        req.getRequestDispatcher(&quot;/WEB-INF/jsp/login.jsp&quot;).forward();
        return false;
    }
}
</code></pre>
<p>配置拦截器</p>
<pre><code class="language-xml">&lt;mvc:interceptors&gt;
    &lt;mvc:interceptor&gt;
        &lt;!--/**代表这个请求下的所有请求--&gt;
        &lt;mvc:mapping path=&quot;/user/**&quot;/&gt;
        &lt;bean class=&quot;com.hjc.config.LoginInterceptor&quot;/&gt;
    &lt;/mvc:interceptor&gt;
&lt;/mvc:interceptors&gt;
</code></pre>

    </div>
</article>


<div class="license markdown-body">
    <blockquote>
        <p>除特殊注明部分，本站内容采用 <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"
               target="_blank">CC BY-NC-SA 4.0</a> 进行许可。</p>
    </blockquote>
</div>



            </div>
            <aside class="col-12 col-md-3 float-left sidebar">
    
    
    
    <div class="sidebar-item sidebar-toc">
        <h3>目录</h3>
        <nav id="TableOfContents">
  <ul>
    <li><a href="#1-简介">1 简介</a>
      <ul>
        <li><a href="#11-定义">1.1 定义</a></li>
        <li><a href="#12-设计">1.2 设计</a></li>
      </ul>
    </li>
    <li><a href="#2-hellospringmvc">2 HelloSpringMVC</a>
      <ul>
        <li><a href="#21-xml配置">2.1 xml配置</a></li>
        <li><a href="#22-注解配置">2.2 注解配置</a></li>
      </ul>
    </li>
    <li><a href="#3-controller相关配置">3. Controller相关配置</a>
      <ul>
        <li><a href="#31-controller">3.1 @Controller</a></li>
        <li><a href="#32-requestmapping">3.2 @RequestMapping</a></li>
        <li><a href="#33-方法返回string">3.3 方法返回String</a></li>
      </ul>
    </li>
    <li><a href="#4-restful风格">4 RESTful风格</a>
      <ul>
        <li><a href="#41-概念">4.1 概念</a></li>
        <li><a href="#42-功能">4.2 功能</a></li>
        <li><a href="#43-优点">4.3 优点</a></li>
      </ul>
    </li>
    <li><a href="#5-结果跳转方式">5 结果跳转方式</a>
      <ul>
        <li><a href="#51-modelandview">5.1 ModelAndView</a></li>
        <li><a href="#52-servletapi">5.2 ServletAPI</a></li>
        <li><a href="#53-springmvc实现转发和重定向">5.3 SpringMVC实现转发和重定向</a></li>
      </ul>
    </li>
    <li><a href="#6-数据处理">6 数据处理</a>
      <ul>
        <li><a href="#61-数据从前端到控制器">6.1 数据从前端到控制器</a></li>
        <li><a href="#62-数据从控制器到前端">6.2 数据从控制器到前端</a></li>
      </ul>
    </li>
    <li><a href="#7-乱码问题">7 乱码问题</a></li>
    <li><a href="#8-json">8 JSON</a>
      <ul>
        <li><a href="#81-概念">8.1 概念</a></li>
        <li><a href="#82-语法">8.2 语法</a></li>
        <li><a href="#83-controller返回json数据">8.3 Controller返回JSON数据</a></li>
      </ul>
    </li>
    <li><a href="#9-拦截器">9 拦截器</a>
      <ul>
        <li><a href="#91-自定义拦截器">9.1 自定义拦截器</a></li>
        <li><a href="#92-拦截器实现登陆判断验证">9.2 拦截器实现登陆判断验证</a></li>
      </ul>
    </li>
  </ul>
</nav>
    </div>
    
    
    
    <div class="sidebar-item sidebar-pages">
        <h3>页面</h3>
        <ul>
            
            <li>
                <a href="/">Home</a>
            </li>
            
            <li>
                <a href="/archives/">Archives</a>
            </li>
            
            <li>
                <a href="/about/">About</a>
            </li>
            
            <li>
                <a href="/search/">Search</a>
            </li>
            
            <li>
                <a href="/index.xml">RSS</a>
            </li>
            
        </ul>
    </div>
    
    <div class="sidebar-item sidebar-tags">
        <h3>标签</h3>
        <div>
            
            <span>
                <a href="/tags/c&#43;&#43;/">c&#43;&#43;</a>
            </span>
            
            <span>
                <a href="/tags/java/">java</a>
            </span>
            
            <span>
                <a href="/tags/jdbc/">jdbc</a>
            </span>
            
            <span>
                <a href="/tags/mybatis/">mybatis</a>
            </span>
            
            <span>
                <a href="/tags/network/">network</a>
            </span>
            
            <span>
                <a href="/tags/servlet/">servlet</a>
            </span>
            
            <span>
                <a href="/tags/spring/">spring</a>
            </span>
            
            <span>
                <a href="/tags/springmvc/">springmvc</a>
            </span>
            
            <span>
                <a href="/tags/web/">web</a>
            </span>
            
            <span>
                <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
            </span>
            
            <span>
                <a href="/tags/%E7%AE%97%E6%B3%95/">算法</a>
            </span>
            
        </div>
    </div>
    
    <div class="sidebar-item sidebar-links">
        <h3>链接</h3>
        <ul>
            
            <li>
                <a href="https://github.com/keichw" target="_blank"><span>GitHub</span></a>
            </li>
            
        </ul>
    </div>
    
</aside>
        </div>
        <div class="btn">
    <div class="btn-toggle-mode">
        <ion-icon name="contrast"></ion-icon>
    </div>
    <div class="btn-scroll-top">
        <ion-icon name="chevron-up"></ion-icon>
    </div>
</div>
    </main>

    <footer>
    <div class="container-lg clearfix">
        <div class="col-12 footer">
            <span>&copy; 2020 <a href="https://keichw.github.io">Kinopio</a> |
                基于 <a href="https://github.com/amzrk2/hugo-theme-fuji/"
                   target="_blank">Fuji-v2</a> & <a href="https://gohugo.io/"
                   target="_blank">Hugo</a> 构建</span>
        </div>
    </div>
</footer>
    
    <script async type="module" src="https://cdn.jsdelivr.net/npm/ionicons@5.0.1/dist/ionicons/ionicons.esm.js"></script>
<script async nomodule src="https://cdn.jsdelivr.net/npm/ionicons@5.0.1/dist/ionicons/ionicons.js"></script>

<script defer src="https://cdn.jsdelivr.net/npm/prismjs@1.20.0/components/prism-core.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/prismjs@1.20.0/plugins/autoloader/prism-autoloader.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/lazysizes@5.2.2/lazysizes.min.js"></script>

<script defer src="/assets/js/fuji.min.js"></script>

</body>

</html>