<!DOCTYPE html>
<html lang="zh-hans">

<head>
    
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
<meta name="HandheldFriendly" content="True" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
<meta name="generator" content="Hugo 0.73.0" />



<link rel="apple-touch-icon" sizes="180x180" href="https://cdn.jsdelivr.net/gh/amzrk2/poal-jsdelivr@1.6.0/favicons/apple-touch-icon.png" />
<link rel="icon" type="image/png" sizes="32x32" href="https://cdn.jsdelivr.net/gh/amzrk2/poal-jsdelivr@1.6.0/favicons/favicon-32x32.png" />
<link rel="icon" type="image/png" sizes="16x16" href="https://cdn.jsdelivr.net/gh/amzrk2/poal-jsdelivr@1.6.0/favicons/favicon-16x16.png" />
<link rel="manifest" href="https://cdn.jsdelivr.net/gh/amzrk2/poal-jsdelivr@1.6.0/favicons/site.webmanifest" />
<link rel="mask-icon" href="https://cdn.jsdelivr.net/gh/amzrk2/poal-jsdelivr@1.6.0/favicons/safari-pinned-tab.svg" color="#8aa2d3" />
<link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/amzrk2/poal-jsdelivr@1.6.0/favicons/favicon.ico" />
<meta name="msapplication-TileColor" content="#8aa2d3" />
<meta name="msapplication-config" content="https://cdn.jsdelivr.net/gh/amzrk2/poal-jsdelivr@1.6.0/favicons/browserconfig.xml" />
<meta name="theme-color" content="#ffffff" />


<title>图 - Kinopio BLOG</title>


<meta name="author" content="Kinopio" />


<meta name="description" content="A minimal Hugo theme with nice theme color." />


<meta name="keywords" content="数据结构" />

<meta property="og:title" content="图" />
<meta property="og:description" content="基本概念 图表示多对多的关系。包含 一组顶点：通常用V(Vertex)表示顶点集合 一组边：通常用E(Edge)表示边的集合 边是顶点对：(v,w)是集合E的元素，其中v，w是集合V的元素 有向边&lt;v,w" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://example.com/post/graph/" />
<meta property="og:image" content="https://example.com/img/og.png"/>
<meta property="article:published_time" content="2019-07-27T23:30:00+08:00" />
<meta property="article:modified_time" content="2019-07-27T23:30:00+08:00" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://example.com/img/og.png"/>

<meta name="twitter:title" content="图"/>
<meta name="twitter:description" content="基本概念 图表示多对多的关系。包含 一组顶点：通常用V(Vertex)表示顶点集合 一组边：通常用E(Edge)表示边的集合 边是顶点对：(v,w)是集合E的元素，其中v，w是集合V的元素 有向边&lt;v,w"/>



<style>
    @media (prefers-color-scheme: dark) {
        body[data-theme='auto'] img {
            filter: brightness(60%);
        }
    }

    body[data-theme='dark'] img {
        filter: brightness(60%);
    }
</style>


<link rel="stylesheet" href="/assets/css/fuji.min.css" />






</head>

<body data-theme="auto">
    <script data-cfasync="false">
    
    var fujiThemeData = localStorage.getItem('fuji_data-theme');
    
    if (!fujiThemeData) {
        localStorage.setItem('fuji_data-theme', 'auto');
    } else {
        
        if (fujiThemeData !== 'auto') {
            document.body.setAttribute('data-theme', fujiThemeData === 'dark' ? 'dark' : 'light');
        }
    }
</script>
<script data-cfasync="false">
    
    function browserDetection(ua) {
        if (ua.indexOf('MSIE ') > 0 || ua.indexOf('Trident/') > 0) {
            return true;
        }
        return false;
    }

    var ua = window.navigator.userAgent;
    if (browserDetection(ua)) {
        window.location.href('https:\/\/example.com\/ie\/');
    }
</script>
    <header>
    <div class="container-lg clearfix">
        <div class="col-12 header">
            <a class="title-main" href="https://example.com">Kinopio BLOG</a>
            
            <span class="title-sub">(ง •̀_•́)ง</span>
            
        </div>
    </div>
</header>

    <main>
        <div class="container-lg clearfix">
            
            <div class="col-12 col-md-9 float-left content">
                
<article>
    
    <h2 class="post-item post-title">
        <a href="https://example.com/post/graph/">图</a>
    </h2>
    <div class="post-item post-meta">
        <span><ion-icon name="today"></ion-icon>&nbsp;2019-07-27</span><span><ion-icon name="file-tray"></ion-icon>&nbsp;2358 字</span><span><ion-icon name="stopwatch"></ion-icon>&nbsp;5 分钟</span><span><ion-icon name="pricetags"></ion-icon>&nbsp;<a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">数据结构</a>&nbsp;</span>
    </div>
    
    
    <div class="post-content markdown-body">
        <h3 id="基本概念">基本概念</h3>
<!-- more -->
<p>图表示多对多的关系。包含</p>
<ul>
<li>一组顶点：通常用V(Vertex)表示顶点集合</li>
<li>一组边：通常用E(Edge)表示边的集合
<ul>
<li>边是顶点对：(v,w)是集合E的元素，其中v，w是集合V的元素</li>
<li>有向边&lt;v,w&gt;表示从v指向w的边(单行线)</li>
<li>不考虑重边和自回路</li>
</ul>
</li>
</ul>
<h3 id="抽象数据类型定义">抽象数据类型定义</h3>
<p>类型名称：图
数据对象集：G(V,E)由一个非空的有限顶点集合V和一个有限边集合E组成
操作集：对于任意图G，以及v，e</p>
<ul>
<li>Graph Create()：建立并返回空图</li>
<li>Graph InsertVertex(Graph G, Vertex v)：将v插入G</li>
<li>Graph InsertEdge(Graph G, Edge e)：将e插入G</li>
<li>void DFS(Graph G, Vertex v)：从顶点v出发深度优先遍历图G</li>
<li>void BFS(Graph G, Vertex v)：从顶点v出发广度优先遍历图G</li>
<li>void ShortestPath(Graph G, Vertex v, int Dist[])：计算图G中顶点v到任意其他顶点的最短距离</li>
<li>void MST(Graph G)：计算图G的最小生成树</li>
</ul>
<h3 id="图的表示">图的表示</h3>
<p>图有两种表示方法，邻接矩阵和邻接表</p>
<p>我们可以创建一个二维数组G[N][N]，若&lt;vi,vj&gt;是G中的边，则G[i][j]=1，否则为0。对于有向图，邻接矩阵是对称的，而对于无向图则不是。对于网络，G[i][j]的值是边&lt;vi,vj&gt;的权重，如果没有边，则为-∞。</p>
<p>邻接矩阵的优点</p>
<ul>
<li>直观、简单、好理解</li>
<li>方便检查任意一对顶点间是否存在边</li>
<li>方便找任一顶点的所有“邻接点”（有边直接相连的顶点）</li>
<li>方便计算任一顶点的“度”（从该点出发的边数为“出度”，指向该点的边数为“入度”）
<ul>
<li>无向图：对应行（或列）非0元素的个数</li>
<li>有向图：对应行非0元素的个数是“出度”，对应列非0元素的个数是“入度”</li>
</ul>
</li>
</ul>
<p>邻接矩阵的缺点</p>
<ul>
<li>浪费空间：存稀疏图（点很多而边很少）有大量无效元素
<ul>
<li>对稠密图（特别是完全图）还是很合算的</li>
</ul>
</li>
<li>浪费时间：统计稀疏图中一共有多少条边</li>
</ul>
<p>同时，我们可以创建一个指针数组G[N]，对应矩阵每行一个链表，只存非0元素。对于网络，链表结构中要增加权重的域。</p>
<p>邻接表的优点</p>
<ul>
<li>方便找任一顶点的所有“邻接点”</li>
<li>节约稀疏图的空间
<ul>
<li>需要N个头指针+2E个结点（每个结点至少2个域）</li>
</ul>
</li>
<li>方便计算任一顶点的“度”
<ul>
<li>无向图：任一顶点的度就是链表的长度</li>
<li>有向图：只能计算“出度”，需要构造“逆邻接表”（存指向自己的边）来方便计算“出度”</li>
</ul>
</li>
</ul>
<p>邻接表的缺点</p>
<ul>
<li>不方便检查任意一对顶点间是否存在边</li>
</ul>
<h3 id="邻接矩阵表示">邻接矩阵表示</h3>
<h5 id="结构体定义">结构体定义</h5>
<pre><code>#define MaxVertexNum 100
#define INFINITY 65535

typedef int Vertex;    		//用顶点下标表示顶点，为整型
typedef int WeightType;
typedef char DataType;

typedef struct ENode *PtrToENode;
struct ENode{		//边的定义
	Vertex V1,V2;		//有向边&lt;v1,v2&gt;
	WeightType Weight;		//权重
};
typedef PtrToENode Edge;

typedef struct GNode *PtrToGNode;
struct GNode{		//图结点的定义
	int Nv;		//顶点数
	int Ne;		//边数
	WeightType G[MaxVertexNum][MaxVertexNum];		//邻接矩阵
	DataType Data[MaxVertexNum];		//存顶点的数据，如果顶点不存数据，可以省略
};
typedef PtrToGNode MGraph;
</code></pre>
<h5 id="图的初始化">图的初始化</h5>
<pre><code>MGraph CreateGraph(int VertexNum){     //初始化一个有VertexNum个顶点但没有边的图
    Vertex V,W;
    MGraph Graph;

    Graph=(MGraph)malloc(sizeof(struct GNode));      //建立图
    Graph-&gt;Nv=VertexNum;
    Graph-&gt;Ne=0;

    for(V=0;V&lt;Graph-&gt;Nv;V++)      //初始化邻接矩阵，顶点编号为0-(Nv-1)
       for(W=0;W&lt;Graph-&gt;Nv;W++)
          Graph-&gt;G[V][W]=INFINITY;

    return Graph;
}
</code></pre>
<h5 id="边的插入">边的插入</h5>
<pre><code>void InsertEdge(MGraph Graph, Edge E){
    Graph-&gt;G[E-&gt;V1][E-&gt;V2]=E-&gt;Weight;      //插入边&lt;V1,V2&gt;
    Graph-&gt;G[E-&gt;V2][E-&gt;V1]=E-&gt;Weight;      //若是无向图，还要插入边&lt;V2,V1&gt;
}
</code></pre>
<h5 id="图的建立">图的建立</h5>
<pre><code>MGraph BuildGraph(){
    MGraph Graph;
    Edge E;
    Vertex V;
    int Nv,i;

    scanf(&quot;%d&quot;,&amp;Nv);     //读入顶点个数
    Graph=CreateGraph(Nv);     //初始化有Nv个顶点但没有边的图

    scanf(&quot;%d&quot;,&amp;(Graph-&gt;Ne));     //读入边数
    if(Graph-&gt;Ne!=0){
       E=(Edge)malloc(sizeof(struct ENode));     //建立边结点
       for(i=0;i&lt;Graph-&gt;Ne;i++){
          scanf(&quot;%d %d %d&quot;,&amp;(E-&gt;V1),&amp;(E-&gt;V2),&amp;(E-&gt;Weight));     //读入边
          InsertEdge(Graph,E);    //插入边
       }
    }

    for(V=0;V&lt;Graph-&gt;Nv;V++)
       scanf(&quot;%d&quot;,&amp;(Graph-&gt;Data[V]));      //如果顶点有数据，则读入数据

    return Graph;
}
</code></pre>
<h3 id="邻接表表示">邻接表表示</h3>
<h5 id="结构体定义-1">结构体定义</h5>
<pre><code>#define MaxVertexNum 100

typedef int Vertex;     //顶点下标表示顶点，为整型
typedef int WeightType;
typedef char DataType;

typedef struct ENode *PtrToENode;
struct ENode{     //边的定义
    Vertex V1,V2;     //有向边&lt;V1,V2&gt;
    WeightType Weight;
};
typedef PtrToENode Edge;

typedef struct AdjVNode *PtrToAdjVNode;
struct AdjVNode{     //邻接点的定义
    Vertex AdjV;      //邻接点下标
    WeightType Weight;      //边权重
    PtrToAdjVNode Next;     //指向下一个邻接点的指针
};

typedef struct Vnode{      //顶点表头结点的定义
    PtrToAdjVNode FirstEdge;      //边表头指针
    DataType Data;       //存顶点的数据
}AdjList[MaxVertexNum];       //AdjList是邻接表类型的数组

typedef struct GNode *PtrToGNode;
struct GNode{     //图结点的定义
    int Nv;     //顶点数
    int Ne;     //边数
    AdjList G;     //邻接表
};
typedef PtrToGNode LGraph;
</code></pre>
<h5 id="图的初始化-1">图的初始化</h5>
<pre><code>LGraph CreateGraph(int VertexNum){      //初始化一个有VertexNum个顶点但没有边的图
    Vertex V;
    LGraph Graph;

    Graph=(LGraph)malloc(sizeof(struct GNode));     //建立图
    Graph-&gt;Nv=VertexNum;
    Graph-&gt;Ve=0;

    for(V=0;V&lt;Graph-&gt;Nv;V++)        //初始化邻接表头指针，定点编号0-(Graph-&gt;Nv-1)
       Graph-&gt;G[V].FirstEdge=NULL;

    return Graph;
}
</code></pre>
<h5 id="边的插入-1">边的插入</h5>
<pre><code>void InsertEdge(LGraph Graph, Edge E){
    PtrToAdjVNode NewNode;
    //插入边&lt;V1,V2&gt;
    NewNode=(PtrToAdjVNode)malloc(sizeof(struct AdjVNode));     //为V2建立新的邻接点
    NewNode-&gt;AdjV=E-&gt;V2;
    NewNode-&gt;Weight=E-&gt;Weight;
    //将V2插入V1的表头
    NewNode-&gt;Next=Graph-&gt;G[E-&gt;V1].FirstEdge;
    Graph-&gt;G[E-&gt;V1].FirstEdge=NewNode;
    //若是无向图，还要插入边&lt;V2,V1&gt;
    NewNode=(PtrToAdjVNode)malloc(sizeof(struct AdjVNode));     //为V1建立新的邻接点
    NewNode-&gt;AdjV=E-&gt;V1;
    NewNode-&gt;Weight=E-&gt;Weight;
    //将V1插入V2的表头
    NewNode-&gt;Next=Graph-&gt;G[E-&gt;V2].FirstEdge;
    Graph-&gt;G[E-&gt;V1].FirstEdge=NewNode;
}
</code></pre>
<h5 id="图的建立-1">图的建立</h5>
<pre><code>LGraph BuildGraph(){
    LGraph Graph;
    Edge E;
    Vertex V;
    int Nv,i;

    scanf(&quot;%d&quot;,&amp;Nv);        //读入顶点个数
    Graph=CreateGraph(Nv);      //初始化有Nv个顶点但没有边的图

    scanf(&quot;%d&quot;,&amp;(Graph-&gt;Ne));       //读入边数
    if(Graph-&gt;Ne!=0){
        E=(Edge)malloc(sizeof(struct ENode));       //建立边结点
        for(i=0;i&lt;Graph-&gt;Ne;i++){
            scanf(&quot;%d %d %d&quot;,&amp;(E-&gt;V1),&amp;(E-&gt;V2),&amp;(E-&gt;Weight));       //读入边的起点、终点、权重
            InsertEdge(Graph,E);        //插入边
        }
    }

    for(V=0;V&lt;Graph-&gt;Nv;V++)        //如果顶点有数据，读入数据
        scanf(&quot;%d&quot;,&amp;(Graph-&gt;G[V].Data));

    return Graph;
}
</code></pre>
<h3 id="图的遍历">图的遍历</h3>
<p>图的遍历有两种方法，深度优先搜索(DFS)和广度优先搜索(BFS)。</p>
<h5 id="深度优先搜索">深度优先搜索</h5>
<p>图的深度优先搜索类似于树的先序遍历。若有N个顶点、E条边，时间复杂度为</p>
<ul>
<li>用邻接表存储图，有O(N+E)</li>
<li>用邻接矩阵存储图，有O(N^2)</li>
</ul>
<p>伪代码如下：</p>
<pre><code>void DFS(Vertex V){
    visited[V]=true;
    for(V的每个邻接点W)
        if(!visited[W])
            DFS(W);
}
</code></pre>
<p>C语言代码如下：</p>
<pre><code>void Visit(Vertex V){
    printf(&quot;正在访问顶点%d&quot;,V);
}

void DFS(LGraph Graph, Vertex V, void (*Visit)(Vertex)){        //以V为出发点对邻接表存储的图Graph进行DFS
    PtrToAdjVNode W;

    Visit(V);       //访问第V个顶点
    Visited[V]=true;        //Visited[]为全局变量，初始化为false，已访问则标记为true

    for(W=Graph-&gt;G[V].FirstEdge;W;W=W-&gt;Next)        //对V的每个邻接点W-&gt;AdjV
        if(!Visited[W-&gt;AdjV])       //若W-&gt;AdjV未被访问
            DFS(Graph,W-&gt;AdjV,Visit);       //则递归访问
}
</code></pre>
<h5 id="广度优先搜索">广度优先搜索</h5>
<p>图的广度优先搜索类似于树的层序遍历，需要使用队列。若有N个顶点、E条边，时间复杂度为</p>
<ul>
<li>用邻接表存储图，有O(N+E)</li>
<li>用邻接矩阵存储图，有O(N^2)</li>
</ul>
<p>伪代码如下：</p>
<pre><code>void BFS(Vertex V){
    visited[V]=true;
    Enqueue(V,Q);
    while(!IsEmpty(Q)){
        V=Dequeue(Q);
        for(V的每个邻接点W)
            if(!visited[W]){
                visited[W]=true;
                Enqueue(W,Q);
            }
    }
}
</code></pre>
<p>C语言代码如下：</p>
<pre><code>bool IsEdge(MGraph Graph, Vertex V, Vertex W){      //判断&lt;V,W&gt;是否是图Graph中的一条边，即W是否是V的邻接点
    return Graph-&gt;G[V][W]&lt;INFINITY?true:false;
}

void BFS(MGraph Graph, Vertex S, void (*Visit)(Vertex)){        //以S为出发点对邻接矩阵存储的图Graphj进行BFS
    Queue Q;
    Vertex V,W;

    Q=CreateQueue(MaxSize);     //创建空队列

    Visit(S);
    Visited[S]=true;
    AddQ(Q,S);      //S入队

    while(!IsEmpty(Q)){
        V=DeleteQ(Q);       //出队
        for(W=0;W,Graph-&gt;Nv;W++)        //对于图中的每个顶点W
            if(!Visited[W]&amp;&amp;IsEdge(Graph,V,W)){     //如果W是V的临界点且未被访问过
                Visit(W);
                Visited[W]=true;
                AddQ(Q,W);
            }
    }
}
</code></pre>

    </div>
</article>


<div class="license markdown-body">
    <blockquote>
        <p>除特殊注明部分，本站内容采用 <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"
               target="_blank">CC BY-NC-SA 4.0</a> 进行许可。</p>
    </blockquote>
</div>



            </div>
            <aside class="col-12 col-md-3 float-left sidebar">
    
    
    
    <div class="sidebar-item sidebar-toc">
        <h3>目录</h3>
        <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#基本概念">基本概念</a></li>
        <li><a href="#抽象数据类型定义">抽象数据类型定义</a></li>
        <li><a href="#图的表示">图的表示</a></li>
        <li><a href="#邻接矩阵表示">邻接矩阵表示</a></li>
        <li><a href="#邻接表表示">邻接表表示</a></li>
        <li><a href="#图的遍历">图的遍历</a></li>
      </ul>
    </li>
  </ul>
</nav>
    </div>
    
    
    
    <div class="sidebar-item sidebar-pages">
        <h3>页面</h3>
        <ul>
            
            <li>
                <a href="/">Home</a>
            </li>
            
            <li>
                <a href="/archives/">Archives</a>
            </li>
            
            <li>
                <a href="/about/">About</a>
            </li>
            
            <li>
                <a href="/search/">Search</a>
            </li>
            
            <li>
                <a href="/index.xml">RSS</a>
            </li>
            
        </ul>
    </div>
    
    <div class="sidebar-item sidebar-tags">
        <h3>标签</h3>
        <div>
            
            <span>
                <a href="/tags/c&#43;&#43;/">c&#43;&#43;</a>
            </span>
            
            <span>
                <a href="/tags/java/">java</a>
            </span>
            
            <span>
                <a href="/tags/jdbc/">jdbc</a>
            </span>
            
            <span>
                <a href="/tags/mybatis/">mybatis</a>
            </span>
            
            <span>
                <a href="/tags/servlet/">servlet</a>
            </span>
            
            <span>
                <a href="/tags/spring/">spring</a>
            </span>
            
            <span>
                <a href="/tags/springmvc/">springmvc</a>
            </span>
            
            <span>
                <a href="/tags/web/">web</a>
            </span>
            
            <span>
                <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
            </span>
            
            <span>
                <a href="/tags/%E7%AE%97%E6%B3%95/">算法</a>
            </span>
            
        </div>
    </div>
    
    <div class="sidebar-item sidebar-links">
        <h3>链接</h3>
        <ul>
            
            <li>
                <a href="https://github.com/keichw" target="_blank"><span>GitHub</span></a>
            </li>
            
        </ul>
    </div>
    
</aside>
        </div>
        <div class="btn">
    <div class="btn-toggle-mode">
        <ion-icon name="contrast"></ion-icon>
    </div>
    <div class="btn-scroll-top">
        <ion-icon name="chevron-up"></ion-icon>
    </div>
</div>
    </main>

    <footer>
    <div class="container-lg clearfix">
        <div class="col-12 footer">
            <span>&copy; 2020 <a href="https://example.com">Kinopio</a> |
                基于 <a href="https://github.com/amzrk2/hugo-theme-fuji/"
                   target="_blank">Fuji-v2</a> & <a href="https://gohugo.io/"
                   target="_blank">Hugo</a> 构建</span>
        </div>
    </div>
</footer>
    
    <script async type="module" src="https://cdn.jsdelivr.net/npm/ionicons@5.0.1/dist/ionicons/ionicons.esm.js"></script>
<script async nomodule src="https://cdn.jsdelivr.net/npm/ionicons@5.0.1/dist/ionicons/ionicons.js"></script>

<script defer src="https://cdn.jsdelivr.net/npm/prismjs@1.20.0/components/prism-core.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/prismjs@1.20.0/plugins/autoloader/prism-autoloader.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/lazysizes@5.2.2/lazysizes.min.js"></script>

<script defer src="/assets/js/fuji.min.js"></script>

</body>

</html>