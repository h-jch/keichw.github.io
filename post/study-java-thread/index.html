<!DOCTYPE html>
<html lang="zh-hans">

<head>
    
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
<meta name="HandheldFriendly" content="True" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
<meta name="generator" content="Hugo 0.73.0" />



<link rel="apple-touch-icon" sizes="180x180" href="https://cdn.jsdelivr.net/gh/amzrk2/poal-jsdelivr@1.6.0/favicons/apple-touch-icon.png" />
<link rel="icon" type="image/png" sizes="32x32" href="https://cdn.jsdelivr.net/gh/amzrk2/poal-jsdelivr@1.6.0/favicons/favicon-32x32.png" />
<link rel="icon" type="image/png" sizes="16x16" href="https://cdn.jsdelivr.net/gh/amzrk2/poal-jsdelivr@1.6.0/favicons/favicon-16x16.png" />
<link rel="manifest" href="https://cdn.jsdelivr.net/gh/amzrk2/poal-jsdelivr@1.6.0/favicons/site.webmanifest" />
<link rel="mask-icon" href="https://cdn.jsdelivr.net/gh/amzrk2/poal-jsdelivr@1.6.0/favicons/safari-pinned-tab.svg" color="#8aa2d3" />
<link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/amzrk2/poal-jsdelivr@1.6.0/favicons/favicon.ico" />
<meta name="msapplication-TileColor" content="#8aa2d3" />
<meta name="msapplication-config" content="https://cdn.jsdelivr.net/gh/amzrk2/poal-jsdelivr@1.6.0/favicons/browserconfig.xml" />
<meta name="theme-color" content="#ffffff" />


<title>Java多线程笔记 - Kinopio BLOG</title>


<meta name="author" content="Kinopio" />


<meta name="description" content="A minimal Hugo theme with nice theme color." />


<meta name="keywords" content="java" />

<meta property="og:title" content="Java多线程笔记" />
<meta property="og:description" content="1 定义 程序 程序是指令和数据的有序集合，没有任何运行的含义，是个静态的概念 进程（process） 进程是执行程序的一次执行过程，是动态的概念 进程是系统资源分配的单位 线程（thread） 一个进程中可以包含若" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://keichw.github.io/post/study-java-thread/" />
<meta property="og:image" content="https://keichw.github.io/img/og.png"/>
<meta property="article:published_time" content="2020-07-26T00:13:07+08:00" />
<meta property="article:modified_time" content="2020-07-26T00:13:07+08:00" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://keichw.github.io/img/og.png"/>

<meta name="twitter:title" content="Java多线程笔记"/>
<meta name="twitter:description" content="1 定义 程序 程序是指令和数据的有序集合，没有任何运行的含义，是个静态的概念 进程（process） 进程是执行程序的一次执行过程，是动态的概念 进程是系统资源分配的单位 线程（thread） 一个进程中可以包含若"/>



<style>
    @media (prefers-color-scheme: dark) {
        body[data-theme='auto'] img {
            filter: brightness(60%);
        }
    }

    body[data-theme='dark'] img {
        filter: brightness(60%);
    }
</style>


<link rel="stylesheet" href="/assets/css/fuji.min.css" />






</head>

<body data-theme="auto">
    <script data-cfasync="false">
    
    var fujiThemeData = localStorage.getItem('fuji_data-theme');
    
    if (!fujiThemeData) {
        localStorage.setItem('fuji_data-theme', 'auto');
    } else {
        
        if (fujiThemeData !== 'auto') {
            document.body.setAttribute('data-theme', fujiThemeData === 'dark' ? 'dark' : 'light');
        }
    }
</script>
<script data-cfasync="false">
    
    function browserDetection(ua) {
        if (ua.indexOf('MSIE ') > 0 || ua.indexOf('Trident/') > 0) {
            return true;
        }
        return false;
    }

    var ua = window.navigator.userAgent;
    if (browserDetection(ua)) {
        window.location.href('https:\/\/keichw.github.io\/ie\/');
    }
</script>
    <header>
    <div class="container-lg clearfix">
        <div class="col-12 header">
            <a class="title-main" href="https://keichw.github.io">Kinopio BLOG</a>
            
            <span class="title-sub">(ง •̀_•́)ง</span>
            
        </div>
    </div>
</header>

    <main>
        <div class="container-lg clearfix">
            
            <div class="col-12 col-md-9 float-left content">
                
<article>
    
    <h2 class="post-item post-title">
        <a href="https://keichw.github.io/post/study-java-thread/">Java多线程笔记</a>
    </h2>
    <div class="post-item post-meta">
        <span><ion-icon name="today"></ion-icon>&nbsp;2020-07-26</span><span><ion-icon name="file-tray"></ion-icon>&nbsp;6410 字</span><span><ion-icon name="stopwatch"></ion-icon>&nbsp;13 分钟</span><span><ion-icon name="pricetags"></ion-icon>&nbsp;<a href="/tags/java">java</a>&nbsp;</span>
    </div>
    
    
    <div class="post-content markdown-body">
        <h2 id="1-定义">1 定义</h2>
<ul>
<li>程序
<ul>
<li>程序是指令和数据的有序集合，没有任何运行的含义，是个静态的概念</li>
</ul>
</li>
<li>进程（process）
<ul>
<li>进程是执行程序的一次执行过程，是动态的概念</li>
<li>进程是系统资源分配的单位</li>
</ul>
</li>
<li>线程（thread）
<ul>
<li>一个进程中可以包含若干个线程</li>
<li>线程是CPU调度和执行的单位</li>
</ul>
</li>
<li>多线程
<ul>
<li>真正的多线程是指有多个CPU，即多核</li>
<li>在一个CPU的情况下，在一个时间点，CPU只能执行一个代码，只是切换很快，有同时进行的错觉</li>
</ul>
</li>
</ul>
<h2 id="2-线程创建">2 线程创建</h2>
<h3 id="21-继承thread类">2.1 继承Thread类</h3>
<ol>
<li>自定义线程类继承Thread类</li>
<li>重写run()方法，编写线程执行体</li>
<li>创建线程对象，调用start()方法启动线程</li>
</ol>
<pre><code class="language-java">public class TestThread1 extends Thread {
    //run方法线程体
    @Override
    public void run() {
        for (int i = 0; i &lt; 20; i++) {
            System.out.println(&quot;the number in sub thread is &quot; + i);
        }
    }
    
    //main线程，主线程
    public static void main(String[] args) {
        //创建一个子线程
        TestThread1 testThread = new TestThread1();
        //调用start方法开启线程
        testThread.start();
        
        for (int i = 0; i &lt; 20; i++) {
            System.out.println(&quot;the number in main thread is &quot; + i);
        }
    }
}
</code></pre>
<p>运行之后，我们能看到两个线程的输出是交错的，说明两个线程在同时运行。如果不明显，可以将循环次数调大</p>
<p>如果在testThread直接调用run方法，那么不会出现多线程的情况，输出结果是由上至下依次输出的。调用start方法才会产生多线程的情况</p>
<p>另外，线程开启后不一定立即执行，由CPU调度执行</p>
<p><strong>实现多线程同步下载图片</strong></p>
<p>使用commons.io包</p>
<pre><code class="language-java">public class TestThread2 extends Thread {
    
    private String url;		//网络文件地址
    private String fileName;	//保存的文件
    
    public TestThread2(String url, String fileName) {
        this.url = url;
        this.fileName = fileName;
    }
    
    @Override
    public void run() {
        WebDownloader webDownloader = new WebDownloader();
        webDownloader.download(url, fileName);
        System.out.println(&quot;over, and the file is &quot; + fileName);
    }
    
    public static void main(String[] args) {
        TestThread2 t1 = new TestThread2(&quot;https://img1.doubanio.com/view/photo/raw/public/p1413828179.jpg&quot;, &quot;1.jpg&quot;);
        TestThread2 t2 = new TestThread2(&quot;https://img9.doubanio.com/view/photo/raw/public/p2162992026.jpg&quot;, &quot;2.jpg&quot;);
        TestThread2 t3 = new TestThread2(&quot;https://img1.doubanio.com/view/photo/raw/public/p1413828209.jpg&quot;, &quot;3.jpg&quot;);
        t1.start();
        t2.start();
        t3.start();
    }
}

//下载器
class WebDownloader {
    //下载方法
    public void download(String url, String fileName) {
        try {
            FileUtils.copyURLToFile(new URL(url), new File(fileName));
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
<h3 id="22-实现runnable接口">2.2 实现Runnable接口</h3>
<ol>
<li>定义线程类实现Runnable接口</li>
<li>实现run()方法，编写线程执行体</li>
<li>创建线程对象，调用start()方法启动线程</li>
</ol>
<pre><code class="language-java">public class TestThread3 implements Runnable {
    //run方法线程体
    @Override
    public void run() {
        for (int i = 0; i &lt; 20; i++) {
            System.out.println(&quot;the number in sub thread is &quot; + i);
        }
    }
    
    //main线程，主线程
    public static void main(String[] args) {
        //创建Runnable接口的实现类对象
        TestThread3 testThread = new TestThread3();
        //创建线程对象，通过线程对象开启线程
        //Thread thread = new Thread(testThread);
        //thread.start();
        new Thread(testThread).start();
        
        for (int i = 0; i &lt; 20; i++) {
            System.out.println(&quot;the number in main thread is &quot; + i);
        }
    }
}
</code></pre>
<p>建议使用实现Runnable接口的做法，避免单继承的局限性，方便一个对象被多个线程使用</p>
<p><strong>多个线程操作同一个对象</strong></p>
<pre><code class="language-java">public class TestThread4 implements Runnable {
    
    private int ticketNum = 10;
    
    @Override
    public void run() {
        while (true) {
            if (ticketNum &lt;= 0)
                break;
            //模拟延时
            try {
                Thread.sleep(200);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName() + &quot;拿到了第&quot; + ticketNum-- + &quot;张票&quot;);
        }
    }
    
    public static void main(String[] args) {
        TestThread4 thread = new TestThread4();
        new Thread(thread, &quot;test1&quot;).start();
        new Thread(thread, &quot;test2&quot;).start();
        new Thread(thread, &quot;test3&quot;).start();
    }
}
</code></pre>
<p>输出结果显示会产生数据紊乱，不符合常理的问题，多个线程操作同一个资源的情况下，线程不安全</p>
<p>其实，new Thread(thread).start() 这种方式是静态代理实现的，Thread类也是实现了Runnable接口，把实现了Runnable接口的thread对象作为参数传进去，就是静态代理的过程</p>
<p>此外，对于thread对象可以用匿名内部类代替，比如</p>
<pre><code class="language-java">new Thread(testThread).start();
</code></pre>
<p>其中，testThread实现了Runnable接口，可以写为</p>
<pre><code class="language-java">new Thread(new Runnable {
    @Override
    public void run() {
        for (int i = 0; i &lt; 20; i++) {
            System.out.println(&quot;the number in sub thread is &quot; + i);
        }
    }
}).start();
</code></pre>
<p>还可以用lambda表达式进一步简化，这要求jdk的版本为8以上</p>
<pre><code class="language-java">new Thread(() -&gt; {
    for (int i = 0; i &lt; 20; i++) {
        System.out.println(&quot;the number in sub thread is &quot; + i);
    }
}).start();
</code></pre>
<h3 id="23-实现callable接口">2.3 实现Callable接口</h3>
<ol>
<li>
<p>实现Callable接口，需要返回值类型</p>
</li>
<li>
<p>重写call方法，需要抛出异常</p>
</li>
<li>
<p>创建目标对象</p>
</li>
<li>
<p>创建执行服务</p>
<pre><code class="language-java">ExecutorService service = Executors.newFixedThreadPool(1);
</code></pre>
</li>
<li>
<p>提交执行</p>
<pre><code class="language-java">Future&lt;Boolean&gt; result = service.submit(thread);
</code></pre>
</li>
<li>
<p>获取结果</p>
<pre><code class="language-java">boolean r = result.get();
</code></pre>
</li>
<li>
<p>关闭服务</p>
<pre><code class="language-java">service.shutdownNow();
</code></pre>
</li>
</ol>
<pre><code class="language-java">public class TestCallable implements Callable&lt;Boolean&gt; {
    
    @Override
    public Boolean call() {
        for (int i = 0; i &lt; 20; i++) {
            System.out.println(&quot;the number in sub thread is &quot; + i);
        }
        return true;
    }
    
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        TestCallable thread = new TestCallable();
        ExecutorService service = Executors.newFixedThreadPool(1);
        Future&lt;Boolean&gt; result = service.submit(thread);
        boolean r = result.get();
        service.shutdownNow();
        
        for (int i = 0; i &lt; 20; i++) {
            System.out.println(&quot;the number in main thread is &quot; + i);
        }
    }
}
</code></pre>
<h2 id="3-线程状态">3 线程状态</h2>
<p><a href="/img/study-java-thread/%e7%ba%bf%e7%a8%8b%e7%8a%b6%e6%80%81.png" target="_blank">
    <img src="/img/study-java-thread/%e7%ba%bf%e7%a8%8b%e7%8a%b6%e6%80%81.png" alt="" />
</a></p>
<h3 id="31-停止线程">3.1 停止线程</h3>
<ul>
<li>不推荐使用jdk提供的stop()，destroy()方法</li>
<li>推荐线程自己停止
<ul>
<li>使用一个标志位进行终止变量，当flag=false时，则终止线程运行</li>
</ul>
</li>
</ul>
<pre><code class="language-java">public class TestStop implements Runnable {
    
    //设置一个标志位
    private boolean flag = true;
    
    @Override
    public void run() {
        int i = 0;
        while (flag) {
            System.out.println(&quot;thread is running... i is &quot; + i++);
        }
    }
    
    //设置公开的方法停止线程
    public void stop() {
        flag = false;
    }
    
    public static void main(String[] args) {
        TestStop testStop = new TestStop();
        new Thread(testStop).start();
        for (int i = 0; i &lt; 100; i++) {
            System.out.println(&quot;main thread...&quot; + i);
            if (i == 90) {
                testStop.stop();
                System.out.println(&quot;thread stop&quot;);w
            }
        }
    }
}
</code></pre>
<h3 id="32-线程休眠">3.2 线程休眠</h3>
<ul>
<li>sleep方法指定当前线程阻塞的毫秒数</li>
<li>sleep存在异常InterruptedException</li>
<li>sleep时间达到后线程进入就绪状态</li>
<li>每个对象都有一个锁，sleep不会释放锁</li>
</ul>
<pre><code class="language-java">public class TestSleep implements Runnable {
        
    private int ticketNum = 10;
    
    @Override
    public void run() {
        while (true) {
            if (ticketNum &lt;= 0)
                break;
            //模拟延时
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName() + &quot;拿到了第&quot; + ticketNum-- + &quot;张票&quot;);
        }
    }
    
    public static void main(String[] args) {
        TestThread4 thread = new TestThread4();
        new Thread(thread, &quot;test1&quot;).start();
        new Thread(thread, &quot;test2&quot;).start();
        new Thread(thread, &quot;test3&quot;).start();
    }
}
</code></pre>
<p>模拟网络延时可以放大问题的发生性</p>
<pre><code class="language-java">//模拟倒计时
public class CountDown {
    public static void countDown() throws InterruptedException {
        int num = 10;
        while (true) {
            Thread.sleep(1000);
            System.out.println(num--);
            if (num &lt;= 0) {
                break;
            }
        }
    }
    
    pubilc static void main(String[] args) {
        try {
            countDown();
        } catch {
            e.printStackTrace();
        }
    }
}
</code></pre>
<h3 id="33-线程yield">3.3 线程yield</h3>
<ul>
<li>yield让当前正在执行的线程暂停，但不阻塞</li>
<li>将线程从运行状态转为就绪状态</li>
<li>让CPU重新调度，yield不一定成功</li>
</ul>
<pre><code class="language-java">public class TestYield {
    public static void main(String[] args) {
        new Thread(new MyThread(), &quot;a&quot;).start();
        new Thread(new MyThread(), &quot;b&quot;).start();
    }
}

class MyThread implements Runnable {
    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName() + &quot;线程开始执行&quot;);
        Thread.yield();
        System.out.println(&quot;线程停止执行&quot;);
    }
}
</code></pre>
<h3 id="34-线程强制执行">3.4 线程强制执行</h3>
<ul>
<li>join合并线程，其他线程阻塞，待此线程执行完成后，再执行其他线程，相当于插队</li>
</ul>
<pre><code class="language-java">public class TestJoin implements Runnable {
    
    @Override
    public void run() {
        for (int i = 0; i &lt; 100; i++) {
            System.out.println(&quot;sub thread is running...&quot; + i);
        }
    }
    
    public static void main(String[] args) throws InterruptedException {
        Thread thread = new Thread(new TestJoin());
        thread.start();
        
        
        //main thread
        for (int i = 0; i &lt; 100; i++) {
            if (i == 20) {
                thread.join();
            }
            System.out.println(&quot;main thread is running...&quot; + i);
        }
    }
}
</code></pre>
<h3 id="35-观测线程状态">3.5 观测线程状态</h3>
<ul>
<li>Thread.State
<ul>
<li>NEW：尚未启动的线程处于此状态</li>
<li>RUNNABLE：在Java虚拟机中执行的线程处于此状态</li>
<li>BLOCKED：被阻塞等待监视器锁定的线程处于此状态</li>
<li>WAITING：正在等待另一个线程执行特定动作的线程处于此状态</li>
<li>TIMED_WAITING：正在等待另一个线程执行动作达到指定等待时间的线程处于此状态</li>
<li>TERMINATED：已退出的线程处于此状态</li>
</ul>
</li>
</ul>
<pre><code class="language-java">public class TestState {
    public static void main(String[] args) throws InterruptedException {
        Thread thread = new Thread(() -&gt; {
            try {
                for (int i = 0; i &lt; 5; i++) {
                	Thread.sleep(1000);
            	}
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(&quot;sub thread is running...&quot;);
        });
        
        //观察状态
        Thread.State state = thread.getState();
        System.out.println(state);
        
        //观察启动后状态
        thread.start();
        state = thread.getState();
        System.out.println(state);
        
        while (state != Thread.State.TERMINATED) {
            Thread.sleep(100);
            state = thread.getState();
            System.out.println(stated);
        }
    }
}
</code></pre>
<h3 id="36-线程优先级">3.6 线程优先级</h3>
<p>线程调度器监控程序中启动后进入就绪状态的所有线程，按照优先级决定应该调度哪个线程来执行</p>
<p>线程的优先级用数字表示，范围从1到10，数字越大代表优先级越高，通过getPriority()和setPriority(int)来获取和改变优先级</p>
<p>优先级的设定一定要在线程启动之前</p>
<p>此外，线程优先级低只是意味着获得调度的概率低，并不是优先级低就不会被调用，得看CPU的调度</p>
<pre><code class="language-java">public class TestPriority {
    public static void main(String[] args) {
        //主线程优先级
        System.out.println(Thread.currentThread().getName() + &quot;--&gt;&quot; + Thread.currentThread().getPriority());
        
        Thread t1 = new Thread(new MyThread());
        Thread t2 = new Thread(new MyThread());
        Thread t3 = new Thread(new MyThread());
        Thread t4 = new Thread(new MyThread());
        Thread t5 = new Thread(new MyThread());
        Thread t6 = new Thread(new MyThread());
        
        //设置优先级
        t1.start();
        t2.setPriority(1);
        t2.start();
        t3.setPriority(4);
        t3.start();
        t4.setPriority(Thread.MAX_PRIORITY);
        t4.start();
        t5.setPriority(-1);	//报错
        t5.start();
        t6.setPriority(11);	//报错
        t6.start();
    }
}

class MyThread implements Runnable {
    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName() + &quot;--&gt;&quot; + Thread.currentThread().getPriority());
    }
}
</code></pre>
<h3 id="37-守护daemon线程">3.7 守护（daemon）线程</h3>
<p>线程分为用户线程和守护线程，守护线程如后台记录操作日志，监控内存，垃圾回收等</p>
<p>虚拟机必须确保用户线程执行完毕，不用等待守护线程执行完毕</p>
<pre><code class="language-java">public class TestDaemon {
    public static void main(String[] args) {
        Thread thread = new Thread(new MonitorThread);
        //默认为false表示用户线程
        thread.setDaemon(true);
        thread.start();
        
        new Thread(new MyThread()).start();
    }
}

class MyThread implements Runnable {
    @Override
    public void run() {
        for (int i = 0; i &lt; 100; i++) {
            System.out.println(&quot;sub thread is running...&quot;);
        }
        System.out.println(&quot;over&quot;);
    }
}

class MonitorThread implements Runnable {
    @Override
    public void run() {
        while (true) {
            System.out.println(&quot;monitor is running...&quot;);
        }
    }
}
</code></pre>
<p>结果显示monitor线程会在mythread线程执行完毕后再执行一段时间，最终停止</p>
<h2 id="4-线程同步">4 线程同步</h2>
<p>线程同步发生在多个线程操作同一个资源，也就是<strong>并发</strong>的情况下</p>
<p>线程同步其实是一种等待机制，多个需要同时访问对象的线程进入此对象的等待池形成队列，等待前面线程使用完毕。</p>
<h3 id="41-锁机制">4.1 锁机制</h3>
<p>为了保证数据在方法中被访问时的正确性，在访问时加入锁机制synchronized，当一个线程获得对象的排它锁，独占资源，其他线程必须等待，使用后释放锁即可</p>
<p>但也存在问题</p>
<ul>
<li>一个线程持有锁会导致其他所有需要此锁的线程挂起</li>
<li>在多线程竞争下，加锁释放锁会导致比较多的上下文切换和调度延时，引发性能问题</li>
<li>如果一个优先级高的线程等待一个优先级低的线程释放锁，会导致优先级倒置，引发性能问题</li>
</ul>
<h3 id="42-线程不安全案例">4.2 线程不安全案例</h3>
<pre><code class="language-java">public class UnsafeBuyTicket {
    public static void main(String[] args) {
        new Thread(new BuyTicket(), &quot;test1&quot;).start();
        new Thread(new BuyTicket(), &quot;test2&quot;).start();
        new Thread(new BuyTicket(), &quot;test3&quot;).start();
    }
}

class BuyTicket implements Runnable {
    
    private int ticketNum = 10;
    private boolean flag = true;
    
    private void buy() throws InterruptedException {
        if (ticketNum &lt;= 0) {
            flag = false;
            return;
        }
        Thread.sleep(100);
        System.out.println(Thread.currentThread().getName() + &quot;get &quot; + ticketNum--);
    }
    
    @Override
    public void run() {
        while (flag) {
            try {
                buy();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
</code></pre>
<pre><code class="language-java">public class UnsafeBank {
    public static void main(String[] args) {
        Account account = new Account(&quot;testAccount&quot;, 100);
        Withdraw withdraw1 = new Withdraw(account, 50, &quot;test1&quot;);
        Withdraw withdraw2 = new Withdraw(account, 100, &quot;test2&quot;);
        
        withdraw1.start();
        withdraw2.start();
    }
}

class Account {
    String name;
    int money;
    
    public Account(String name, int money) {
        this.name = name;
        this.money = money;
    }
}

class Withdraw extends Thread {
    Account account;
    int withdrawMoney;
    int moneyInHand;
    
    public Withdraw(Account account, int withdrawMoney, String name) {
        super(name);
        this.account = account;
        this.withdrawMoney = withdrawMoney;
    }
    
    @Override
    public void run() {
        if (account.money &lt; withdrawMoney) {
            System.out.println(Thread.currentThread().getName() + &quot;no enough money&quot;);
            return;
        }
        
        //sleep增加问题发生的可能性
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        
        account.money -= withdrawMoney;
        moneyInHand += withdrawMoney;
        System.out.println(account.name + &quot;余额为：&quot; + account.money);
        System.out.println(Thread.currentThread().getName() + &quot;手中的钱：&quot; + moneyInHand);
    }
}
</code></pre>
<pre><code class="language-java">public class UnsafeList {
    public static void main(String[] args) {
        List&lt;String&gt; list = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; 10000; i++) {
            new Thread(() -&gt; {
                list.add(Thread.currnetThread().getName());
            }).start();
        }
        
        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(list.size());
    }
}
</code></pre>
<h3 id="42-同步方法">4.2 同步方法</h3>
<p>通过private关键字保证数据对象只能被方法访问，使用synchronized关键字</p>
<ul>
<li>synchronized方法
<ul>
<li>public synchronized void method(int args) {}</li>
<li>synchronized方法控制对象的访问，每个对象对应一把锁，每个synchronized方法都必须获得调用该方法的对象的锁才能执行，否则线程阻塞。方法一旦执行，就独占该锁，直到方法返回才释放锁</li>
<li>将一个大的方法声明为synchronized会影响效率
<ul>
<li>方法内需要修改的资源才需要锁，锁的范围太大会影响执行速度</li>
</ul>
</li>
</ul>
</li>
<li>synchronized块
<ul>
<li>synchronized(Obj) {}</li>
<li>Obj为同步监视器
<ul>
<li>可以是任何对象，但推荐使用共享资源作为同步监视器</li>
<li>同步方法中无需指定同步监视器，因为同步方法的同步监视器就是this</li>
</ul>
</li>
<li>执行过程和synchronized方法一样</li>
</ul>
</li>
</ul>
<p><strong>使用同步方法或者同步代码块修改不安全案例</strong></p>
<pre><code class="language-java">public class SafeBuyTicket {
    public static void main(String[] args) {
        new Thread(new BuyTicket(), &quot;test1&quot;).start();
        new Thread(new BuyTicket(), &quot;test2&quot;).start();
        new Thread(new BuyTicket(), &quot;test3&quot;).start();
    }
}

class BuyTicket implements Runnable {
    
    private int ticketNum = 10;
    private boolean flag = true;
    
    //synchronized同步方法，锁的是this
    private synchronized void buy() throws InterruptedException {
        if (ticketNum &lt;= 0) {
            flag = false;
            return;
        }
        Thread.sleep(100);
        System.out.println(Thread.currentThread().getName() + &quot;get &quot; + ticketNum--);
    }
    
    @Override
    public void run() {
        while (flag) {
            try {
                buy();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
</code></pre>
<pre><code class="language-java">public class SafeBank {
    public static void main(String[] args) {
        Account account = new Account(&quot;testAccount&quot;, 100);
        Withdraw withdraw1 = new Withdraw(account, 50, &quot;test1&quot;);
        Withdraw withdraw2 = new Withdraw(account, 100, &quot;test2&quot;);
        
        withdraw1.start();
        withdraw2.start();
    }
}

class Account {
    String name;
    int money;
    
    public Account(String name, int money) {
        this.name = name;
        this.money = money;
    }
}

class Withdraw extends Thread {
    Account account;
    int withdrawMoney;
    int moneyInHand;
    
    public Withdraw(Account account, int withdrawMoney, String name) {
        super(name);
        this.account = account;
        this.withdrawMoney = withdrawMoney;
    }
    
    @Override
    public void run() {
        //锁的是共享资源account
        //如果synchronized加载run方法上，那么锁的是this，也就是Withdraw对象，但这个不是共享资源
        synchronized (account) {
            if (account.money &lt; withdrawMoney) {
                System.out.println(Thread.currentThread().getName() + &quot;no enough money&quot;);
                return;
            }
        
            //sleep增加问题发生的可能性
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        
            account.money -= withdrawMoney;
            moneyInHand += withdrawMoney;
            System.out.println(account.name + &quot;余额为：&quot; + account.money);
            System.out.println(Thread.currentThread().getName() + &quot;手中的钱：&quot; + moneyInHand);
        }
    }
}
</code></pre>
<pre><code class="language-java">public class UnsafeList {
    public static void main(String[] args) {
        List&lt;String&gt; list = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; 10000; i++) {
            new Thread(() -&gt; {
                synchronized (list) {
                    list.add(Thread.currnetThread().getName());
                }
            }).start();
        }
        
        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(list.size());
    }
}
</code></pre>
<p>对于第三个案例，我们还可以使用JUC安全类型内的集合CopyOnWriteArrayList</p>
<pre><code class="language-java">public class TestJUC {
    public static void main(String[] args) {
        CopyOnWriteArrayList&lt;String&gt; list = new CopyOnWriteArrayList&lt;&gt;();
        for (int i = 0; i &lt; 10000; i++) {
            new Thread(() -&gt; {
                list.add(Thread.currentThread().getName());
            }).start();
        }
        
        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(list.size());
    }
}
</code></pre>
<h3 id="43-死锁">4.3 死锁</h3>
<p>多个线程各自占有一些共享资源，并且互相等待其他线程占有的资源才能运行，导致两个或多个线程都在等待对方释放资源，都停止执行的情形</p>
<p>一个同步块同时拥有两个以上对象的锁时，就有可能会发生死锁问题</p>
<pre><code class="language-java">public class TestDeadlock {
    public static void main(String[] args) {
        MyThread t1 = new MyThread(&quot;test1&quot;, 0);
        MyThread t2 = new MyThread(&quot;test2&quot;, 1);
        
        t1.start();
        t2.start();
    }
}

class A {
    
}

class B {
    
}

class MyThread extends Thread {
    //用static来保证资源只有一份
    static A a = new A();
    static B b = new B();
    
    String name;
    int choice;
    
    public MyThread(String name, int choice) {
        this.name = name;
        this.choice = choice;
    }
    
    @Override
    public void run() {
        try {
            do();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
    
    private void do() throws InterruptedException {
        if (choice == 0) {
            synchronized (a) {
                System.out.println(name + &quot;get a&quot;);
                Thread.sleep(1000);
                synchronized (b) {
                    System.out.println(name + &quot;get b&quot;);
                }
            }
        } else {
            synchronized (b) {
                System.out.println(name + &quot;get b&quot;);
                Thread.sleep(2000);
                synchronized (a) {
                    System.out.println(name + &quot;get a&quot;);
                }
            }
        }
    }
}
</code></pre>
<p>程序会产生死锁，因为一个同步块同时拥有了两个锁a和b，而且<strong>a和b的资源只有一份（用static修饰）</strong>。如果把程序修改一下，就不会死锁</p>
<pre><code class="language-java">private void do() throws InterruptedException {
        if (choice == 0) {
            synchronized (a) {
                System.out.println(name + &quot;get a&quot;);
                Thread.sleep(1000);
            }
            synchronized (b) {
                System.out.println(name + &quot;get b&quot;);
            }
        } else {
            synchronized (b) {
                System.out.println(name + &quot;get b&quot;);
                Thread.sleep(2000);
            }
            synchronized (a) {
                System.out.println(name + &quot;get a&quot;);
            }
        }
    }
</code></pre>
<p>死锁产生的必要条件</p>
<ul>
<li>互斥条件：一个资源每次只能被一个进程使用</li>
<li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不妨</li>
<li>不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺</li>
<li>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系</li>
</ul>
<p>只要想办法打破其中任一条件，就可以避免死锁的发生</p>
<h3 id="44-lock">4.4 Lock</h3>
<p>synchronized关键字是隐式定义锁来实现同步，而Lock对象显示定义同步锁实现同步</p>
<p>Lock接口位于JUC包，是多个线程对共享资源进行访问的工具，作用和synchronized一样</p>
<ul>
<li>ReentrantLock 可重入锁
<ul>
<li>实现了Lock</li>
<li>与synchronized有相同的并发性和内存语义</li>
<li>可以显示加锁和释放锁</li>
<li>可以使用tryLock()方法尝试获得锁，如果无法获得，程序不会无限等待下去，而是做一些额外处理</li>
</ul>
</li>
</ul>
<pre><code class="language-java">public class TestLock {
    public static void main(String[] args) {
        MyThread thread = new MyThread();
        
        new Thread(thread).start();
        new Thread(thread).start();
        new Thread(thread).start();
    }
}

class MyThread implements Runnable {
    
    int ticketNum = 10;
    
    private final ReentrantLock lock = new ReentrantLock();
    
    @Override
    public void run() {
        while (true) {
            //加锁
            lock.lock();
            try {
                if (ticketNum &lt;= 0) {
                    break;
                }
            
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(ticketNum--);
            } finally {
                //释放锁
                lock.unlock();
            }
            
        }
    }
}
</code></pre>
<p>Lock和synchronized对比</p>
<ul>
<li>Lock是显示锁，需要手动开启和关闭，synchronized是隐式锁，出了作用域自动释放</li>
<li>Lock只有代码块锁，synchronized有代码块锁和方法锁</li>
<li>使用Lock锁，JVM将花费较少的时间来调度线程，性能更好</li>
<li>优先使用顺序：Lock &gt; 同步代码块 &gt; 同步方法</li>
</ul>
<h2 id="5-线程协作">5 线程协作</h2>
<h3 id="51-线程通信">5.1 线程通信</h3>
<p>Java提供了几个方法解决线程通信的问题</p>
<ul>
<li>wait()：表示线程一直等待，直到其他线程通知，与sleep不同，会释放锁</li>
<li>wait(long timeout)：指定等待的毫秒数</li>
<li>notify()：唤醒一个处于等待状态的线程</li>
<li>notifyAll()：唤醒同一个对象上所有调用wait()方法的线程，优先级高的优先调度</li>
</ul>
<p>这几个方法都是Object类的方法，都只能在同步方法或同步代码块中使用，否则会抛出异常</p>
<h3 id="52-生产者消费者问题">5.2 生产者消费者问题</h3>
<p><strong>解决方法一：管程法</strong></p>
<p>生产者将生产好的数据放入缓冲区，消费者从缓冲区获取数据</p>
<pre><code class="language-java">public class TestPC {
    public static void main(String[] args) {
        SynBuffer buffer = new SynBuffer();
        
        new Producer(buffer).start();
        new Consumer(buffer).start();
    }
}

class Producer extends Thread {
    SynBuffer buffer;
    
    public Producer(SynBuffer buffer) {
        this.buffer = buffer;
    }
    
    @Override
    public void run() {
        for (int i = 0; i &lt; 100; i++) {
            buffer.push(new Product(i));
            System.out.println(&quot;生产了 &quot; + i + &quot;个产品&quot;);
        }
    }
}

class Consumer extends Thread {
    SynBuffer buffer;
    
    public Consumer(SynBuffer buffer) {
        this.buffer = buffer;
    }
    
    @Override
    public void run() {
        for (int i = 0; i &lt; 100; i++) {
            System.out.println(&quot;消费了 &quot; + buffer.pop().id + &quot;个产品&quot;);
        }
    }
}

class Product {
    int id;
    
    public Product(int id) {
        this.id = id;
    }
}

class SynBuffer {
    Product[] products = new Product[10];
    int count = 0;
    
    public synchronized void push(Product product) {
        if (count == products.length) {
            try {
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        products[count] = product;
        count++;
        this.notifyAll();
    }
    
    public synchronized Product pop() {
        if (count == 0) {
            try {
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        
        count--;
        Product product = products[count];
        this.notifyAll();
        return product;
    }
}
</code></pre>
<p><strong>解决方法二：信号灯法</strong></p>
<pre><code class="language-java">public class TestPC {
    public static void main(String[] args) {
        Show show = new Show();
        
        new Actor(show).start();
        new Audience(show).start();
    }
}

class Actor extends Thread {
    Show show;
    
    public Actor(Show show) {
        this.show = show;
    }
    
    @Override
    public void run() {
        for (int i = 0; i &lt; 20; i++) {
            if (i % 2 == 0) {
                show.play(&quot;show1&quot;);
            } else {
                show.play(&quot;show2&quot;);
            }
        }
    }
}

class Audience extends Thread {
    Show show;
    
    public Audience(Show show) {
        this.show = show;
    }
    
    @Override
    public void run() {
        for (int i = 0; i &lt; 20; i++) {
            show.watch();
        }
    }
}

class Show {
    String item;
    boolean flag = true;
    
    public synchronized void play(String item) {
        if (!flag) {
            try {
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        System.out.println(&quot;演员表演了&quot; + item);
        
        this.notifyAll();
        this.item = item;
        this.flag = !this.flag;
    }
    
    public synchronized void watch() {
        if (flag) {
            try {
                this.wait();
            } catch (IterruptedException e) {
                e.printStackTrace();
            }
        }
        System.out.println(&quot;观看了&quot; + item);
        
        this.notifyAll();
        this.flag = !this.flag;
    }
}
</code></pre>
<h2 id="6-线程池">6 线程池</h2>
<p>经常创建和销毁使用量特别大的资源对性能影响很大，一般要使用线程池，提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中，避免频繁创建销毁，可以重复利用</p>
<h3 id="61-使用线程池">6.1 使用线程池</h3>
<p>线程池相关的API：ExecutorService和Executors</p>
<ul>
<li>ExecutorService：真正的线程池接口，常见子类ThreadPoolExecutor
<ul>
<li>void execute(Runnable command)：执行任务/命令。无返回值，一般用来执行Runnable</li>
<li>&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; tast)：执行任务，有返回值，一般用来执行Callable</li>
<li>void shutdown()：关闭连接池</li>
</ul>
</li>
<li>Executors：工具类，线程池的工厂类，用于创建并返回不同类型的线程池</li>
</ul>
<pre><code class="language-java">public class TestPool {
    public static void main(String[] args) {
        //创建服务，创建线程池
        ExecutorService service = Executors.newFixedThreadPool(10);
        
        //执行
        service.execute(new MyThread());
        service.execute(new MyThread());
        service.execute(new MyThread());
        service.execute(new MyThread());
        
        //关闭连接
        service.shutdown();
}

class MyThread implements Runnbale {
    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName() + i);
    }
}
</code></pre>

    </div>
</article>


<div class="license markdown-body">
    <blockquote>
        <p>除特殊注明部分，本站内容采用 <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"
               target="_blank">CC BY-NC-SA 4.0</a> 进行许可。</p>
    </blockquote>
</div>



            </div>
            <aside class="col-12 col-md-3 float-left sidebar">
    
    
    
    <div class="sidebar-item sidebar-toc">
        <h3>目录</h3>
        <nav id="TableOfContents">
  <ul>
    <li><a href="#1-定义">1 定义</a></li>
    <li><a href="#2-线程创建">2 线程创建</a>
      <ul>
        <li><a href="#21-继承thread类">2.1 继承Thread类</a></li>
        <li><a href="#22-实现runnable接口">2.2 实现Runnable接口</a></li>
        <li><a href="#23-实现callable接口">2.3 实现Callable接口</a></li>
      </ul>
    </li>
    <li><a href="#3-线程状态">3 线程状态</a>
      <ul>
        <li><a href="#31-停止线程">3.1 停止线程</a></li>
        <li><a href="#32-线程休眠">3.2 线程休眠</a></li>
        <li><a href="#33-线程yield">3.3 线程yield</a></li>
        <li><a href="#34-线程强制执行">3.4 线程强制执行</a></li>
        <li><a href="#35-观测线程状态">3.5 观测线程状态</a></li>
        <li><a href="#36-线程优先级">3.6 线程优先级</a></li>
        <li><a href="#37-守护daemon线程">3.7 守护（daemon）线程</a></li>
      </ul>
    </li>
    <li><a href="#4-线程同步">4 线程同步</a>
      <ul>
        <li><a href="#41-锁机制">4.1 锁机制</a></li>
        <li><a href="#42-线程不安全案例">4.2 线程不安全案例</a></li>
        <li><a href="#42-同步方法">4.2 同步方法</a></li>
        <li><a href="#43-死锁">4.3 死锁</a></li>
        <li><a href="#44-lock">4.4 Lock</a></li>
      </ul>
    </li>
    <li><a href="#5-线程协作">5 线程协作</a>
      <ul>
        <li><a href="#51-线程通信">5.1 线程通信</a></li>
        <li><a href="#52-生产者消费者问题">5.2 生产者消费者问题</a></li>
      </ul>
    </li>
    <li><a href="#6-线程池">6 线程池</a>
      <ul>
        <li><a href="#61-使用线程池">6.1 使用线程池</a></li>
      </ul>
    </li>
  </ul>
</nav>
    </div>
    
    
    
    <div class="sidebar-item sidebar-pages">
        <h3>页面</h3>
        <ul>
            
            <li>
                <a href="/">Home</a>
            </li>
            
            <li>
                <a href="/archives/">Archives</a>
            </li>
            
            <li>
                <a href="/about/">About</a>
            </li>
            
            <li>
                <a href="/search/">Search</a>
            </li>
            
            <li>
                <a href="/index.xml">RSS</a>
            </li>
            
        </ul>
    </div>
    
    <div class="sidebar-item sidebar-tags">
        <h3>标签</h3>
        <div>
            
            <span>
                <a href="/tags/c&#43;&#43;/">c&#43;&#43;</a>
            </span>
            
            <span>
                <a href="/tags/java/">java</a>
            </span>
            
            <span>
                <a href="/tags/jdbc/">jdbc</a>
            </span>
            
            <span>
                <a href="/tags/mybatis/">mybatis</a>
            </span>
            
            <span>
                <a href="/tags/network/">network</a>
            </span>
            
            <span>
                <a href="/tags/servlet/">servlet</a>
            </span>
            
            <span>
                <a href="/tags/spring/">spring</a>
            </span>
            
            <span>
                <a href="/tags/springmvc/">springmvc</a>
            </span>
            
            <span>
                <a href="/tags/web/">web</a>
            </span>
            
            <span>
                <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
            </span>
            
            <span>
                <a href="/tags/%E7%AE%97%E6%B3%95/">算法</a>
            </span>
            
        </div>
    </div>
    
    <div class="sidebar-item sidebar-links">
        <h3>链接</h3>
        <ul>
            
            <li>
                <a href="https://github.com/keichw" target="_blank"><span>GitHub</span></a>
            </li>
            
        </ul>
    </div>
    
</aside>
        </div>
        <div class="btn">
    <div class="btn-toggle-mode">
        <ion-icon name="contrast"></ion-icon>
    </div>
    <div class="btn-scroll-top">
        <ion-icon name="chevron-up"></ion-icon>
    </div>
</div>
    </main>

    <footer>
    <div class="container-lg clearfix">
        <div class="col-12 footer">
            <span>&copy; 2020 <a href="https://keichw.github.io">Kinopio</a> |
                基于 <a href="https://github.com/amzrk2/hugo-theme-fuji/"
                   target="_blank">Fuji-v2</a> & <a href="https://gohugo.io/"
                   target="_blank">Hugo</a> 构建</span>
        </div>
    </div>
</footer>
    
    <script async type="module" src="https://cdn.jsdelivr.net/npm/ionicons@5.0.1/dist/ionicons/ionicons.esm.js"></script>
<script async nomodule src="https://cdn.jsdelivr.net/npm/ionicons@5.0.1/dist/ionicons/ionicons.js"></script>

<script defer src="https://cdn.jsdelivr.net/npm/prismjs@1.20.0/components/prism-core.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/prismjs@1.20.0/plugins/autoloader/prism-autoloader.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/lazysizes@5.2.2/lazysizes.min.js"></script>

<script defer src="/assets/js/fuji.min.js"></script>

</body>

</html>