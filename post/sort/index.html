<!DOCTYPE html>
<html lang="zh-hans">

<head>
    
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
<meta name="HandheldFriendly" content="True" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
<meta name="generator" content="Hugo 0.73.0" />



<link rel="apple-touch-icon" sizes="180x180" href="https://cdn.jsdelivr.net/gh/amzrk2/poal-jsdelivr@1.6.0/favicons/apple-touch-icon.png" />
<link rel="icon" type="image/png" sizes="32x32" href="https://cdn.jsdelivr.net/gh/amzrk2/poal-jsdelivr@1.6.0/favicons/favicon-32x32.png" />
<link rel="icon" type="image/png" sizes="16x16" href="https://cdn.jsdelivr.net/gh/amzrk2/poal-jsdelivr@1.6.0/favicons/favicon-16x16.png" />
<link rel="manifest" href="https://cdn.jsdelivr.net/gh/amzrk2/poal-jsdelivr@1.6.0/favicons/site.webmanifest" />
<link rel="mask-icon" href="https://cdn.jsdelivr.net/gh/amzrk2/poal-jsdelivr@1.6.0/favicons/safari-pinned-tab.svg" color="#8aa2d3" />
<link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/amzrk2/poal-jsdelivr@1.6.0/favicons/favicon.ico" />
<meta name="msapplication-TileColor" content="#8aa2d3" />
<meta name="msapplication-config" content="https://cdn.jsdelivr.net/gh/amzrk2/poal-jsdelivr@1.6.0/favicons/browserconfig.xml" />
<meta name="theme-color" content="#ffffff" />


<title>排序算法 - Kinopio BLOG</title>


<meta name="author" content="Kinopio" />


<meta name="description" content="A minimal Hugo theme with nice theme color." />


<meta name="keywords" content="算法" />

<meta property="og:title" content="排序算法" />
<meta property="og:description" content="基本概念 void X_Sort(ElementType A[], int N) N是正整数 只讨论基于比较的排序(&lt;、=、&gt;有定义) 只讨论内部排序 稳定性：任意两个相等的数据，排序前后的相对位置不发生变化 没有一种排序是任何情况下都表现最好的 简单排序 冒泡排" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://example.com/post/sort/" />
<meta property="og:image" content="https://example.com/img/og.png"/>
<meta property="article:published_time" content="2019-07-21T22:58:00+08:00" />
<meta property="article:modified_time" content="2019-07-21T22:58:00+08:00" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://example.com/img/og.png"/>

<meta name="twitter:title" content="排序算法"/>
<meta name="twitter:description" content="基本概念 void X_Sort(ElementType A[], int N) N是正整数 只讨论基于比较的排序(&lt;、=、&gt;有定义) 只讨论内部排序 稳定性：任意两个相等的数据，排序前后的相对位置不发生变化 没有一种排序是任何情况下都表现最好的 简单排序 冒泡排"/>



<style>
    @media (prefers-color-scheme: dark) {
        body[data-theme='auto'] img {
            filter: brightness(60%);
        }
    }

    body[data-theme='dark'] img {
        filter: brightness(60%);
    }
</style>


<link rel="stylesheet" href="/assets/css/fuji.min.css" />






</head>

<body data-theme="auto">
    <script data-cfasync="false">
    
    var fujiThemeData = localStorage.getItem('fuji_data-theme');
    
    if (!fujiThemeData) {
        localStorage.setItem('fuji_data-theme', 'auto');
    } else {
        
        if (fujiThemeData !== 'auto') {
            document.body.setAttribute('data-theme', fujiThemeData === 'dark' ? 'dark' : 'light');
        }
    }
</script>
<script data-cfasync="false">
    
    function browserDetection(ua) {
        if (ua.indexOf('MSIE ') > 0 || ua.indexOf('Trident/') > 0) {
            return true;
        }
        return false;
    }

    var ua = window.navigator.userAgent;
    if (browserDetection(ua)) {
        window.location.href('https:\/\/example.com\/ie\/');
    }
</script>
    <header>
    <div class="container-lg clearfix">
        <div class="col-12 header">
            <a class="title-main" href="https://example.com">Kinopio BLOG</a>
            
            <span class="title-sub">(ง •̀_•́)ง</span>
            
        </div>
    </div>
</header>

    <main>
        <div class="container-lg clearfix">
            
            <div class="col-12 col-md-9 float-left content">
                
<article>
    
    <h2 class="post-item post-title">
        <a href="https://example.com/post/sort/">排序算法</a>
    </h2>
    <div class="post-item post-meta">
        <span><ion-icon name="today"></ion-icon>&nbsp;2019-07-21</span><span><ion-icon name="file-tray"></ion-icon>&nbsp;3360 字</span><span><ion-icon name="stopwatch"></ion-icon>&nbsp;7 分钟</span><span><ion-icon name="pricetags"></ion-icon>&nbsp;<a href="/tags/%E7%AE%97%E6%B3%95">算法</a>&nbsp;</span>
    </div>
    
    
    <div class="post-content markdown-body">
        <h3 id="基本概念">基本概念</h3>
<pre><code>void X_Sort(ElementType A[], int N)
</code></pre>
<!-- more -->
<ul>
<li>N是正整数</li>
<li>只讨论基于比较的排序(&lt;、=、&gt;有定义)</li>
<li>只讨论内部排序</li>
<li>稳定性：任意两个相等的数据，排序前后的相对位置不发生变化</li>
<li>没有一种排序是任何情况下都表现最好的</li>
</ul>
<h3 id="简单排序">简单排序</h3>
<h5 id="冒泡排序">冒泡排序</h5>
<p>每一趟冒泡可以确定至少一个元素的位置，确定一个最大值，也就是说，排序过程中序列尾部是排好序的。冒泡排序是稳定的算法。</p>
<pre><code>void Bubble_Sort(ElementType A[], int N){
	int P,i;

	for(P=N-1;P&gt;=0;P--){
		int flag=0;
		for(i=0;i&lt;P;i++){		//一趟冒泡
			if(A[i]&gt;A[i+1]){
				Swap(A[i],A[i+1]);
				flag=1;		//标识发生了交换
			}
		}
		if(flag==0)		//全程无交换
			break;
	}
}
</code></pre>
<p>最好情况：顺序 T=O(N)，最坏情况：逆序 T=O(N^2)</p>
<h5 id="插入排序">插入排序</h5>
<p>从1号元素开始，依次取出元素与其前面的元素比较，将其插入到合适的位置，排序过程中序列前部是排好序的。插入排序是稳定的算法。</p>
<pre><code>void Insertion_Sort(ElementType A[], int N){
	int P,i;
	ElementType Tmp;

	for(P=1;P&lt;N;P++){
		Tmp=A[P];		//取出未排序序列中的第一个元素
		for(i=P;i&gt;0&amp;&amp;A[i-1]&gt;Tmp;i--)
			A[i]=A[i-1];		//依次与已排序序列中的元素比较并右移
		A[i]=Tmp;		//放入适合的位置
	}
}
</code></pre>
<p>最好情况：顺序 T=O(N)，最坏情况：逆序 T=O(N^2)</p>
<hr>
<p>简单排序的平均时间复杂度为O(N^2)。</p>
<h3 id="希尔排序">希尔排序</h3>
<p>希尔排序是由Donald Shell提出的，所以叫希尔排序。
要进行希尔排序，首先要定义增量序列Dm &gt; Dm-1 &gt; ··· &gt; D1 = 1，然后就在待排序列上对每个增量序列Dk进行“Dk-间隔”排序(k=m,m-1,···,1)。其中要注意的是，“Dk-间隔”有序的序列，在执行“Dk-1-间隔”排序后，仍然是“Dk-间隔”有序的。
那么，希尔排序的关键就是确定增量序列，之后的每个“Dk-间隔”排序就可以采用简单排序来做。</p>
<ul>
<li>原始希尔排序  Dm=[N/2], Dk=[Dk+1/2]  向下取整</li>
</ul>
<pre><code>void Shell_Sort(ElementType A[], int N){
	for(D=N/2;D&gt;0;D/=2){		//希尔增量序列
		for(P=D;P&lt;N;P++){		//插入排序
			Tmp=A[P];
			for(i=P;i&gt;=D&amp;&amp;A[i-D]&gt;Tmp;i-=D)
				A[i]=A[i-D];
			A[i]=Tmp;
		}
	}
}
</code></pre>
<p>最坏情况：T=O(N^2)</p>
<p>但是这样选取增量序列有个问题，增量元素不互质，那么小增量可能根本不起作用。</p>
<p>这样也就产生了跟多增量序列</p>
<ul>
<li>
<p>Hibbard增量序列</p>
<ul>
<li>Dk=2^k-1 —— 相邻元素互质</li>
<li>最坏情况：T=O(N^3/2)</li>
<li>猜想：Tavg=O(N^5/4)</li>
</ul>
</li>
<li>
<p>Sedgewick增量序列</p>
<ul>
<li>{1,5,19,41,109,···}  —— 9×4^i-9×2^i+1或4^i-3×2^i+1</li>
<li>猜想：Tavg=O(N^7/6), Tworst=O(N^4/3)</li>
</ul>
</li>
</ul>
<pre><code>void Shell_Sort(ElementType A[], int N){
	//希尔排序 - 用Sedgewick增量序列
	int Si,D,P,i;
	ElementTypde Tmp;
	//只列出一小部分增量
	int Sedgewick[]={929,505,209,109,41,19,5,1,0};

	for(Si=0;Sedgewick[Si]&gt;=N;Si++)
		;		//初始的增量Sedgewick[Si]不能超过待排序列的长度，把超过的部分滤除

	for(D=Sedgewick[Si];D&gt;0;D=Sedgewick[++Si]){
		for(P=D;P&lt;N;P++){		//插入排序
			Tmp=A[P];
			for(i=P;i&gt;=D&amp;&amp;A[i-D]&gt;Tmp;i-=D)
				A[i]=A[i-D];
			A[i]=Tmp;
		}
	}
}
</code></pre>
<h3 id="堆排序">堆排序</h3>
<p>堆排序是利用最小堆的特性来对待排序列进行排序。</p>
<ul>
<li>算法1
用待排序列中的元素建最小堆，再从堆中返回最小元素到新的数组中，最后把新的排好序的数组复制到原序列中。</li>
</ul>
<pre><code>void Heap_Sort(ElementType A[], int N){
	BuildHeap(A);		//O(N)
	for(i=0;i&lt;N;i++)
		TmpA[i]=DeleteMin(A);		//O(logN)
	for(i=0;i&lt;N;i++)		//O(N)
		A[i]=TmpA[i];
}
</code></pre>
<p>T=O(NlogN)，需要额外O(N)的空间，并且复制元素需要时间。</p>
<ul>
<li>算法2
用待排序列中的元素建最大堆，再对堆直接操作，把根结点最大值和堆的最后一个元素交换，则确定了最大值的位置，然后对其余元素进行调整(下滤)，依次进行上述操作。相比算法1不需要额外的空间。</li>
</ul>
<pre><code>void Swap(ElementType *a, ElementType *b){
	ElementType t=*a;
	*a=*b;
	*b=t;
}

void PercDown(ElementType A[], int p, int N){
	//改编自堆的下滤操作PrecDown(MaxHeap H, int p)，参考堆的那篇博客
	//将N个元素的数组中以A[p]为根的子堆调整为最大堆
	int Parent,Child;
	ElementType X;

	X=A[p];		//取出根结点的值
	for(Parent=p;Parent*2+1&lt;N;Parent=Child){
		Child=Parent*2+1;
		if((Child!=N-1)&amp;&amp;(A[Child]&lt;A[Child+1]))
			Child++;		//Child指向左右子结点的最大者
		if(X&gt;=A[Child])		
			break;		//找到了合适位置
		else
			A[Parent]=A[Child];		//下滤
	}
	A[Parent]=X;
}

void Heap_Sort(ElementType A[], int N){
	int i;

	for(i=N/2-1;i&gt;=0;i--)
		PercDown(A,i,N);		//建最大堆，从最后一个父结点开始往前，依次下滤
	for(i=N-1;i&gt;0;i--){
		Swap(&amp;A[0],&amp;A[i]);		//交换最大值和末尾的值，相当于删除最大堆顶
		PercDown(A,0,i);		//对剩余子堆进行调整(下滤)
	}
}
</code></pre>
<p>堆排序处理N个不同元素的随机排列的平均比较次数是2NlogN-O(NloglogN)。虽然堆排序给出最佳平均复杂度，但实际效果不如用Sedgewick增量序列的希尔排序。</p>
<h3 id="归并排序">归并排序</h3>
<p>归并排序先将待排序列分成多个序列，每个序列各自排序，最后多个有序序列合并成一个有序序列。归并算法的核心便是<strong>有序子列的归并</strong>。</p>
<pre><code>void Merge(ElementType A[], ElementType TmpA[], int L, int R, int RightEnd){
	//L=左边起始位置，R=右边起始位置，RightEnd=右边终点位置
	//将有序的A[L]-A[R-1]和A[R]-A[RightEnd]归并成一个有序序列
	int LeftEnd,NumElements,Tmp;
	int i;

	LeftEnd=R-1;		//左边重点位置
	Tmp=L;		//有序序列的起始位置
	NumElements=RightEnd-L+1;

	while(L&lt;=LeftEnd&amp;&amp;R&lt;=RightEnd){
		if(A[L]&lt;=A[R])
			TmpA[Tmp++]=A[L++];		//将左边元素复制到TmpA
		else
			TmpA[Tmp++]=A[R++];		//将右边元素复制到TmpA
	}

	while(L&lt;=LeftEnd)
		TmpA[Tmp++]=A[L++];		//直接复制左边剩下的
	while(R&lt;=RightEnd)
		TmpA[Tmp++]=A[R++];		//直接复制右边剩下的

	for(i=0;i&lt;NumElements;i++,RightEnd--)
		A[RightEnd]=TmpA[Rightend];		//将有序的TmpA复制回A
}
</code></pre>
<p>归并排序有两种实现方式，递归算法和非递归算法。</p>
<h5 id="递归算法">递归算法</h5>
<p>归并排序的递归算法采用的是<strong>分而治之</strong>的思想。</p>
<pre><code>void MSort(ElementType A[], ElementType TmpA[], int L, int RightEnd){
	//核心递归排序函数
	int Center;

	if(L&lt;RightEnd){
		Center=(L+RightEnd)/2;
		MSort(A, TmpA, L, Center);		//递归解决左边
		MSort(A, TmpA, Center+1, RightEnd);		//递归解决右边
		Merge(A, TmpA, L, Center+1, RightEnd);		//合并两段有序序列
	}
}
</code></pre>
<p>T=O(NlogN)，是稳定的算法。</p>
<p>统一函数接口</p>
<pre><code>void Merge_Sort(ElementType A[], int N){
	ElementType *TmpA;
	TmpA=(ElementType *)malloc(N*sizeof(ElementType));

	if(TmpA!=NULL){
		MSort(A, TmpA, 0, N-1);
		free(TmpA);
	}
	else
		printf(&quot;空间不足&quot;);
}
</code></pre>
<h5 id="非递归算法">非递归算法</h5>
<p>归并排序的非递归算法由循环实现。</p>
<pre><code>void Merge_pass(ElementType A[], ElementType TmpA[], int N, int length){		//length是当前有序子序列的长度
	//两两归并相邻有序子序列
	int i,j;

	for(i=0;i&lt;=N-2*length;i+=2*length)
		Merge(A, TmpA, i, i+length, i+2*length-1);
	if(i+length&lt;N)		//归并最后2个子列
		Merge(A, TmpA, i, i+length, N-1);
	else 		//最后只剩1个子列
		for(j=i;j&lt;N;j++)
			TmpA[j]=A[j];
}

void Merge_Sort(ElementType A[], int N){
	int length;
	ElementType *TmpA;

	length=1;		//初始化子序列长度
	TmpA=(ElementType *)malloc(N*sizeof(ElementType));
	if(TmpA!=NULL){
		while(length&lt;N){
			Merge_pass(A, TmpA, N, length);
			length*=2;
			Merge_pass(TmpA, A, N, length);
			length*=2;
		}
		free(TmpA);
	}
	else
		printf(&quot;空间不足&quot;);
}
</code></pre>
<h3 id="快速排序">快速排序</h3>
<p>快速排序采用分而治之的思想，先选取一个主元pivot，比主元小的元素放在前面，而比主元大的元素放在后面。问题就是如何选取主元，这里有个方法是取头、中、尾的中位数，比如8、12、3的中位数是8。另外，如果数据规模较小，快速排序的效率可能还不如插入排序快，所以，当递归的数据规模充分小，则停止递归，直接调用简单排序。</p>
<pre><code>ElementType Median3(ElementType A[], int Left, int Right){
	int Center=(Left+Right)/2;
	if(A[Left]&gt;A[Center])
		Swap(&amp;A[Left],&amp;A[Center]);
	if(A[Left]&gt;A[Right])
		Swap(&amp;A[Left],&amp;A[Right]);
	if(A[Center]&gt;A[Right])
		Swap(&amp;A[Center],&amp;A[Right]);
	//此时，A[Left]&lt;=A[Center]&lt;=A[Right]
	Swap(&amp;A[Center],&amp;A[Right-1]);		//将基准Pivot藏到右边
	//只需要考虑A[Left+1],···,A[Right-2]
	return A[Right-1];
}

void Qsort(ElementType A[], int Left, int Right){
	int Pivot,Cutoff,Low,High;

	if(Cutoff&lt;=Right-Left){		//如果序列元素充分多，则进入快速排序
		Pivot=Median3(A,Left,Right);		//选取主元pivot
		Low=Left;
		High=Right-1;
		while(1){		//将序列中比基准小的移到基准左边，大的移到基准右边
			while(A[++Low]&lt;Pivot);
			while(A[--High]&gt;Pivot);
			if(Low&lt;High)
				Swap(&amp;A[Low],&amp;A[High]);
			else
				break;
		}
		Swap(&amp;A[Low],&amp;A[Right-1]);		//将基准放到正确的位置
		Qsort(A,Left,Low-1);		//递归解决左边
		Qsort(A,Low+1,Right);		//递归解决右边
	}
	else
		Insertion_Sort(A+Left,Right-Left+1);		//元素太少，用插入排序
}

void Quick_Sort(ElementType A[], int N){		//统一接口
	Qsort(A,0,N-1);
}
</code></pre>
<p>如果pivot选取的好，那么快速排序的时间复杂度为T=O(NlogN)。</p>
<h3 id="基数排序">基数排序</h3>
<pre><code>/* 假设元素最多有MaxDigit个关键字，基数全是同样的Radix */
#define MaxDigit 4
#define Radix 10
 
typedef struct Node *PtrToNode;
struct Node{		//桶元素结点
    int key;
    PtrToNode next;
};

struct HeadNode{		//桶头结点
    PtrToNode head, tail;
};
typedef struct HeadNode Bucket[Radix];
  
int GetDigit(int X, int D){
	/* 默认次位D=1, 主位D&lt;=MaxDigit */
    int d, i;
     
    for(i=1; i&lt;=D; i++){
        d = X % Radix;
        X /= Radix;
    }
    return d;
}

void LSDRadixSort(ElementType A[], int N){    
	//基数排序-次位优先
    int D, Di, i;
    Bucket B;
    PtrToNode tmp, p, List = NULL; 
      
    for(i=0; i&lt;Radix; i++) /* 初始化每个桶为空链表 */
        B[i].head = B[i].tail = NULL;
    for(i=0; i&lt;N; i++){ /* 将原始序列逆序存入初始链表List */
        tmp = (PtrToNode)malloc(sizeof(struct Node));
        tmp-&gt;key = A[i];
        tmp-&gt;next = List;
        List = tmp;
    }
    /* 下面开始排序 */ 
    for(D=1; D&lt;=MaxDigit; D++){ /* 对数据的每一位循环处理 */
        /* 下面是分配的过程 */
        p = List;
        while(p){
            Di = GetDigit(p-&gt;key, D); /* 获得当前元素的当前位数字 */
            /* 从List中摘除 */
            tmp = p; p = p-&gt;next;
            /* 插入B[Di]号桶尾 */
            tmp-&gt;next = NULL;
            if(B[Di].head == NULL)
                B[Di].head = B[Di].tail = tmp;
            else{
                B[Di].tail-&gt;next = tmp;
                B[Di].tail = tmp;
            }
        }
        /* 下面是收集的过程 */
        List = NULL; 
        for(Di=Radix-1; Di&gt;=0; Di--){ /* 将每个桶的元素顺序收集入List */
            if(B[Di].head){ /* 如果桶不为空 */
                /* 整桶插入List表头 */
                B[Di].tail-&gt;next = List;
                List = B[Di].head;
                B[Di].head = B[Di].tail = NULL; /* 清空桶 */
            }
        }
    }
    /* 将List倒入A[]并释放空间 */
    for(i=0; i&lt;N; i++){
        tmp = List;
        List = List-&gt;next;
        A[i] = tmp-&gt;key;
        free(tmp);
    } 
}


//基数排序-主位优先

void MSD(ElementType A[], int L, int R, int D){ 
	/* 核心递归函数: 对A[L]...A[R]的第D位数进行排序 */
    int Di, i, j;
    Bucket B;
    PtrToNode tmp, p, List = NULL; 
    if (D==0) return; /* 递归终止条件 */
      
    for(i=0; i&lt;Radix; i++) /* 初始化每个桶为空链表 */
        B[i].head = B[i].tail = NULL;
    for(i=L; i&lt;=R; i++){ /* 将原始序列逆序存入初始链表List */
        tmp = (PtrToNode)malloc(sizeof(struct Node));
        tmp-&gt;key = A[i];
        tmp-&gt;next = List;
        List = tmp;
    }
    /* 下面是分配的过程 */
    p = List;
    while (p){
        Di = GetDigit(p-&gt;key, D); /* 获得当前元素的当前位数字 */
        /* 从List中摘除 */
        tmp = p; p = p-&gt;next;
        /* 插入B[Di]号桶 */
        if(B[Di].head == NULL) B[Di].tail = tmp;
        tmp-&gt;next = B[Di].head;
        B[Di].head = tmp;
    }
    /* 下面是收集的过程 */
    i = j = L; /* i, j记录当前要处理的A[]的左右端下标 */
    for(Di=0; Di&lt;Radix; Di++){ /* 对于每个桶 */
        if(B[Di].head){ /* 将非空的桶整桶倒入A[], 递归排序 */
            p = B[Di].head;
            while(p){
                tmp = p;
                p = p-&gt;next;
                A[j++] = tmp-&gt;key;
                free(tmp);
            }
            /* 递归对该桶数据排序, 位数减1 */
            MSD(A, i, j-1, D-1);
            i = j; /* 为下一个桶对应的A[]左端 */
        } 
    } 
}
 
void MSDRadixSort(ElementType A[], int N){		//统一接口
    MSD(A, 0, N-1, MaxDigit); 
}
</code></pre>
<h3 id="排序算法的比较">排序算法的比较</h3>
<table>
<thead>
<tr>
<th align="center">排序算法</th>
<th align="center">平均时间复杂度</th>
<th align="center">最坏情况下时间复杂度</th>
<th align="center">额外空间复杂度</th>
<th align="center">稳定性</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">简单选择排序</td>
<td align="center">O(N^2)</td>
<td align="center">O(N^2)</td>
<td align="center">O(1)</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">冒泡排序</td>
<td align="center">O(N^2)</td>
<td align="center">O(N^2)</td>
<td align="center">O(1)</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">直接插入排序</td>
<td align="center">O(N^2)</td>
<td align="center">O(N^2)</td>
<td align="center">O(1)</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">希尔排序</td>
<td align="center">O(N^d)</td>
<td align="center">O(N^2)</td>
<td align="center">O(1)</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">堆排序</td>
<td align="center">O(NlogN)</td>
<td align="center">O(NlogN)</td>
<td align="center">O(1)</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">快速排序</td>
<td align="center">O(NlogN)</td>
<td align="center">O(N^2)</td>
<td align="center">O(logN)</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">归并排序</td>
<td align="center">O(NlogN)</td>
<td align="center">O(NlogN)</td>
<td align="center">O(N)</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">基数排序</td>
<td align="center">O(P(N+B))</td>
<td align="center">O(P(N+B))</td>
<td align="center">O(N+B)</td>
<td align="center">稳定</td>
</tr>
</tbody>
</table>

    </div>
</article>


<div class="license markdown-body">
    <blockquote>
        <p>除特殊注明部分，本站内容采用 <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"
               target="_blank">CC BY-NC-SA 4.0</a> 进行许可。</p>
    </blockquote>
</div>



            </div>
            <aside class="col-12 col-md-3 float-left sidebar">
    
    
    
    <div class="sidebar-item sidebar-toc">
        <h3>目录</h3>
        <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#基本概念">基本概念</a></li>
        <li><a href="#简单排序">简单排序</a></li>
        <li><a href="#希尔排序">希尔排序</a></li>
        <li><a href="#堆排序">堆排序</a></li>
        <li><a href="#归并排序">归并排序</a></li>
        <li><a href="#快速排序">快速排序</a></li>
        <li><a href="#基数排序">基数排序</a></li>
        <li><a href="#排序算法的比较">排序算法的比较</a></li>
      </ul>
    </li>
  </ul>
</nav>
    </div>
    
    
    
    <div class="sidebar-item sidebar-pages">
        <h3>页面</h3>
        <ul>
            
            <li>
                <a href="/">Home</a>
            </li>
            
            <li>
                <a href="/archives/">Archives</a>
            </li>
            
            <li>
                <a href="/about/">About</a>
            </li>
            
            <li>
                <a href="/search/">Search</a>
            </li>
            
            <li>
                <a href="/index.xml">RSS</a>
            </li>
            
        </ul>
    </div>
    
    <div class="sidebar-item sidebar-tags">
        <h3>标签</h3>
        <div>
            
            <span>
                <a href="/tags/c&#43;&#43;/">c&#43;&#43;</a>
            </span>
            
            <span>
                <a href="/tags/java/">java</a>
            </span>
            
            <span>
                <a href="/tags/jdbc/">jdbc</a>
            </span>
            
            <span>
                <a href="/tags/mybatis/">mybatis</a>
            </span>
            
            <span>
                <a href="/tags/servlet/">servlet</a>
            </span>
            
            <span>
                <a href="/tags/spring/">spring</a>
            </span>
            
            <span>
                <a href="/tags/web/">web</a>
            </span>
            
            <span>
                <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
            </span>
            
            <span>
                <a href="/tags/%E7%AE%97%E6%B3%95/">算法</a>
            </span>
            
        </div>
    </div>
    
    <div class="sidebar-item sidebar-links">
        <h3>链接</h3>
        <ul>
            
            <li>
                <a href="https://github.com/keichw" target="_blank"><span>GitHub</span></a>
            </li>
            
        </ul>
    </div>
    
</aside>
        </div>
        <div class="btn">
    <div class="btn-toggle-mode">
        <ion-icon name="contrast"></ion-icon>
    </div>
    <div class="btn-scroll-top">
        <ion-icon name="chevron-up"></ion-icon>
    </div>
</div>
    </main>

    <footer>
    <div class="container-lg clearfix">
        <div class="col-12 footer">
            <span>&copy; 2020 <a href="https://example.com">Kinopio</a> |
                基于 <a href="https://github.com/amzrk2/hugo-theme-fuji/"
                   target="_blank">Fuji-v2</a> & <a href="https://gohugo.io/"
                   target="_blank">Hugo</a> 构建</span>
        </div>
    </div>
</footer>
    
    <script async type="module" src="https://cdn.jsdelivr.net/npm/ionicons@5.0.1/dist/ionicons/ionicons.esm.js"></script>
<script async nomodule src="https://cdn.jsdelivr.net/npm/ionicons@5.0.1/dist/ionicons/ionicons.js"></script>

<script defer src="https://cdn.jsdelivr.net/npm/prismjs@1.20.0/components/prism-core.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/prismjs@1.20.0/plugins/autoloader/prism-autoloader.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/lazysizes@5.2.2/lazysizes.min.js"></script>

<script defer src="/assets/js/fuji.min.js"></script>

</body>

</html>