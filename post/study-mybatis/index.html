<!DOCTYPE html>
<html lang="zh-hans">

<head>
    
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
<meta name="HandheldFriendly" content="True" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
<meta name="generator" content="Hugo 0.73.0" />



<link rel="apple-touch-icon" sizes="180x180" href="https://cdn.jsdelivr.net/gh/amzrk2/poal-jsdelivr@1.6.0/favicons/apple-touch-icon.png" />
<link rel="icon" type="image/png" sizes="32x32" href="https://cdn.jsdelivr.net/gh/amzrk2/poal-jsdelivr@1.6.0/favicons/favicon-32x32.png" />
<link rel="icon" type="image/png" sizes="16x16" href="https://cdn.jsdelivr.net/gh/amzrk2/poal-jsdelivr@1.6.0/favicons/favicon-16x16.png" />
<link rel="manifest" href="https://cdn.jsdelivr.net/gh/amzrk2/poal-jsdelivr@1.6.0/favicons/site.webmanifest" />
<link rel="mask-icon" href="https://cdn.jsdelivr.net/gh/amzrk2/poal-jsdelivr@1.6.0/favicons/safari-pinned-tab.svg" color="#8aa2d3" />
<link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/amzrk2/poal-jsdelivr@1.6.0/favicons/favicon.ico" />
<meta name="msapplication-TileColor" content="#8aa2d3" />
<meta name="msapplication-config" content="https://cdn.jsdelivr.net/gh/amzrk2/poal-jsdelivr@1.6.0/favicons/browserconfig.xml" />
<meta name="theme-color" content="#ffffff" />


<title>MyBatis学习笔记 - Kinopio BLOG</title>


<meta name="author" content="Kinopio" />


<meta name="description" content="A minimal Hugo theme with nice theme color." />


<meta name="keywords" content="mybatis, java" />

<meta property="og:title" content="MyBatis学习笔记" />
<meta property="og:description" content="1 简介 1.1 什么是MyBatis 持久层框架 定制化SQL、存储过程和高级映射 使用简单的XML或注解配置，映射原生类型、接口和POJO为数据库中的记录 1.2 持久化 数据持久化 持久化就是将程序的数据在持久状态和瞬时状" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://example.com/post/study-mybatis/" />
<meta property="og:image" content="https://example.com/img/og.png"/>
<meta property="article:published_time" content="2020-07-11T19:49:02+08:00" />
<meta property="article:modified_time" content="2020-07-11T19:49:02+08:00" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://example.com/img/og.png"/>

<meta name="twitter:title" content="MyBatis学习笔记"/>
<meta name="twitter:description" content="1 简介 1.1 什么是MyBatis 持久层框架 定制化SQL、存储过程和高级映射 使用简单的XML或注解配置，映射原生类型、接口和POJO为数据库中的记录 1.2 持久化 数据持久化 持久化就是将程序的数据在持久状态和瞬时状"/>



<style>
    @media (prefers-color-scheme: dark) {
        body[data-theme='auto'] img {
            filter: brightness(60%);
        }
    }

    body[data-theme='dark'] img {
        filter: brightness(60%);
    }
</style>


<link rel="stylesheet" href="/assets/css/fuji.min.css" />






</head>

<body data-theme="auto">
    <script data-cfasync="false">
    
    var fujiThemeData = localStorage.getItem('fuji_data-theme');
    
    if (!fujiThemeData) {
        localStorage.setItem('fuji_data-theme', 'auto');
    } else {
        
        if (fujiThemeData !== 'auto') {
            document.body.setAttribute('data-theme', fujiThemeData === 'dark' ? 'dark' : 'light');
        }
    }
</script>
<script data-cfasync="false">
    
    function browserDetection(ua) {
        if (ua.indexOf('MSIE ') > 0 || ua.indexOf('Trident/') > 0) {
            return true;
        }
        return false;
    }

    var ua = window.navigator.userAgent;
    if (browserDetection(ua)) {
        window.location.href('https:\/\/example.com\/ie\/');
    }
</script>
    <header>
    <div class="container-lg clearfix">
        <div class="col-12 header">
            <a class="title-main" href="https://example.com">Kinopio BLOG</a>
            
            <span class="title-sub">(ง •̀_•́)ง</span>
            
        </div>
    </div>
</header>

    <main>
        <div class="container-lg clearfix">
            
            <div class="col-12 col-md-9 float-left content">
                
<article>
    
    <h2 class="post-item post-title">
        <a href="https://example.com/post/study-mybatis/">MyBatis学习笔记</a>
    </h2>
    <div class="post-item post-meta">
        <span><ion-icon name="today"></ion-icon>&nbsp;2020-07-11</span><span><ion-icon name="file-tray"></ion-icon>&nbsp;7538 字</span><span><ion-icon name="stopwatch"></ion-icon>&nbsp;16 分钟</span><span><ion-icon name="pricetags"></ion-icon>&nbsp;<a href="/tags/mybatis">mybatis</a>&nbsp;<a href="/tags/java">java</a>&nbsp;</span>
    </div>
    
    
    <div class="post-content markdown-body">
        <h2 id="1-简介">1 简介</h2>
<h3 id="11-什么是mybatis">1.1 什么是MyBatis</h3>
<ul>
<li>持久层框架</li>
<li>定制化SQL、存储过程和高级映射</li>
<li>使用简单的XML或注解配置，映射原生类型、接口和POJO为数据库中的记录</li>
</ul>
<h3 id="12-持久化">1.2 持久化</h3>
<p>数据持久化</p>
<ul>
<li>持久化就是将程序的数据在持久状态和瞬时状态转化的过程</li>
<li>数据库、IO文件持久化</li>
</ul>
<h3 id="13-持久层">1.3 持久层</h3>
<p>Dao层</p>
<ul>
<li>完成持久化工作的代码块</li>
</ul>
<h3 id="14-为什么需要mybatis">1.4 为什么需要MyBatis</h3>
<ul>
<li>传统的JDBC代码太复杂，需要简化</li>
<li>解除sql和程序代码的耦合</li>
<li>……</li>
</ul>
<h2 id="2-第一个mybatis程序">2 第一个MyBatis程序</h2>
<p>搭建环境&ndash;&gt;导入MyBatis&ndash;&gt;编写代码&ndash;&gt;测试</p>
<h3 id="21-搭建环境">2.1 搭建环境</h3>
<ol>
<li>创建数据库</li>
<li>创建项目</li>
<li>导入JDBC驱动，MyBatis包</li>
<li>配置mybatis的核心xml文件</li>
</ol>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration
  PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
  &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;
  &lt;environments default=&quot;development&quot;&gt;
    &lt;environment id=&quot;development&quot;&gt;
      &lt;transactionManager type=&quot;JDBC&quot;/&gt;
      &lt;dataSource type=&quot;POOLED&quot;&gt;
        &lt;property name=&quot;driver&quot; value=&quot;${driver}&quot;/&gt;
        &lt;property name=&quot;url&quot; value=&quot;${url}&quot;/&gt;
        &lt;property name=&quot;username&quot; value=&quot;${username}&quot;/&gt;
        &lt;property name=&quot;password&quot; value=&quot;${password}&quot;/&gt;
      &lt;/dataSource&gt;
    &lt;/environment&gt;
  &lt;/environments&gt;
  &lt;!--每个Mapper.xml都要在核心配置文件中注册--&gt;
  &lt;mappers&gt;
    &lt;mapper resource=&quot;com/hjc/dao/UserMapper.xml&quot;/&gt;
  &lt;/mappers&gt;
&lt;/configuration&gt;
</code></pre>
<ol start="5">
<li>从xml文件中构建SqlSessionFactory，我们把构建SqlSessionFactory的方法放在工具类的静态方法内</li>
</ol>
<pre><code class="language-java">public class MyBatisUtils {
    
    private static SqlSessionFactory sqlSessionFactory;
    
    static {
        try {
            String resource = &quot;mybatis-config.xml&quot;;
			InputStream inputStream = Resources.getResourceAsStream(resource);
			sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    
    public static sqlSession getSqlSession() {
        return sqlSessionFactory.openSession();
    }
}
</code></pre>
<h3 id="22-编写代码">2.2 编写代码</h3>
<ol>
<li>编写实体类（pojo）</li>
<li>编写Dao接口</li>
</ol>
<pre><code class="language-java">public interface UserDao {
    List&lt;User&gt; getUserList();
}
</code></pre>
<ol start="3">
<li>编写UserMapper.xml文件（接口实现类由原来的UserDaoImpl转变为Mapper配置文件）</li>
</ol>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
  PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
  &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;!--namespace = 绑定一个对应的Dao/Mapper接口--&gt;
&lt;mapper namespace=&quot;com.hjc.dao.UserDao&quot;&gt;
  &lt;!--select查询语句--&gt;
  &lt;select id=&quot;getUserList&quot; resultType=&quot;com.hjc.pojo.User&quot;&gt;
    select * from user;
  &lt;/select&gt;
&lt;/mapper&gt;
</code></pre>
<ol start="4">
<li>
<p>在核心配置文件中注册UserMapper.xml</p>
<pre><code class="language-xml">&lt;!--每个Mapper.xml都要在核心配置文件中注册--&gt;
&lt;mappers&gt;
  &lt;mapper resource=&quot;com/hjc/dao/UserMapper.xml&quot;/&gt;
&lt;/mappers&gt;
</code></pre>
<ol>
<li><strong>在默认的Maven配置下，UserMapper.xml文件应该放在resources文件夹下，也就是resources/com/hjc/dao/UserMapper.xml路径</strong></li>
<li>要想把UserDao和UserMapper.xml文件放在一起，需要更改Maven构建配置</li>
<li>如果不这样做，在构建时，Mapper文件无法被打包到target文件夹中</li>
</ol>
</li>
</ol>
<pre><code class="language-xml">&lt;build&gt;
    &lt;resources&gt;
        &lt;resource&gt;
            &lt;directory&gt;src/main/java&lt;/directory&gt;
            &lt;includes&gt;
                &lt;include&gt;**/*.xml&lt;/include&gt;
            &lt;/includes&gt;
            &lt;filtering&gt;false&lt;/filtering&gt;
        &lt;/resource&gt;
    &lt;/resources&gt;
&lt;/build&gt;
</code></pre>
<h3 id="23-测试代码">2.3 测试代码</h3>
<pre><code class="language-java">public class UserDaoTest {
    
    @Test
    public void testGetUserList() {
        //获得SqlSession对象
        SqlSession sqlSession = MyBatisUtils.getSqlSession();
        //方式一：getMapper
        UserDao userDao = sqlSession.getMapper(UserDao.class);
        List&lt;User&gt; userList = userDao.getUserList();
        
        //方式二：不建议使用
        //List&lt;User&gt; userList = sqlSession.selectList(&quot;com.hjc.dao.UserDao.getUserList&quot;);
        
        for (User user : userList)
            System.out.println(user);
        
        //关闭SqlSession
        sqlSession.close();
    }
}
</code></pre>
<h2 id="3-crud">3 CRUD</h2>
<h3 id="31-namespace">3.1 namespace</h3>
<p>namespace中的包名要和Dao/Mapper接口的包名一致</p>
<h3 id="32-select">3.2 select</h3>
<p>查询语句</p>
<ul>
<li>id：就是对应的namespace中的方法名</li>
<li>resultType：sql语句执行的返回类型</li>
<li>parameterType：sql语句的参数类型</li>
</ul>
<ol>
<li>编写接口</li>
</ol>
<pre><code class="language-java">//根据id查询用户
User getUserById(int id);
</code></pre>
<ol start="2">
<li>编写对应Mapper.xml文件中的sql语句</li>
</ol>
<pre><code class="language-xml">&lt;select id=&quot;getUserById&quot; parameterType=&quot;Integer&quot; resultType=&quot;com.hjc.pojo.User&quot;&gt;
    select * from user where id = #{id}
&lt;/selects&gt;
</code></pre>
<ol start="3">
<li>测试</li>
</ol>
<pre><code class="language-java">@Test
public void testGetUserById() {
    SqlSession sqlSession = MyBatisUtils.getSqlSession();
    UserDao userDao = sqlSession.getMapper(UserDao.class);
    User user = userDao.getUserById(1);
    System.out.println(user);
    sqlSession.close();
}
</code></pre>
<h3 id="33-insert">3.3 insert</h3>
<ol>
<li>编写接口</li>
</ol>
<pre><code class="language-java">//插入用户
void addUser(User user);
</code></pre>
<ol start="2">
<li>编写对应Mapper.xml文件中的sql语句</li>
</ol>
<pre><code class="language-xml">&lt;insert id=&quot;addUser&quot; parameterType=&quot;com.hjc.pojo.User&quot;&gt;
    insert into user (id, name, pwd) values (#{id}, #{name}, #{pwd})
&lt;/insert&gt;
</code></pre>
<ol start="3">
<li>测试</li>
</ol>
<pre><code class="language-java">@Test
public void testAddUser() {
    SqlSession sqlSession = MyBatisUtils.getSqlSession();
    UserDao userDao = sqlSession.getMapper(UserDao.class);
    userDao.addUser(new User(5, &quot;test&quot;, 123456));
    //需要提交事务
    sqlSession.commit();
    sqlSession.close();
}
</code></pre>
<h3 id="34-update">3.4 update</h3>
<ol>
<li>编写接口</li>
</ol>
<pre><code class="language-java">//更新用户
void updateUse(User user);
</code></pre>
<ol start="2">
<li>编写对应Mapper.xml文件中的sql语句</li>
</ol>
<pre><code class="language-xml">&lt;update id=&quot;updateUser&quot; parameterType=&quot;com.hjc.pojp.User&quot;&gt;
    update user set name = #{name}, pwd = #{pwd} where id = #{id}
&lt;/update&gt;
</code></pre>
<ol start="3">
<li>测试</li>
</ol>
<pre><code class="language-java">@Test
public void testUpdateUser() {
    SqlSession sqlSession = MyBatisUtils.getSqlSession();
    UserDao userDao = sqlSession.getMapper(UserDao.class);
    userDao.updateUser(new User(5, &quot;test&quot;, 123456));
    //需要提交事务
    sqlSession.commit();
    sqlSession.close();
}
</code></pre>
<h3 id="35-delete">3.5 delete</h3>
<ol>
<li>编写接口</li>
</ol>
<pre><code class="language-java">//删除用户
void deleteUserById(int id);
</code></pre>
<ol start="2">
<li>编写对应Mapper.xml文件中的sql语句</li>
</ol>
<pre><code class="language-xml">&lt;delete id=&quot;deleteUserById&quot; parameter=&quot;Integer&quot;&gt;
    delete from user where id = #{id}
&lt;/delete&gt;
</code></pre>
<ol start="3">
<li>测试</li>
</ol>
<pre><code class="language-java">@Test
public void testDeleteUserById() {
    SqlSession sqlSession = MyBatisUtils.getSqlSession();
    UserDao userDao = sqlSession.getMapper(UserDao.class);
    userDao.deleteUserById(5);
    //需要提交事务
    sqlSession.commit();
    sqlSession.close();
}
</code></pre>
<p><strong>注意点：MyBatis默认不会自动提交事务，需要手动提交事务</strong></p>
<h3 id="36-map">3.6 Map</h3>
<p>如果实体类或数据库中表的字段或参数过多，我们应当考虑使用Map作为sql的参数</p>
<pre><code class="language-java">void addUserByMap(Map&lt;String, Object&gt; map);
</code></pre>
<pre><code class="language-xml">&lt;insert id=&quot;addUserByMap&quot; parameterType=&quot;Map&quot;&gt;
    insert into user (id, pwd) values (#{userId}, #{userPwd})
&lt;/insert&gt;
</code></pre>
<pre><code class="language-java">@Test
public void testAddUserByMap() {
    SqlSession sqlSession = MyBatisUtils.getSqlSession();
    UserDao userDao = sqlSession.getMapper(UserDao.class);
    Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();
    map.put(&quot;userId&quot;, 6);
    map.put(&quot;userPwd&quot;, &quot;123456&quot;);
    userDao.addUserByMap(map);
    //需要提交事务
    sqlSession.commit();
    sqlSession.close();
}
</code></pre>
<ul>
<li>Map传递参数，直接在sql中取出key即可</li>
<li>对象传递参数，直接在sql中取对象的属性即可</li>
<li>只有一个基本类型参数的情况下，可以直接在sql中取到</li>
<li>多个参数的情况，用Map，或者注解</li>
</ul>
<h3 id="37-模糊查询">3.7 模糊查询</h3>
<pre><code class="language-java">List&lt;User&gt; getUserLike(String name);
</code></pre>
<pre><code class="language-xml">&lt;select id=&quot;getUserLike&quot; parameterType=&quot;String&quot; resultType=&quot;com.hjc.pojo.User&quot;&gt;
    select * from user where name like #{name}
&lt;/select&gt;
</code></pre>
<pre><code class="language-java">@Test
public void testGetUserLike() {
    SqlSession sqlSession = MyBatisUtils.getSqlSession();
    UserDao userDao = sqlSession.getMapper(UserDao.class);
    List&lt;User&gt; userList = userDao.getUserLike(&quot;%test%&quot;);
    for (User user : userList)
        System.out.println(user);
    sqlSession.close();
}
</code></pre>
<ul>
<li>在Java代码执行的时候，传递通配符&rdquo;% %&rdquo;</li>
</ul>
<pre><code class="language-java">List&lt;User&gt; userList = userDao.getUserLike(&quot;%test%&quot;);
</code></pre>
<ul>
<li>在sql拼接中使用通配符&rdquo;% %&rdquo;</li>
</ul>
<pre><code class="language-sql">select * from user where name like &quot;%&quot;#{name}&quot;%&quot;
</code></pre>
<h2 id="4-配置解析">4 配置解析</h2>
<h3 id="41-核心配置文件">4.1 核心配置文件</h3>
<ul>
<li>mybatis-config.xml</li>
<li>配置文件会影响MyBatis行为的设置和属性信息</li>
</ul>
<pre><code class="language-xml">configuration（配置）
    properties（属性）
    settings（设置）
    typeAliases（类型别名）
    typeHandlers（类型处理器）
    objectFactory（对象工厂）
    plugins（插件）
    environments（环境配置）
        environment（环境变量）
            transactionManager（事务管理器）
            dataSource（数据源）
    databaseIdProvider（数据库厂商标识）
    mappers（映射器）
</code></pre>
<h3 id="42-环境配置environments">4.2 环境配置（environments）</h3>
<p>MyBatis可以配置成适应多种环境，但每个SqlSessionFactory实例只能选择一种环境</p>
<p>MyBatis默认的事务管理器就是JDBC，连接池POOLED</p>
<h3 id="43-属性properties">4.3 属性（properties）</h3>
<p>可以通过properties属性来实现引用配置文件，属性可以在Java属性文件（properties文件）中配置，也可以通过properties元素的子元素来传递</p>
<ol>
<li>编写外部配置文件db.properties</li>
</ol>
<pre><code class="language-properties">driver=com.mysql.cj.jdbc.Driver
url=jdbc:mysql://localhost:3306/test_demo?useSSL=false&amp;allowPublicKeyRetrieval=true&amp;serverTimezone=UTC
username=root
password=123456
</code></pre>
<ol start="2">
<li>在核心配置文件中引入properties文件</li>
</ol>
<pre><code class="language-xml">&lt;properties resource=&quot;db.properties&quot;/&gt;
</code></pre>
<ol start="3">
<li>也可以在核心配置文件中增加属性</li>
</ol>
<pre><code class="language-xml">&lt;properties resource=&quot;db.properties&quot;&gt;
    &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
    &lt;property name=&quot;password&quot; value=&quot;111111&quot;/&gt;
&lt;/properties&gt;
</code></pre>
<ol start="4">
<li>如果两个地方都配置了同一字段，优先使用外部文件配置的信息</li>
</ol>
<h3 id="44-类型别名typealiases">4.4 类型别名（typeAliases）</h3>
<ul>
<li>类型别名是为Java类型设置一个短的名字，为了减少全限定类名的冗余</li>
</ul>
<pre><code class="language-xml">&lt;typeAliases&gt;
    &lt;typeAlias type=&quot;com.hjc.pojo.User&quot; alias=&quot;User&quot;/&gt;
&lt;/typeAliases&gt;
</code></pre>
<ul>
<li>指定一个包名，MyBatis会在包名下面搜索需要的JavaBean，默认别名就是这个类的类名，首字母小写，也可以配合注解@Alias使用</li>
</ul>
<pre><code class="language-xml">&lt;typeAliases&gt;
    &lt;package name=&quot;com.hjc.pojo&quot;/&gt;
&lt;/typeAliases&gt;
</code></pre>
<ul>
<li>在实体类比较少的时候，使用第一种方式；实体类比较多，建议第二种</li>
</ul>
<h3 id="45-设置settings">4.5 设置（settings）</h3>
<ul>
<li>cacheEnabled：全局开启或关闭所有映射器配置文件中已配置的任何缓存</li>
<li>lazyLoadingEnabled：开启或关闭延迟加载</li>
<li>logImpl：指定MyBatis所有日志的具体实现</li>
</ul>
<pre><code class="language-xml">&lt;settings&gt;
    &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;
    &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt;
    &lt;setting name=&quot;logImpl&quot; value=&quot;LOG4J&quot;/&gt;
&lt;/settings&gt;
</code></pre>
<h3 id="46-映射器mappers">4.6 映射器（mappers）</h3>
<p>注册绑定Mapper文件</p>
<ol>
<li>方式一</li>
</ol>
<pre><code class="language-xml">&lt;mappers&gt;
  &lt;mapper resource=&quot;com/hjc/dao/UserMapper.xml&quot;/&gt;
&lt;/mappers&gt;
</code></pre>
<ol start="2">
<li>方式二：使用class文件绑定注册</li>
</ol>
<pre><code class="language-xml">&lt;mappers&gt;
    &lt;mapper class=&quot;com.hjc.dao.UserMapper&quot;/&gt;
&lt;/mappers&gt;
</code></pre>
<p>注意点</p>
<ul>
<li><strong>接口和其Mapper配置文件必须同名</strong></li>
<li><strong>接口和其Mapper配置文件必须在同一个包下</strong></li>
</ul>
<ol start="3">
<li>方式三：使用扫描包进行绑定注册</li>
</ol>
<pre><code class="language-xml">&lt;mappers&gt;
    &lt;mapper package=&quot;com.hjc.dao&quot;/&gt;
&lt;/mappers&gt;
</code></pre>
<p>注意点</p>
<ul>
<li><strong>接口和其Mapper配置文件必须同名</strong></li>
<li><strong>接口和其Mapper配置文件必须在同一个包下</strong></li>
</ul>
<h3 id="47-其他配置">4.7 其他配置</h3>
<ul>
<li>typeHandlers（类型处理器）</li>
<li>objectFactory（对象工厂）</li>
<li>plugins插件
<ul>
<li>mybatis-generator-core</li>
<li>mybatis-plus</li>
<li>通用mapper</li>
</ul>
</li>
</ul>
<h3 id="48-生命周期和作用域">4.8 生命周期和作用域</h3>
<p><a href="/img/study-mybatis/%e6%b5%81%e7%a8%8b.png" target="_blank">
    <img src="/img/study-mybatis/%e6%b5%81%e7%a8%8b.png" alt="" />
</a></p>
<p>生命周期和作用域至关重要，错误使用会导致并发问题</p>
<p><strong>SqlSessionFactoryBuilder</strong></p>
<ul>
<li>一旦创建了SqlSessionFactory，就不再需要SqlSessionFactoryBuilder了</li>
<li>局部变量</li>
</ul>
<p><strong>SqlSessionFactory</strong></p>
<ul>
<li>相当于数据库连接池</li>
<li>一旦被创建就在应用的运行期间一直存在，没有理由丢弃它或重新创建另一个实例</li>
<li>SqlSessionFactory的最佳作用域是应用作用域</li>
<li>使用单例模式或者静态单例模式</li>
</ul>
<p><strong>SqlSesison</strong></p>
<ul>
<li>相当于连接到连接池的一个请求</li>
<li>不是线程安全的，不能被共享</li>
<li>SqlSession的最佳作用域是请求或方法作用域</li>
<li>用完之后要立即关闭，否则资源被占用</li>
</ul>
<p><a href="/img/study-mybatis/SqlSession.png" target="_blank">
    <img src="/img/study-mybatis/SqlSession.png" alt="" />
</a></p>
<p>图中的每个Mapper代表一个具体的业务</p>
<h2 id="5-实体类属性名和数据库字段名不一致问题">5 实体类属性名和数据库字段名不一致问题</h2>
<p>解决方法：</p>
<h3 id="51-起别名">5.1 起别名</h3>
<p>原来是</p>
<pre><code class="language-xml">&lt;select id=&quot;getUserById&quot; parameterType=&quot;int&quot; resultType=&quot;com.hjc.pojo.User&quot;&gt;
    select * from user where id = #{id}
&lt;/select&gt;
</code></pre>
<p>改为</p>
<pre><code class="language-xml">&lt;select id=&quot;getUserById&quot; parameterType=&quot;int&quot; resultType=&quot;com.hjc.pojo.User&quot;&gt;
    select id, name, pwd from user where id = #{id}
&lt;/select&gt;
</code></pre>
<h3 id="52-使用resultmap">5.2 使用resultMap</h3>
<p>结果集映射</p>
<pre><code class="language-xml">&lt;!--结果集映射--&gt;
&lt;resultMap id=&quot;UserMap&quot; type=&quot;User&quot;&gt;
    &lt;!--column为数据库字段，property为实体类属性--&gt;
    &lt;!--&lt;result column=&quot;id&quot; property=&quot;id&quot;/&gt;--&gt;
    &lt;!--&lt;result column=&quot;name&quot; property=&quot;name&quot;/&gt;--&gt;
    &lt;result column=&quot;pwd&quot; property=&quot;password&quot;/&gt;
&lt;/resultMap&gt;

&lt;select id=&quot;getUserById&quot; parameterType=&quot;int&quot; resultMap=&quot;UserMap&quot;&gt;
    select * from user where id = #{id}
&lt;/select&gt;
</code></pre>
<p>对于简单的语句不需要配置显示的结果集映射，而对于复杂一点的语句需要描述它们的关系</p>
<h2 id="6-日志">6 日志</h2>
<h3 id="61-日志工厂">6.1 日志工厂</h3>
<p>如果数据库操作出现异常，需要排错，那么日志就是最好的助手</p>
<p>以前可以使用sout打印，debug，现在有日志工厂</p>
<p>MyBatis使用内置的日志工厂提供日志功能，可以设置具体日志实现</p>
<p><strong>STDOUT_LOGGING</strong></p>
<p>在mybatis核心配置文件中配置日志</p>
<pre><code class="language-xml">&lt;settings&gt;
    &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt;
&lt;/settings&gt;
</code></pre>
<p>可以直接使用</p>
<h3 id="62-log4j">6.2 LOG4J</h3>
<ul>
<li>
<p>LOG4J可以控制日志信息输送的目的地是控制台，文件，GUI组件</p>
</li>
<li>
<p>可以控制每一条日志的输出格式</p>
</li>
<li>
<p>可以定义每一条日志信息的级别</p>
</li>
<li>
<p>LOG4J在配置完后不能直接使用</p>
</li>
</ul>
<ol>
<li>先导入LOG4J的包</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;log4j&lt;/groupId&gt;
    &lt;artifactId&gt;log4j&lt;/artifactId&gt;
    &lt;version&gt;1.2.17&lt;/version&gt;
&lt;/dependency&gt;

</code></pre>
<ol start="2">
<li>在resource文件夹下创建log4j.properties文件</li>
</ol>
<pre><code class="language-properties">#将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码
log4j.rootLogger=DEBUG,console,file

#控制台输出的相关设置
log4j.appender.console = org.apache.log4j.ConsoleAppender
log4j.appender.console.Target = System.out
log4j.appender.console.Threshold=DEBUG
log4j.appender.console.layout = org.apache.log4j.PatternLayout
log4j.appender.console.layout.ConversionPattern=[%c]-%m%n

#文件输出的相关设置
log4j.appender.file = org.apache.log4j.RollingFileAppender
log4j.appender.file.File=./log/hjc.log
log4j.appender.file.MaxFileSize=10mb
log4j.appender.file.Threshold=DEBUG
log4j.appender.file.layout=org.apache.log4j.PatternLayout
log4j.appender.file.layout.ConversionPattern=[%p][%d{yy-MM-dd}][%c]%m%n

#日志输出级别
log4j.logger.org.mybatis=DEBUG
log4j.logger.java.sql=DEBUG
log4j.logger.java.sql.Statement=DEBUG
log4j.logger.java.sql.ResultSet=DEBUG
log4j.logger.java.sql.PreparedStatement=DEBUG
</code></pre>
<ol start="3">
<li>配置log4j为日志实现</li>
</ol>
<pre><code class="language-xml">&lt;settings&gt;
    &lt;setting name=&quot;logImpl&quot; value=&quot;LOG4J&quot;/&gt;
&lt;/settings&gt;
</code></pre>
<ol start="4">
<li>log4j的使用，测试运行</li>
</ol>
<p><strong>简单使用</strong></p>
<ol>
<li>在要使用log4j的类中，导入包 import org.apache.log4j.Logger;</li>
<li>日志对象，参数为当前类的class</li>
</ol>
<pre><code class="language-java">private static Logger logger = Logger.getLogger(UserDaoTest.class);
</code></pre>
<ol start="3">
<li>日志级别</li>
</ol>
<pre><code class="language-java">logger.info(&quot;info: 开始测试&quot;);
logger.debug(&quot;debug: 开始debug&quot;);
logger.error(&quot;error: 出现了错误&quot;);
</code></pre>
<h2 id="7-分页">7 分页</h2>
<p>如果一次查询得到的数据量太大，会产生资源浪费的后果，所以要用到分页</p>
<ul>
<li>减少数据的处理量</li>
</ul>
<h3 id="71-使用limit分页">7.1 使用limit分页</h3>
<pre><code class="language-sql">语法：select * from user limit startIndex, pageSize;
例子：select * from user limit 1, 3;
</code></pre>
<p>MyBatis中实现分页</p>
<ol>
<li>编写接口，传输参数为map，map内存放start Index和pageSize</li>
</ol>
<pre><code class="language-java">//分页查询
List&lt;User&gt; getUserByLimit(Map&lt;String, Integer&gt; map);
</code></pre>
<ol start="2">
<li>编写对应的Mapper.xml文件</li>
</ol>
<pre><code class="language-xml">&lt;select id=&quot;getUserByLimit&quot; parameterType=&quot;map&quot; resultType=&quot;com.hjc.pojo.User&quot;&gt;
    select * from user limit #{startIndex}, #{pageSize}
&lt;/select&gt;
</code></pre>
<ol start="3">
<li>测试</li>
</ol>
<pre><code class="language-java">@Test
public void testGetUserByLimit() {
    SqlSession sqlSession = MyBatisUtils.getSqlSession();
    UserDao userDao = sqlSession.getMapper(UserDao.class);
    Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();
    map.put(&quot;startIndex&quot;, 1);
    map.put(&quot;pageSize&quot;, 2);
    List&lt;User&gt; userList = userDao.getUserByLimit(map);
    for (User user : userList)
        System.out.println(user);
    sqlSession.close();
}
</code></pre>
<h3 id="72-使用rowbounds分页">7.2 使用RowBounds分页</h3>
<p>不在sql中使用limit，使用面向对象思想</p>
<ol>
<li>编写接口</li>
</ol>
<pre><code class="language-java">List&lt;user&gt; getUserByRowBounds();
</code></pre>
<ol start="2">
<li>编写对应的Mapper.xml文件</li>
</ol>
<pre><code class="language-xml">&lt;select id=&quot;getUserByRowBounds&quot; resultType=&quot;com.hjc.pojo.User&quot;&gt;
    select * from user
&lt;/select&gt;
</code></pre>
<ol start="3">
<li>测试</li>
</ol>
<pre><code class="language-java">@Test
public void testGetUserByRowBounds() {
    SqlSession sqlSession = MyBatisUtils.getSqlSession();
    RowBounds rowBounds = new RowBounds(1, 2);
    //不使用Mapper来查询，使用以前的selectList来查询
    List&lt;User&gt; userList =
        sqlSession.selectList(&quot;com.hjc.dao.UserDao.getUserByRowBounds&quot;, null, rowBounds);
    for (User user : userList)
        System.out.println(user);
    sqlSession.close();
}
</code></pre>
<h3 id="73-使用分页插件">7.3 使用分页插件</h3>
<p>MyBatis分页插件PageHelper，<a href="https://pagehelper.github.io/" target="_blank">了解</a></p>
<h2 id="8-使用注解">8 使用注解</h2>
<h3 id="81-面向接口编程">8.1 面向接口编程</h3>
<p>在开发中，会选择面向接口编程</p>
<ul>
<li>根本原因是<strong>解耦</strong>，可拓展，提高复用</li>
<li>分层开发中，上层不需要管具体的实现</li>
<li>规范性更好</li>
</ul>
<p>关于接口的理解</p>
<ul>
<li>从深层次的理解，接口是定义（规范、约束）与实现的分离</li>
<li>接口的本身反映了系统设计人员对系统的抽象理解</li>
<li>接口有两类
<ul>
<li>第一类是对一个个体的抽象，对应为一个抽象体（abstract class）</li>
<li>第二类是对一个个体某一方面的抽象，即形成一个抽象面（interface）</li>
</ul>
</li>
<li>一个个体可能有多个抽象面</li>
</ul>
<h3 id="82-注解">8.2 注解</h3>
<ol>
<li>注解在接口内方法名上标注</li>
</ol>
<pre><code class="language-java">@Select(&quot;select * from user&quot;)
List&lt;User&gt; getUsers();
</code></pre>
<ol start="2">
<li>需要在核心配置文件中绑定接口</li>
</ol>
<pre><code class="language-xml">&lt;mappers&gt;
    &lt;mapper class=&quot;com.hjc.dao.UserDao&quot;/&gt;
&lt;/mappers&gt;
</code></pre>
<ol start="3">
<li>测试</li>
</ol>
<ul>
<li>本质：反射机制实现</li>
<li>底层：动态代理</li>
</ul>
<h3 id="83-注解实现crud">8.3 注解实现CRUD</h3>
<p>可以在工具类内实现自动提交事务</p>
<pre><code class="language-java">public static sqlSession getSqlSession() {
    return sqlSessionFactory.openSession(true);
}
</code></pre>
<ol>
<li>编写接口</li>
</ol>
<pre><code class="language-java">public interface UserDao {
    
    @Select(&quot;select * from user where id = #{id}&quot;)
    User getUserById(@param(&quot;id&quot;) int id);
    
    @Insert(&quot;insert into user (id, name, pwd) values (#{id}, #{name}, #{pwd})&quot;)
    int addUser(User user);
    
    @Update(&quot;update user set name = #{name}, pwd = #{pwd} where id = #{id}&quot;)
    int updateUser(User user);
    
    @Delete(&quot;delete from user where id = #{uid}&quot;)
    int deleteUser(@Param(&quot;uid&quot;) int id);
}
</code></pre>
<ol start="2">
<li>绑定接口</li>
</ol>
<pre><code class="language-xml">&lt;mappers&gt;
    &lt;mapper class=&quot;com.hjc.dao.UserDao&quot;/&gt;
&lt;/mappers&gt;
</code></pre>
<ol start="3">
<li>测试</li>
</ol>
<p><strong>关于@Param注解</strong></p>
<ul>
<li>基本类型的参数或者String类型，需要加上</li>
<li>引用类型不需要加</li>
<li>如果只有一个基本类型参数的话，可以忽略</li>
<li>在sql语句中使用的参数就是注解内设定的属性名</li>
</ul>
<h2 id="9-mybatis执行流程">9 MyBatis执行流程</h2>
<p><a href="/img/study-mybatis/MyBatis%e6%89%a7%e8%a1%8c%e6%b5%81%e7%a8%8b.png" target="_blank">
    <img src="/img/study-mybatis/MyBatis%e6%89%a7%e8%a1%8c%e6%b5%81%e7%a8%8b.png" alt="" />
</a></p>
<h2 id="10-lombok">10 Lombok</h2>
<p>lombok是一个插件，通过注解来消除业务中冗长的代码，尤其对于POJO</p>
<p>使用步骤</p>
<ol>
<li>在IDEA中安装Lombok插件</li>
<li>在项目中导入Lombok包</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
    &lt;artifactId&gt;lombok&lt;/artifactId&gt;
    &lt;version&gt;1.18.10&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<ol start="3">
<li>在实体类上加注解
<ol>
<li>@Data</li>
<li>@AllArgsConstructor</li>
<li>@NoArgsConstructor</li>
<li>……</li>
</ol>
</li>
</ol>
<h2 id="11--多对一关系处理">11  多对一关系处理</h2>
<p>mysql中多对一查询方式</p>
<ul>
<li>子查询</li>
<li>联表查询</li>
</ul>
<p>假设多个学生对应一个老师，那么先分别写对应实体类</p>
<pre><code class="language-java">@Data
public Student implements Serializable {
    private int id;
    private String name;
    //学生需要关联一个老师
    private Teacher teacher;
}
</code></pre>
<pre><code class="language-java">@Data
public Teacher implements Serializable {
    private int id;
    private String name;
}
</code></pre>
<p>要查出所有学生以及对应的老师，有两种方法</p>
<h3 id="111-按照查询嵌套处理">11.1 按照查询嵌套处理</h3>
<p>思路：</p>
<ol>
<li>查询所有的学生信息</li>
<li>根据查询出的学生tid，查询对应的老师，相当于子查询</li>
</ol>
<pre><code class="language-xml">&lt;select id=&quot;getStudent&quot; resultMap=&quot;StudentPlusTeacher&quot;&gt;
    select * from student
&lt;/select&gt;

&lt;resultMap id=&quot;StudentPlusTeacher&quot; type=&quot;Student&quot;&gt;
    &lt;!--主键--&gt;
    &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt;
    &lt;result property=&quot;name&quot; column=&quot;name&quot;/&gt;
    &lt;!--复杂的属性需要单独处理，对象用association，集合用collection
    javaType表示属性的类型--&gt;
    &lt;association property=&quot;teacher&quot; column=&quot;tid&quot; javaType=&quot;Teacher&quot; select=&quot;getTeacher&quot;/&gt;
&lt;/resultMap&gt;

&lt;select id=&quot;getTeacher&quot; parameterType=&quot;int&quot; resultType=&quot;Teacher&quot;&gt;
    select * form teacher where id = #{id}
&lt;/select&gt;
</code></pre>
<p>注：在核心配置文件中已经配置了别名，所以可以省去实体类的包路径</p>
<h3 id="112-按照结果嵌套处理">11.2 按照结果嵌套处理</h3>
<pre><code class="language-xml">&lt;select id=&quot;getStudent&quot; resultMap=&quot;StudentPlusTeacher&quot;&gt;
    select s.id as sid, s.name as sname, t.name as tname
    from student s, teacher t
    where s.tid = t.id
&lt;/select&gt;

&lt;resultMap id=&quot;StudentPlusTeacher&quot; type=&quot;Student&quot;&gt;
    &lt;id property=&quot;id&quot; column=&quot;sid&quot;/&gt;
    &lt;result property=&quot;name&quot; column=&quot;sname&quot;/&gt;
    &lt;association property=&quot;teacher&quot; javaType=&quot;Teacher&quot;&gt;
        &lt;result property=&quot;name&quot; column=&quot;tname&quot;/&gt;
    &lt;/association&gt;
&lt;/resultMap&gt;
</code></pre>
<h2 id="12-一对多关系处理">12 一对多关系处理</h2>
<p>假设一个老师有多个学生，那么先分别写对应的实体类</p>
<pre><code class="language-java">@Data
public class Student implements Serializable {
    private int id;
    private String name;
    private int tid;
}
</code></pre>
<pre><code class="language-java">@Data
public class Teacher implements Serializable {
    private int id;
    private String name;
    //一个老师有多个学生
    private List&lt;Student&gt; students;
}
</code></pre>
<p>要查出指定老师及其对应的所有学生</p>
<h3 id="121-按照结果嵌套处理">12.1 按照结果嵌套处理</h3>
<pre><code class="language-xml">&lt;select id=&quot;getTeacher&quot; parameterType=&quot;int&quot; resultMap=&quot;TeacherPlusStudent&quot;&gt;
    select s.id as sid, s.name as sname, t.name as tname, t.id as tid
    from student s, teacher t
    where s.tid = t.id and t.id = #{tid}
&lt;/select&gt;

&lt;resultMap id=&quot;TeacherPlusStudent&quot; type=&quot;Teacher&quot;&gt;
    &lt;id property=&quot;id&quot; column=&quot;tid&quot;/&gt;
    &lt;result property=&quot;name&quot; column=&quot;tname&quot;/&gt;
    &lt;!--复杂的属性需要单独处理，对象用association，集合用collection
    ofType表示集合中的泛型信息--&gt;
    &lt;collection proerty=&quot;students&quot; ofType=&quot;Student&quot;&gt;
        &lt;id property=&quot;id&quot; column=&quot;sid&quot;/&gt;
        &lt;result property=&quot;name&quot; column=&quot;sname&quot;/&gt;
        &lt;result property=&quot;tid&quot; column=&quot;tid&quot;/&gt;
    &lt;/collection&gt;
&lt;/resultMap&gt;
</code></pre>
<h3 id="122-按照查询嵌套处理">12.2 按照查询嵌套处理</h3>
<pre><code class="language-xml">&lt;select id=&quot;getTeacher&quot; parameterType=&quot;int&quot; resultMap=&quot;TeacherPlusStudent&quot;&gt;
    select * from teacher where id = #{tid}
&lt;/select&gt;

&lt;resultMap id=&quot;TeacherPlusStudent&quot; type=&quot;Teacher&quot;&gt;
    &lt;collection property=&quot;students&quot; javaType=&quot;ArrayList&quot; ofType=&quot;Student&quot; select=&quot;getStudentByTeacherId&quot; column=&quot;id&quot;/&gt;
&lt;/resultMap&gt;

&lt;select id=&quot;getStudentByTeacherId&quot; parameter=&quot;int&quot; resultType=&quot;Student&quot;&gt;
    select * from student where tid = #{tid}
&lt;/select&gt;
</code></pre>
<h3 id="123-总结">12.3 总结</h3>
<ol>
<li>关联：association，表示多对一</li>
<li>集合：collection，表示一对多</li>
<li>javaType：用来指定实体类中属性的类型</li>
<li>ofType：用来指定集合中的泛型信息，即集合内的pojo类型</li>
</ol>
<h2 id="13-动态sql">13 动态SQL</h2>
<p>动态SQL是指根据不同的条件生成不同的SQL语句，之前的项目写sql时，有时候会根据不同的条件拼接sql语句，现在可以使用动态SQL来实现</p>
<p>参考mybatis官方文档中对于<a href="https://mybatis.org/mybatis-3/zh/dynamic-sql.html" target="_blank">动态SQL</a>的解释</p>
<h3 id="131-if">13.1 if</h3>
<pre><code class="language-xml">&lt;select id=&quot;findActiveBlogWithTitleLike&quot; resultType=&quot;Blog&quot;&gt;
    SELECT * FROM BLOG
    WHERE state = ‘ACTIVE’
    &lt;if test=&quot;title != null&quot;&gt;
        AND title like #{title}
    &lt;/if&gt;
&lt;/select&gt;
</code></pre>
<h3 id="132-choosewhenotherwise">13.2 choose、when、otherwise</h3>
<p>相当于switch语句</p>
<pre><code class="language-xml">&lt;select id=&quot;findActiveBlogLike&quot; resultType=&quot;Blog&quot;&gt;
    SELECT * FROM BLOG WHERE state = ‘ACTIVE’
    &lt;choose&gt;
        &lt;when test=&quot;title != null&quot;&gt;
            AND title like #{title}
        &lt;/when&gt;
        &lt;when test=&quot;author != null and author.name != null&quot;&gt;
            AND author_name like #{author.name}
        &lt;/when&gt;
        &lt;otherwise&gt;
            AND featured = 1
        &lt;/otherwise&gt;
    &lt;/choose&gt;
&lt;/select&gt;
</code></pre>
<h3 id="133-wheresettrim">13.3 where、set、trim</h3>
<p>上面几个例子，sql语句中WHERE关键字后面都跟了默认的条件state = ‘ACTIVE’，如果把这条语句删了或者改为动态SQL，那么整个SQL语句会出现问题，比如</p>
<pre><code class="language-xml">&lt;select id=&quot;findActiveBlogLike&quot; resultType=&quot;Blog&quot;&gt;
    SELECT * FROM BLOG
    WHERE
    &lt;if test=&quot;state != null&quot;&gt;
        state = #{state}
    &lt;/if&gt;
    &lt;if test=&quot;title != null&quot;&gt;
        AND title like #{title}
    &lt;/if&gt;
    &lt;if test=&quot;author != null and author.name != null&quot;&gt;
        AND author_name like #{author.name}
    &lt;/if&gt;
&lt;/select&gt;
</code></pre>
<p>如果if条件一个都不满足，那么sql变为</p>
<pre><code class="language-sql">SELECT * FROM BLOG WHERE
</code></pre>
<p>很明显，这条sql语句是错误的</p>
<p>如果第一个id条件不满足，那么sql变为</p>
<pre><code class="language-sql">SELECT * FROM BLOG WHERE AND title like #{title} ……
</code></pre>
<p>很明显，这条sql语句也是错误的</p>
<p>那么，MyBatis提供了<em>where</em>标签，可以解决这些问题。我们把上面的例子用where标签修改</p>
<pre><code class="language-xml">&lt;select id=&quot;findActiveBlogLike&quot; resultType=&quot;Blog&quot;&gt;
    SELECT * FROM BLOG
    &lt;where&gt;
        &lt;if test=&quot;state != null&quot;&gt;
            state = #{state}
        &lt;/if&gt;
        &lt;if test=&quot;title != null&quot;&gt;
            AND title like #{title}
        &lt;/if&gt;
        &lt;if test=&quot;author != null and author.name != null&quot;&gt;
            AND author_name like #{author.name}
        &lt;/if&gt;
    &lt;/where&gt;
&lt;/select&gt;
</code></pre>
<pre><code class="language-xml">&lt;select id=&quot;findActiveBlogLike&quot; resultType=&quot;Blog&quot;&gt;
    SELECT * FROM BLOG
    &lt;where&gt;
        &lt;choose&gt;
            &lt;when test=&quot;title != null&quot;&gt;
                AND title like #{title}
            &lt;/when&gt;
            &lt;when test=&quot;author != null and author.name != null&quot;&gt;
                AND author_name like #{author.name}
            &lt;/when&gt;
            &lt;otherwise&gt;
                AND featured = 1
            &lt;/otherwise&gt;
        &lt;/choose&gt;
    &lt;/where&gt;
&lt;/select&gt;
</code></pre>
<p><em>where</em> 元素只会在子元素返回任何内容的情况下才插入 “WHERE” 子句。而且，若子句的开头为 “AND” 或 “OR”，<em>where</em> 元素也会将它们去除</p>
<p>另外，<em>set</em>标签类似于<em>where</em>标签，会动态地设置SET关键字，同时也会删掉无关的逗号</p>
<pre><code class="language-xml">&lt;update id=&quot;updateAuthorIfNecessary&quot;&gt;
    update Author
    &lt;set&gt;
        &lt;if test=&quot;username != null&quot;&gt;
            username = #{username},
        &lt;/if&gt;
        &lt;if test=&quot;password != null&quot;&gt;
            password = #{password},
        &lt;/if&gt;
        &lt;if test=&quot;email != null&quot;&gt;
            email = #{email},
        &lt;/if&gt;
        &lt;if test=&quot;bio != null&quot;&gt;
            bio = #{bio}
        &lt;/if&gt;
    &lt;/set&gt;
    where id = #{id}
&lt;/update&gt;
</code></pre>
<p><em>set</em>会自动在行首插入SET关键字，并根据传进来的参数是否为空决定sql语句的结构</p>
<p><em>trim</em>标签与<em>set</em>标签等价</p>
<h3 id="134-sql片段">13.4 SQL片段</h3>
<p>SQL片段：将sql语句的部分提取出来，方便复用</p>
<pre><code class="language-xml">&lt;sql id=&quot;test&quot;&gt;
    &lt;if test=&quot;state != null&quot;&gt;
        state = #{state}
    &lt;/if&gt;
    &lt;if test=&quot;title != null&quot;&gt;
        AND title like #{title}
    &lt;/if&gt;
    &lt;if test=&quot;author != null and author.name != null&quot;&gt;
        AND author_name like #{author.name}
    &lt;/if&gt;
&lt;/sql&gt;

&lt;select id=&quot;findActiveBlogLike&quot; resultType=&quot;Blog&quot;&gt;
    SELECT * FROM BLOG
    &lt;where&gt;
        &lt;include refid=&quot;test&quot;/&gt;
    &lt;/where&gt;
&lt;/select&gt;
</code></pre>
<p>注意：</p>
<ul>
<li>最好基于单表来定义SQL片段</li>
<li>SQL片段内不要存在<em>where</em>标签</li>
</ul>
<h3 id="135-foreach">13.5 foreach</h3>
<p>遇到IN语句的时候，可以使用<em>foreach</em>标签对集合进行遍历</p>
<pre><code class="language-xml">&lt;select id=&quot;selectPostIn&quot; parameterType=&quot;list&quot; resultType=&quot;domain.blog.Post&quot;&gt;
    SELECT *
    FROM POST P
    WHERE ID in
    &lt;!--传入参数为list集合--&gt;
    &lt;foreach item=&quot;item&quot; index=&quot;index&quot; collection=&quot;list&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt;
        #{item}
    &lt;/foreach&gt;
&lt;/select&gt;
</code></pre>
<p>可以将任何可迭代对象（如 List、Set 等）、Map 对象或者数组对象作为集合参数传递给 <em>foreach</em>。当使用可迭代对象或者数组时，index 是当前迭代的序号，item 的值是本次迭代获取到的元素。当使用 Map 对象（或者 Map.Entry 对象的集合）时，index 是键，item 是值</p>
<p><strong>总结</strong></p>
<p>动态SQL就是在拼接SQL语句，只要保证SQL的正确性，就按照SQL的格式排列组合。先写出完整的SQL语句，再对应修改称为动态SQL实现通用</p>
<h2 id="14-缓存">14 缓存</h2>
<h3 id="141-简介">14.1 简介</h3>
<ol>
<li>什么是缓存
<ul>
<li>存在内存中的临时数据</li>
<li>将用户经常查询的数据放在缓存中，下次查询时不用再从数据库中获取，而是从缓存中获取，从而提高查询效率，解决高并发系统的性能问题</li>
</ul>
</li>
<li>为什么使用缓存
<ul>
<li>减少和数据库的交互次数，减少系统开销，提高系统效率</li>
</ul>
</li>
<li>什么数据能使用缓存
<ul>
<li>经常查询且不经常改变的数据</li>
</ul>
</li>
</ol>
<h3 id="142-mybatis缓存">14.2 MyBatis缓存</h3>
<ul>
<li>MyBatis包含一个强大的查询缓存特性，可以非常方便地定制和配置缓存</li>
<li>MyBatis默认定义了两级缓存：一级缓存和二级缓存
<ul>
<li><strong>默认情况下，只有一级缓存开启（SqlSession级别的缓存，也称为本地缓存）</strong></li>
<li>二级缓存需要手动开启和配置，是基于namespace级别的缓存</li>
<li>MyBatis定义了缓存接口Cache，可以通过实现Cache接口来自定义二级缓存</li>
</ul>
</li>
</ul>
<h3 id="143-缓存原理">14.3 缓存原理</h3>
<p><a href="/img/study-mybatis/%e7%bc%93%e5%ad%98%e5%8e%9f%e7%90%86.png" target="_blank">
    <img src="/img/study-mybatis/%e7%bc%93%e5%ad%98%e5%8e%9f%e7%90%86.png" alt="" />
</a></p>
<h3 id="144-一级缓存">14.4 一级缓存</h3>
<ul>
<li>一级缓存也叫本地缓存：SqlSession
<ul>
<li>相当于一个map</li>
<li>和数据库同一次会话（同一次SqlSession）期间查询到的数据会放在本地缓存中</li>
<li>以后如果要获取相同的数据，可以直接从缓存中取，不需要从数据库中查询</li>
</ul>
</li>
</ul>
<p>测试</p>
<pre><code class="language-java">@Test
public void test() {
    SqlSession sqlSession = MyBatisUtils.getSqlSession();
    UserDao userDao = sqlSession.getMapper(UserDao.class);
    User user1 = userDao.getUserById(1);
    User user2 = userDao.getUserById(1);
    System.out.println(user1 == user2);
    sqlSession.close();
}
</code></pre>
<p>根据日志，我们可以看到sql只执行了一次，user1和user2是同一个</p>
<ul>
<li>缓存失效的情况
<ul>
<li>查询不同的数据</li>
<li>增删改操作可能会改变原来的数据，缓存会刷新</li>
<li>使用不同的Mapper进行查询</li>
<li>手动清除缓存</li>
</ul>
</li>
</ul>
<h3 id="145-二级缓存">14.5 二级缓存</h3>
<ul>
<li>二级缓存也叫全局缓存，作用域比一级缓存要大</li>
<li>基于namespace级别的缓存，一个命名空间对应一个二级缓存</li>
<li>工作机制
<ul>
<li>一次会话查询一条数据，这个数据会被放在当前会话的一级缓存中</li>
<li>如果当前会话关闭了，那么对应的一级缓存就没了。但是二级缓存开启后，会话关闭之后，一级缓存中的数据会保存到二级缓存中</li>
<li>新的会话查询数据，就可以从二级缓存中获取数据</li>
<li>不同的Mapper查出的数据会放在对应的缓存中</li>
</ul>
</li>
</ul>
<p>步骤</p>
<ol>
<li>在核心配置文件中开启全局缓存</li>
</ol>
<pre><code class="language-xml">&lt;settings&gt;
    &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;
&lt;/settings&gt;
</code></pre>
<ol start="2">
<li>在要使用二级缓存的Mapper.xml中开启二级缓存，可以自定义缓存属性</li>
</ol>
<pre><code class="language-xml">&lt;cache eviction=&quot;FIFO&quot; flushInterval=&quot;60000&quot; size=&quot;512&quot; readOnly=&quot;true&quot;/&gt;
</code></pre>
<ol start="3">
<li>测试</li>
</ol>
<pre><code class="language-java">@Test
public void test() {
    SqlSession sqlSession1 = MyBatisUtils.getSqlSession();
    UserDao userDao1 = sqlSession1.getMapper(UserDao.class);
    User user1 = userDao1.getUserById(1);
    sqlSession1.close();
    //只有sqlSession1关闭后，一级缓存内的数据才会进入二级缓存
    SqlSession sqlSession2 = MyBatisUtils.getSqlSession();
    UserDao userDao2 = sqlSession2.getMapper(UserDao.class);
    User user2 = userDao2.getUserById(1);
    sqlSession2.close();
    
    System.out.println(user1 == user2);
}
</code></pre>
<p>根据日志可以看到sql只执行了一次，且查到的User对象是同一个</p>
<p>注意：</p>
<ul>
<li>二级缓存对同一个Mapper下的数据才能起到提高效率的效果</li>
<li>数据会先放在一级缓存中，只有当会话提交或者关闭后，才会放到二级缓存中</li>
</ul>
<h3 id="146-自定义缓存ehcache">14.6 自定义缓存EhCache</h3>
<p>可以使用自定义的缓存，也可以使用第三方的缓存</p>

    </div>
</article>


<div class="license markdown-body">
    <blockquote>
        <p>除特殊注明部分，本站内容采用 <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"
               target="_blank">CC BY-NC-SA 4.0</a> 进行许可。</p>
    </blockquote>
</div>



            </div>
            <aside class="col-12 col-md-3 float-left sidebar">
    
    
    
    <div class="sidebar-item sidebar-toc">
        <h3>目录</h3>
        <nav id="TableOfContents">
  <ul>
    <li><a href="#1-简介">1 简介</a>
      <ul>
        <li><a href="#11-什么是mybatis">1.1 什么是MyBatis</a></li>
        <li><a href="#12-持久化">1.2 持久化</a></li>
        <li><a href="#13-持久层">1.3 持久层</a></li>
        <li><a href="#14-为什么需要mybatis">1.4 为什么需要MyBatis</a></li>
      </ul>
    </li>
    <li><a href="#2-第一个mybatis程序">2 第一个MyBatis程序</a>
      <ul>
        <li><a href="#21-搭建环境">2.1 搭建环境</a></li>
        <li><a href="#22-编写代码">2.2 编写代码</a></li>
        <li><a href="#23-测试代码">2.3 测试代码</a></li>
      </ul>
    </li>
    <li><a href="#3-crud">3 CRUD</a>
      <ul>
        <li><a href="#31-namespace">3.1 namespace</a></li>
        <li><a href="#32-select">3.2 select</a></li>
        <li><a href="#33-insert">3.3 insert</a></li>
        <li><a href="#34-update">3.4 update</a></li>
        <li><a href="#35-delete">3.5 delete</a></li>
        <li><a href="#36-map">3.6 Map</a></li>
        <li><a href="#37-模糊查询">3.7 模糊查询</a></li>
      </ul>
    </li>
    <li><a href="#4-配置解析">4 配置解析</a>
      <ul>
        <li><a href="#41-核心配置文件">4.1 核心配置文件</a></li>
        <li><a href="#42-环境配置environments">4.2 环境配置（environments）</a></li>
        <li><a href="#43-属性properties">4.3 属性（properties）</a></li>
        <li><a href="#44-类型别名typealiases">4.4 类型别名（typeAliases）</a></li>
        <li><a href="#45-设置settings">4.5 设置（settings）</a></li>
        <li><a href="#46-映射器mappers">4.6 映射器（mappers）</a></li>
        <li><a href="#47-其他配置">4.7 其他配置</a></li>
        <li><a href="#48-生命周期和作用域">4.8 生命周期和作用域</a></li>
      </ul>
    </li>
    <li><a href="#5-实体类属性名和数据库字段名不一致问题">5 实体类属性名和数据库字段名不一致问题</a>
      <ul>
        <li><a href="#51-起别名">5.1 起别名</a></li>
        <li><a href="#52-使用resultmap">5.2 使用resultMap</a></li>
      </ul>
    </li>
    <li><a href="#6-日志">6 日志</a>
      <ul>
        <li><a href="#61-日志工厂">6.1 日志工厂</a></li>
        <li><a href="#62-log4j">6.2 LOG4J</a></li>
      </ul>
    </li>
    <li><a href="#7-分页">7 分页</a>
      <ul>
        <li><a href="#71-使用limit分页">7.1 使用limit分页</a></li>
        <li><a href="#72-使用rowbounds分页">7.2 使用RowBounds分页</a></li>
        <li><a href="#73-使用分页插件">7.3 使用分页插件</a></li>
      </ul>
    </li>
    <li><a href="#8-使用注解">8 使用注解</a>
      <ul>
        <li><a href="#81-面向接口编程">8.1 面向接口编程</a></li>
        <li><a href="#82-注解">8.2 注解</a></li>
        <li><a href="#83-注解实现crud">8.3 注解实现CRUD</a></li>
      </ul>
    </li>
    <li><a href="#9-mybatis执行流程">9 MyBatis执行流程</a></li>
    <li><a href="#10-lombok">10 Lombok</a></li>
    <li><a href="#11--多对一关系处理">11  多对一关系处理</a>
      <ul>
        <li><a href="#111-按照查询嵌套处理">11.1 按照查询嵌套处理</a></li>
        <li><a href="#112-按照结果嵌套处理">11.2 按照结果嵌套处理</a></li>
      </ul>
    </li>
    <li><a href="#12-一对多关系处理">12 一对多关系处理</a>
      <ul>
        <li><a href="#121-按照结果嵌套处理">12.1 按照结果嵌套处理</a></li>
        <li><a href="#122-按照查询嵌套处理">12.2 按照查询嵌套处理</a></li>
        <li><a href="#123-总结">12.3 总结</a></li>
      </ul>
    </li>
    <li><a href="#13-动态sql">13 动态SQL</a>
      <ul>
        <li><a href="#131-if">13.1 if</a></li>
        <li><a href="#132-choosewhenotherwise">13.2 choose、when、otherwise</a></li>
        <li><a href="#133-wheresettrim">13.3 where、set、trim</a></li>
        <li><a href="#134-sql片段">13.4 SQL片段</a></li>
        <li><a href="#135-foreach">13.5 foreach</a></li>
      </ul>
    </li>
    <li><a href="#14-缓存">14 缓存</a>
      <ul>
        <li><a href="#141-简介">14.1 简介</a></li>
        <li><a href="#142-mybatis缓存">14.2 MyBatis缓存</a></li>
        <li><a href="#143-缓存原理">14.3 缓存原理</a></li>
        <li><a href="#144-一级缓存">14.4 一级缓存</a></li>
        <li><a href="#145-二级缓存">14.5 二级缓存</a></li>
        <li><a href="#146-自定义缓存ehcache">14.6 自定义缓存EhCache</a></li>
      </ul>
    </li>
  </ul>
</nav>
    </div>
    
    
    
    <div class="sidebar-item sidebar-pages">
        <h3>页面</h3>
        <ul>
            
            <li>
                <a href="/">Home</a>
            </li>
            
            <li>
                <a href="/archives/">Archives</a>
            </li>
            
            <li>
                <a href="/about/">About</a>
            </li>
            
            <li>
                <a href="/search/">Search</a>
            </li>
            
            <li>
                <a href="/index.xml">RSS</a>
            </li>
            
        </ul>
    </div>
    
    <div class="sidebar-item sidebar-tags">
        <h3>标签</h3>
        <div>
            
            <span>
                <a href="/tags/c&#43;&#43;/">c&#43;&#43;</a>
            </span>
            
            <span>
                <a href="/tags/java/">java</a>
            </span>
            
            <span>
                <a href="/tags/jdbc/">jdbc</a>
            </span>
            
            <span>
                <a href="/tags/mybatis/">mybatis</a>
            </span>
            
            <span>
                <a href="/tags/servlet/">servlet</a>
            </span>
            
            <span>
                <a href="/tags/spring/">spring</a>
            </span>
            
            <span>
                <a href="/tags/web/">web</a>
            </span>
            
            <span>
                <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
            </span>
            
            <span>
                <a href="/tags/%E7%AE%97%E6%B3%95/">算法</a>
            </span>
            
        </div>
    </div>
    
    <div class="sidebar-item sidebar-links">
        <h3>链接</h3>
        <ul>
            
            <li>
                <a href="https://github.com/keichw" target="_blank"><span>GitHub</span></a>
            </li>
            
        </ul>
    </div>
    
</aside>
        </div>
        <div class="btn">
    <div class="btn-toggle-mode">
        <ion-icon name="contrast"></ion-icon>
    </div>
    <div class="btn-scroll-top">
        <ion-icon name="chevron-up"></ion-icon>
    </div>
</div>
    </main>

    <footer>
    <div class="container-lg clearfix">
        <div class="col-12 footer">
            <span>&copy; 2020 <a href="https://example.com">Kinopio</a> |
                基于 <a href="https://github.com/amzrk2/hugo-theme-fuji/"
                   target="_blank">Fuji-v2</a> & <a href="https://gohugo.io/"
                   target="_blank">Hugo</a> 构建</span>
        </div>
    </div>
</footer>
    
    <script async type="module" src="https://cdn.jsdelivr.net/npm/ionicons@5.0.1/dist/ionicons/ionicons.esm.js"></script>
<script async nomodule src="https://cdn.jsdelivr.net/npm/ionicons@5.0.1/dist/ionicons/ionicons.js"></script>

<script defer src="https://cdn.jsdelivr.net/npm/prismjs@1.20.0/components/prism-core.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/prismjs@1.20.0/plugins/autoloader/prism-autoloader.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/lazysizes@5.2.2/lazysizes.min.js"></script>

<script defer src="/assets/js/fuji.min.js"></script>

</body>

</html>