<!DOCTYPE html>
<html lang="zh-hans">

<head>
    
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
<meta name="HandheldFriendly" content="True" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
<meta name="generator" content="Hugo 0.73.0" />



<link rel="apple-touch-icon" sizes="180x180" href="https://cdn.jsdelivr.net/gh/amzrk2/poal-jsdelivr@1.6.0/favicons/apple-touch-icon.png" />
<link rel="icon" type="image/png" sizes="32x32" href="https://cdn.jsdelivr.net/gh/amzrk2/poal-jsdelivr@1.6.0/favicons/favicon-32x32.png" />
<link rel="icon" type="image/png" sizes="16x16" href="https://cdn.jsdelivr.net/gh/amzrk2/poal-jsdelivr@1.6.0/favicons/favicon-16x16.png" />
<link rel="manifest" href="https://cdn.jsdelivr.net/gh/amzrk2/poal-jsdelivr@1.6.0/favicons/site.webmanifest" />
<link rel="mask-icon" href="https://cdn.jsdelivr.net/gh/amzrk2/poal-jsdelivr@1.6.0/favicons/safari-pinned-tab.svg" color="#8aa2d3" />
<link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/amzrk2/poal-jsdelivr@1.6.0/favicons/favicon.ico" />
<meta name="msapplication-TileColor" content="#8aa2d3" />
<meta name="msapplication-config" content="https://cdn.jsdelivr.net/gh/amzrk2/poal-jsdelivr@1.6.0/favicons/browserconfig.xml" />
<meta name="theme-color" content="#ffffff" />


<title>JavaWeb技术原理 - Kinopio BLOG</title>


<meta name="author" content="Kinopio" />


<meta name="description" content="A minimal Hugo theme with nice theme color." />


<meta name="keywords" content="java, web, servlet, jdbc" />

<meta property="og:title" content="JavaWeb技术原理" />
<meta property="og:description" content="最近在重温JavaWeb的内容，特此记录一下。 1 基本概念 1.1 前言 web开发： 静态web html，css 提供给所有人看的数据始终不会变化 动态web 几乎所有网站，淘宝 提供给所有人看的数据始终会发生变化，每个" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://keichw.github.io/post/javaweb/" />
<meta property="og:image" content="https://keichw.github.io/img/og.png"/>
<meta property="article:published_time" content="2020-07-06T21:07:03+08:00" />
<meta property="article:modified_time" content="2020-07-06T21:07:03+08:00" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://keichw.github.io/img/og.png"/>

<meta name="twitter:title" content="JavaWeb技术原理"/>
<meta name="twitter:description" content="最近在重温JavaWeb的内容，特此记录一下。 1 基本概念 1.1 前言 web开发： 静态web html，css 提供给所有人看的数据始终不会变化 动态web 几乎所有网站，淘宝 提供给所有人看的数据始终会发生变化，每个"/>



<style>
    @media (prefers-color-scheme: dark) {
        body[data-theme='auto'] img {
            filter: brightness(60%);
        }
    }

    body[data-theme='dark'] img {
        filter: brightness(60%);
    }
</style>


<link rel="stylesheet" href="/assets/css/fuji.min.css" />






</head>

<body data-theme="auto">
    <script data-cfasync="false">
    
    var fujiThemeData = localStorage.getItem('fuji_data-theme');
    
    if (!fujiThemeData) {
        localStorage.setItem('fuji_data-theme', 'auto');
    } else {
        
        if (fujiThemeData !== 'auto') {
            document.body.setAttribute('data-theme', fujiThemeData === 'dark' ? 'dark' : 'light');
        }
    }
</script>
<script data-cfasync="false">
    
    function browserDetection(ua) {
        if (ua.indexOf('MSIE ') > 0 || ua.indexOf('Trident/') > 0) {
            return true;
        }
        return false;
    }

    var ua = window.navigator.userAgent;
    if (browserDetection(ua)) {
        window.location.href('https:\/\/keichw.github.io\/ie\/');
    }
</script>
    <header>
    <div class="container-lg clearfix">
        <div class="col-12 header">
            <a class="title-main" href="https://keichw.github.io">Kinopio BLOG</a>
            
            <span class="title-sub">(ง •̀_•́)ง</span>
            
        </div>
    </div>
</header>

    <main>
        <div class="container-lg clearfix">
            
            <div class="col-12 col-md-9 float-left content">
                
<article>
    
    <h2 class="post-item post-title">
        <a href="https://keichw.github.io/post/javaweb/">JavaWeb技术原理</a>
    </h2>
    <div class="post-item post-meta">
        <span><ion-icon name="today"></ion-icon>&nbsp;2020-07-06</span><span><ion-icon name="file-tray"></ion-icon>&nbsp;8380 字</span><span><ion-icon name="stopwatch"></ion-icon>&nbsp;17 分钟</span><span><ion-icon name="pricetags"></ion-icon>&nbsp;<a href="/tags/java">java</a>&nbsp;<a href="/tags/web">web</a>&nbsp;<a href="/tags/servlet">servlet</a>&nbsp;<a href="/tags/jdbc">jdbc</a>&nbsp;</span>
    </div>
    
    
    <div class="post-content markdown-body">
        <p>最近在重温JavaWeb的内容，特此记录一下。</p>
<h2 id="1-基本概念">1 基本概念</h2>
<h3 id="11-前言">1.1 前言</h3>
<p>web开发：</p>
<ul>
<li>静态web
<ul>
<li>html，css</li>
<li>提供给所有人看的数据始终不会变化</li>
</ul>
</li>
<li>动态web
<ul>
<li>几乎所有网站，淘宝</li>
<li>提供给所有人看的数据始终会发生变化，每个人在不同的时间、不同的地点看到的信息各不相同</li>
<li>servlet/jsp，asp，php</li>
</ul>
</li>
</ul>
<h3 id="12-web应用程序">1.2 web应用程序</h3>
<p>可以提供浏览器访问的程序</p>
<ul>
<li>a.html、b.html等多个web资源，这些web资源可以被外界访问，对外界提供服务</li>
<li>能访问到的任何一个页面或者资源，都存在于世界某个地方的计算机上</li>
<li>url</li>
<li>统一的web资源会被放在同一个文件夹下，web应用程序—&gt;Tomcat服务器</li>
<li>一个web应用有多个部分组成（静态web、动态web）
<ul>
<li>html，css，js</li>
<li>jsp，servlet</li>
<li>Java程序</li>
<li>jar包</li>
<li>配置文件（properties，xml）</li>
</ul>
</li>
<li>web应用程序编写完后，若想要提供给外部访问，需要一个服务器来统一管理</li>
</ul>
<h3 id="13-静态web">1.3 静态web</h3>
<ul>
<li>
<p>*.html，*.html这些都是网站的资源，如果服务器上一直存在这些资源，我们就可以直接进行读取，需要网络</p>
<p><a href="/img/javaweb/%e9%9d%99%e6%80%81web.png" target="_blank">
    <img src="/img/javaweb/%e9%9d%99%e6%80%81web.png" alt="" />
</a></p>
</li>
<li>
<p>静态web的缺点</p>
<ul>
<li>web页面无法动态更新，所有用户看到的都是一个页面
<ul>
<li>轮播图，点击特效：伪动态</li>
<li>JavaScript</li>
</ul>
</li>
<li>无法和数据库交互（数据无法持久化，用户无法交互）</li>
</ul>
</li>
</ul>
<h3 id="14-动态web">1.4 动态web</h3>
<ul>
<li>页面会动态展示，web页面的展示效果因人而异</li>
</ul>
<p><a href="/img/javaweb/%e5%8a%a8%e6%80%81web.png" target="_blank">
    <img src="/img/javaweb/%e5%8a%a8%e6%80%81web.png" alt="" />
</a></p>
<ul>
<li>
<p>动态web的缺点</p>
<ul>
<li>如果服务器的动态web资源出现了错误，需要重新编写后台程序，重新发布</li>
<li>停机维护</li>
</ul>
</li>
<li>
<p>动态web的优点</p>
<ul>
<li>
<p>web页面可以动态更新，所有用户看到的不是同一个页面</p>
</li>
<li>
<p>可以与数据库交互</p>
<p><a href="/img/javaweb/%e5%8a%a8%e6%80%81web2.png" target="_blank">
    <img src="/img/javaweb/%e5%8a%a8%e6%80%81web2.png" alt="" />
</a></p>
</li>
</ul>
</li>
</ul>
<h2 id="2-web服务器">2 Web服务器</h2>
<h3 id="21-技术讲解">2.1 技术讲解</h3>
<h4 id="asp">ASP</h4>
<ul>
<li>微软：国内最早流行的就是ASP</li>
<li>在html中嵌入了VB的脚本，ASP+COM</li>
<li>在ASP开发中，基本一个页面有几千行的业务代码，页面混乱</li>
<li>维护成本高</li>
<li>C#</li>
<li>IIS</li>
</ul>
<h4 id="php">PHP</h4>
<ul>
<li>php开发速度很快，功能强大，跨平台，代码简单</li>
<li>无法承载大访问量的情况</li>
</ul>
<h4 id="servletjsp">servlet/jsp</h4>
<ul>
<li>sun公司主推的B/S架构</li>
<li>基于Java语言</li>
<li>可以承载三高问题带来的影响</li>
<li>语法像ASP</li>
</ul>
<h3 id="22-web服务器">2.2 web服务器</h3>
<p>服务器是一种被动的操作，用来处理用户的一些请求和给用户一些响应信息</p>
<ul>
<li>IIS，微软的</li>
<li>Tomcat</li>
</ul>
<h2 id="3-tomcat">3 Tomcat</h2>
<h3 id="31-安装tomcat">3.1 安装Tomcat</h3>
<h3 id="32-tomcat启动">3.2 Tomcat启动</h3>
<h3 id="33-tomcat配置">3.3 Tomcat配置</h3>
<p>网站是如何进行访问的</p>
<ol>
<li>输入一个域名，回车</li>
<li>检查本机的hosts配置文件内是否存在域名映射
<ol>
<li>有：直接访问对应的ip地址，找到需要访问的web程序，可以直接访问</li>
<li>没有：去DNS服务器找对应的ip地址，找到则返回</li>
</ol>
</li>
</ol>
<h3 id="34-发布web网站">3.4 发布web网站</h3>
<ul>
<li>
<p>将自己写的网站，放到服务器（Tomcat）指定的web应用的文件夹（webapps）下，就可以访问了</p>
</li>
<li>
<p>网站应有的架构</p>
</li>
</ul>
<pre><code class="language-xml">--webapps ：Tomcat服务器的web目录
	-ROOT
	-testweb ：网站的目录名
		- WEB-INF
			-classes : java程序
			-lib：web应用所依赖的jar包
			-web.xml ：网站配置文件
		- index.html 默认的首页
		- static 
            -css
            	-style.css
            -js
            -img
         -.....
</code></pre>
<h2 id="4-http">4 HTTP</h2>
<h3 id="41-什么是http">4.1 什么是HTTP</h3>
<p>超文本传输协议是一个简单的请求-响应协议，通常运行在TCP之上</p>
<ul>
<li>文本：html，字符串，……</li>
<li>超文本：图片，音乐，视频，定位，地图，……</li>
<li>端口：80</li>
</ul>
<p>HTTPS：安全的</p>
<h3 id="42-两个版本">4.2 两个版本</h3>
<ul>
<li>http 1.0
<ul>
<li>HTTP/1.0：客户端与web服务器连接后，只能获得一个web资源</li>
</ul>
</li>
<li>http 2.0
<ul>
<li>HTTP/2.0：客户端与web服务器连接后，可以获得多个web资源</li>
</ul>
</li>
</ul>
<h3 id="43-http请求">4.3 HTTP请求</h3>
<ul>
<li>客户端—request—服务器</li>
</ul>
<pre><code class="language-xml">Request URL:https://www.baidu.com/   请求地址
Request Method:GET    get方法/post方法
Status Code:200 OK    状态码：200
Remote（远程） Address:14.215.177.39:443

Accept:text/html  
Accept-Encoding:gzip, deflate, br
Accept-Language:zh-CN,zh;q=0.9    语言
Cache-Control:max-age=0
Connection:keep-alive
</code></pre>
<h4 id="请求行">请求行</h4>
<ul>
<li>请求行中的请求方式：GET</li>
<li>请求方式：GET，POST，HEAD，DELETE，PUT，TRACT，……
<ul>
<li>GET：请求能够携带的参数比较少，大小有限制，会在浏览器的URL地址栏显示数据内容，不安全，但高效</li>
<li>POST：请求能够携带的参数没有限制，大小没有限制，不会在浏览器的URL地址栏显示数据内容，安全，但不高效</li>
</ul>
</li>
</ul>
<h4 id="消息头">消息头</h4>
<pre><code class="language-xml">Accept:告诉浏览器支持的数据类型
Accept-Encoding:支持哪种编码格式 GBK	UTF-8	GB2312	ISO8859-1
Accept-Language:告诉浏览器语言环境
Cache-Control:缓存控制
Connection:告诉浏览器请求完成是断开还是保持连接
HOST：主机
</code></pre>
<h3 id="44-http响应">4.4 HTTP响应</h3>
<ul>
<li>服务器—response—客户端</li>
</ul>
<h4 id="响应体">响应体</h4>
<pre><code class="language-xml">Accept：告诉浏览器支持的数据类型
Accept-Encoding：支持哪种编码格式  GBK   UTF-8   GB2312  ISO8859-1
Accept-Language：告诉浏览器语言环境
Cache-Control：缓存控制
Connection：告诉浏览器请求完成是断开还是保持连接
HOST：主机
Refresh：告诉客户端，多久刷新一次
Location：让网页重新定位
</code></pre>
<h4 id="响应状态码">响应状态码</h4>
<ul>
<li>200：请求响应成功</li>
<li>3xx：请求重定向</li>
<li>4xx：找不到资源404</li>
<li>5xx：服务器代码错误500，502：网关错误</li>
</ul>
<h2 id="5-maven">5 Maven</h2>
<p>在JavaWeb开发中，需要使用大量的jar包，手动导入很繁琐，如何自动导入和配置jar包</p>
<h3 id="51-项目架构管理工具">5.1 项目架构管理工具</h3>
<p>Maven的核心思想：约定大于配置。Maven会规定如何编写Java代码</p>
<h3 id="52-下载安装maven">5.2 下载安装Maven</h3>
<h3 id="53-配置环境变量">5.3 配置环境变量</h3>
<h3 id="54-配置阿里云镜像">5.4 配置阿里云镜像</h3>
<h2 id="6-servlet">6 Servlet</h2>
<h3 id="61-servlet简介">6.1 Servlet简介</h3>
<ul>
<li>Servlet是sun公司开发动态web的一门技术</li>
<li>sun在这些api中提供一个接口叫做Servlet，如果想开发一个Servlet程序，只需要
<ul>
<li>编写一个类，实现Servlet接口</li>
<li>把开发好的Java类部署到服务器中</li>
</ul>
</li>
<li>把实现了Servlet接口的Java程序叫做Servlet</li>
</ul>
<h3 id="62-helloservlet">6.2 HelloServlet</h3>
<ol>
<li>
<p>构建一个普通的Maven项目</p>
</li>
<li>
<p>编写一个Serlvet程序</p>
<ol>
<li>编写一个普通类</li>
<li>实现Servlet接口，这里直接继承HttpServlet</li>
</ol>
</li>
</ol>
<pre><code class="language-java">public class HelloServlet extends HttpServlet {
	//由于get或者post只是请求实现的不同的方式，可以相互调用，业务逻辑都一样；
	@Override
	protected void doGet(HttpServletRequest req, HttpServletResponse resp)
    throws ServletException, IOException {
	//ServletOutputStream outputStream = resp.getOutputStream();
		PrintWriter writer = resp.getWriter(); //响应流
		writer.print(&quot;Hello,Serlvet&quot;);
	}
        
	@Override
	protected void doPost(HttpServletRequest req, HttpServletResponse resp)
    throws ServletException, IOException {
		doGet(req, resp);
	}
}
</code></pre>
<ol start="3">
<li>
<p>编写Servlet的映射</p>
<p>为什么需要映射，我们写的是Java程序，但是要通过浏览器访问，而浏览器需要连接web服务器，所以我们需要在web服务中注册我们写的Servlet，还需要定义一个浏览器能够访问的路径</p>
</li>
</ol>
<pre><code class="language-xml">&lt;!--注册Servlet--&gt;
&lt;servlet&gt;
	&lt;servlet-name&gt;hello&lt;/servlet-name&gt;
	&lt;servlet-class&gt;com.hjc.servlet.HelloServlet&lt;/servlet-class&gt;
&lt;/servlet&gt;
&lt;!--Servlet的请求路径--&gt;
&lt;servlet-mapping&gt;
	&lt;servlet-name&gt;hello&lt;/servlet-name&gt;
	&lt;url-pattern&gt;/hello&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre>
<ol start="4">
<li>
<p>配置Tomcat</p>
</li>
<li>
<p>启动测试</p>
</li>
</ol>
<h3 id="63-servlet原理">6.3 Servlet原理</h3>
<p>Servlet是由web服务器在收到浏览器请求后调用</p>
<p><a href="/img/javaweb/Servlet.png" target="_blank">
    <img src="/img/javaweb/Servlet.png" alt="" />
</a></p>
<h3 id="64-mapping问题">6.4 Mapping问题</h3>
<ol>
<li>一个servlet可以指定一个映射路径</li>
</ol>
<pre><code class="language-xml">&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;hello&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/hello&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre>
<ol start="2">
<li>一个servlet可以指定多个映射路径</li>
</ol>
<pre><code class="language-xml">&lt;servlet-mapping&gt;
	&lt;servlet-name&gt;hello&lt;/servlet-name&gt;
	&lt;url-pattern&gt;/hello&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
&lt;servlet-mapping&gt;
	&lt;servlet-name&gt;hello&lt;/servlet-name&gt;
	&lt;url-pattern&gt;/hello2&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
&lt;servlet-mapping&gt;
	&lt;servlet-name&gt;hello&lt;/servlet-name&gt;
	&lt;url-pattern&gt;/hello3&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
&lt;servlet-mapping&gt;
	&lt;servlet-name&gt;hello&lt;/servlet-name&gt;
	&lt;url-pattern&gt;/hello4&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
&lt;servlet-mapping&gt;
	&lt;servlet-name&gt;hello&lt;/servlet-name&gt;
	&lt;url-pattern&gt;/hello5&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre>
<ol start="3">
<li>一个servlet可以指定通用映射路径</li>
</ol>
<pre><code class="language-xml">&lt;servlet-mapping&gt;
	&lt;servlet-name&gt;hello&lt;/servlet-name&gt;
	&lt;url-pattern&gt;/hello/*&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre>
<ol start="4">
<li>默认请求路径</li>
</ol>
<pre><code class="language-xml">&lt;!--默认请求路径--&gt;
&lt;servlet-mapping&gt;
	&lt;servlet-name&gt;hello&lt;/servlet-name&gt;
	&lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre>
<ol start="5">
<li>指定一些后缀或者前缀</li>
</ol>
<pre><code class="language-xml">&lt;!--可以自定义后缀实现请求映射
    注意点，*前面不能加项目映射的路径
    hello/sajdlkajda.do
    --&gt;
&lt;servlet-mapping&gt;
	&lt;servlet-name&gt;hello&lt;/servlet-name&gt;
	&lt;url-pattern&gt;*.do&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre>
<ol start="6">
<li>优先级问题</li>
</ol>
<p>指定了固有的映射路径优先级最高，如果找不到就会走默认的处理请求</p>
<pre><code class="language-xml">&lt;!--404--&gt;
&lt;servlet&gt;
	&lt;servlet-name&gt;error&lt;/servlet-name&gt;
	&lt;servlet-class&gt;com.hjc.servlet.ErrorServlet&lt;/servlet-class&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
	&lt;servlet-name&gt;error&lt;/servlet-name&gt;
	&lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre>
<h3 id="65-servletcontext">6.5 ServletContext</h3>
<p>web容器在启动的时候，它会为每个web程序都创建一个对应的ServletContext对象，代表当前的web应用</p>
<h4 id="1-共享数据">1. 共享数据</h4>
<p>在一个servlet中保存的数据，可以在另一个servlet中得到</p>
<pre><code class="language-java">public class HelloServlet extends HttpServlet {
	@Override
	protected void doGet(HttpServletRequest req, HttpServletResponse resp)
        throws ServletException, IOException {
    	//this.getInitParameter()   初始化参数
        //this.getServletConfig()   Servlet配置
        //this.getServletContext()  Servlet上下文
        ServletContext context = this.getServletContext();
        String username = &quot;hjc&quot;; //数据
        context.setAttribute(&quot;username&quot;,username); 
        //将一个数据保存在了ServletContext中，名字为username，值为username
    }
}
</code></pre>
<pre><code class="language-java">public class GetServlet extends HttpServlet {
	@Override
	protected void doGet(HttpServletRequest req, HttpServletResponse resp)
        throws ServletException, IOException {
        ServletContext context = this.getServletContext();
        String username = (String) context.getAttribute(&quot;username&quot;);
        resp.setContentType(&quot;text/html&quot;);
        resp.setCharacterEncoding(&quot;utf-8&quot;);
        resp.getWriter().print(&quot;名字&quot;+username);
    }
}
</code></pre>
<pre><code class="language-xml">&lt;servlet&gt;
	&lt;servlet-name&gt;hello&lt;/servlet-name&gt;
	&lt;servlet-class&gt;com.hjc.servlet.HelloServlet&lt;/servlet-class&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
	&lt;servlet-name&gt;hello&lt;/servlet-name&gt;
	&lt;url-pattern&gt;/hello&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;

&lt;servlet&gt;
	&lt;servlet-name&gt;get&lt;/servlet-name&gt;
	&lt;servlet-class&gt;com.hjc.servlet.GetServlet&lt;/servlet-class&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
	&lt;servlet-name&gt;get&lt;/servlet-name&gt;
	&lt;url-pattern&gt;/get&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre>
<h4 id="2-获取初始化参数">2. 获取初始化参数</h4>
<pre><code class="language-xml">&lt;!--配置一些web应用初始化参数--&gt;
&lt;context-param&gt;
	&lt;param-name&gt;url&lt;/param-name&gt;
	&lt;param-value&gt;jdbc:mysql://localhost:3306/mybatis&lt;/param-value&gt;
&lt;/context-param&gt;
</code></pre>
<pre><code class="language-java">public class HelloServlet extends HttpServlet {
	@Override
	protected void doGet(HttpServletRequest req, HttpServletResponse resp)
        throws ServletException, IOException {
        ServletContext context = this.getServletContext();
        String url = context.getInitParameter(&quot;url&quot;);
        resp.getWriter().print(url);
    }
}
</code></pre>
<h4 id="3-请求转发">3. 请求转发</h4>
<pre><code class="language-java">public class HelloServlet extends HttpServlet {
	@Override
	protected void doGet(HttpServletRequest req, HttpServletResponse resp)
        throws ServletException, IOException {
        ServletContext context = this.getServletContext();
        context.getRequestDispatcher(&quot;/gp&quot;).forward(req, resp);	// gp为转发路径
    }
}
</code></pre>
<h4 id="4-读取资源文件">4. 读取资源文件</h4>
<p>Properties</p>
<ul>
<li>在java目录下新建properties</li>
<li>在resources目录下新建properties</li>
</ul>
<pre><code class="language-properties">username=root
password=123456
</code></pre>
<pre><code class="language-java">public class ServletDemo extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp)
        throws ServletException, IOException {
        InputStream is = this.getServletContext()
            .getResourceAsStream(&quot;/WEB-INF/classes/com/hjc/servlet/test.properties&quot;);
        Properties prop = new Properties();
        prop.load(is);
        String user = prop.getProperty(&quot;username&quot;);
        String pwd = prop.getProperty(&quot;password&quot;);
        resp.getWriter().print(user+&quot;:&quot;+pwd);
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp)
        throws ServletException, IOException {
        doGet(req, resp);
    }
}
</code></pre>
<h3 id="66-httpservletresponse">6.6 HttpServletResponse</h3>
<ul>
<li>web服务器接收到客户端的http请求，针对这个请求，分别创建一个代表请求的HttpServletRequest对象和代表相应的HttpServletResponse对象</li>
<li>如果要获取客户端请求过来的参数，找HttpServletRequest</li>
<li>如果要给客户端响应一些信息，找HttpServletResponse</li>
</ul>
<h4 id="1-简单分类">1. 简单分类</h4>
<p>负责向浏览器发送数据的方法</p>
<pre><code class="language-java">servletOutputstream getOutputstream() throws IOException;
Printwriter getwriter() throws IOException;
</code></pre>
<p>负责向浏览器发送响应头的方法</p>
<pre><code class="language-java">void setCharacterEncoding(String var1)；
void setContentLength(int var1)；
void setContentLengthLong(long var1);
void setContentType(String var1)；
void setDateHeader(String varl,long var2)
void addDateHeader(String var1,long var2)
void setHeader(String var1,String var2);
void addHeader(String var1,String var2)；
void setIntHeader(String var1,int var2);
void addIntHeader(String varl,int var2);
</code></pre>
<h4 id="2-下载文件">2. 下载文件</h4>
<ol>
<li>向浏览器输出消息</li>
<li>下载文件
<ol>
<li>获取下载文件的路径</li>
<li>获取下载文件的文件名</li>
<li>设置让浏览器支持下载需要的东西</li>
<li>获取下载文件的输入流</li>
<li>创建缓冲区</li>
<li>获取OutputStream对象</li>
<li>将FileOutputStream流写入到buffer缓冲区</li>
<li>使用OutputStream将缓冲区内的数据输出到客户端</li>
</ol>
</li>
</ol>
<pre><code class="language-java">@Override
protected void doGet(HttpServletRequest req, HttpServletResponse resp)
    throws ServletException, IOException {
    // 1. 要获取下载文件的路径
    String realPath = path;	//路径
    System.out.println(&quot;下载文件的路径：&quot;+realPath);
    // 2. 下载的文件名是啥？
    String fileName = realPath.substring(realPath.lastIndexOf(&quot;\\&quot;) + 1);
    // 3. 设置想办法让浏览器能够支持(Content-Disposition)下载我们需要的东西,中文文件名URLEncoder.encode编码，否则有可能乱码
    resp.setHeader(&quot;Content-Disposition&quot;,&quot;attachment;filename=&quot;+URLEncoder.encode(fileName,&quot;UTF-8&quot;));
    // 4. 获取下载文件的输入流
    FileInputStream in = new FileInputStream(realPath);
    // 5. 创建缓冲区
    int len = 0;
    byte[] buffer = new byte[1024];
    // 6. 获取OutputStream对象
    ServletOutputStream out = resp.getOutputStream();
    // 7. 将FileOutputStream流写入到buffer缓冲区,使用OutputStream将缓冲区中的数据输出到客户端！
    while ((len=in.read(buffer))&gt;0){
        out.write(buffer,0,len);
    }

    in.close();
    out.close();
}
</code></pre>
<h4 id="3-验证码功能">3. 验证码功能</h4>
<p>验证码实现</p>
<ul>
<li>前端实现</li>
<li>后端实现，需要用到Java的图片类，生产一个图片</li>
</ul>
<pre><code class="language-java">public class ImageServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp)
        throws ServletException, IOException {

        //如何让浏览器3秒自动刷新一次;
        resp.setHeader(&quot;refresh&quot;,&quot;3&quot;);
        
        //在内存中创建一个图片
        BufferedImage image = new BufferedImage(80,20,BufferedImage.TYPE_INT_RGB);
        //得到图片
        Graphics2D g = (Graphics2D) image.getGraphics(); //笔
        //设置图片的背景颜色
        g.setColor(Color.white);
        g.fillRect(0,0,80,20);
        //给图片写数据
        g.setColor(Color.BLUE);
        g.setFont(new Font(null,Font.BOLD,20));
        g.drawString(makeNum(),0,20);

        //告诉浏览器，这个请求用图片的方式打开
        resp.setContentType(&quot;image/jpeg&quot;);
        //网站存在缓存，不让浏览器缓存
        resp.setDateHeader(&quot;expires&quot;,-1);
        resp.setHeader(&quot;Cache-Control&quot;,&quot;no-cache&quot;);
        resp.setHeader(&quot;Pragma&quot;,&quot;no-cache&quot;);

        //把图片写给浏览器
        ImageIO.write(image,&quot;jpg&quot;, resp.getOutputStream());

    }

    //生成随机数
    private String makeNum(){
        Random random = new Random();
        String num = random.nextInt(9999999) + &quot;&quot;;
        StringBuffer sb = new StringBuffer();
        for (int i = 0; i &lt; 7-num.length() ; i++) {
            sb.append(&quot;0&quot;);
        }
        num = sb.toString() + num;
        return num;
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp)
        throws ServletException, IOException {
        doGet(req, resp);
    }
}
</code></pre>
<pre><code class="language-xml">&lt;servlet&gt;
	&lt;servlet-name&gt;ImageServlet&lt;/servlet-name&gt;
	&lt;servlet-class&gt;com.hjc.servlet.ImageServlet&lt;/servlet-class&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
	&lt;servlet-name&gt;ImageServlet&lt;/servlet-name&gt;
	&lt;url-pattern&gt;/img&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre>
<h4 id="4-实现重定向">4. 实现重定向</h4>
<pre><code class="language-java">void sendRedirect(String var1) throws IOException;
</code></pre>
<p>常见场景</p>
<ul>
<li>用户登录</li>
</ul>
<pre><code class="language-java">@Override
protected void doGet(HttpservletRequest req, HttpservletResponse resp)
    throws ServletException, IOException {

    resp.sendRedirect(&quot;/r/img&quot;);//重定向
    /*
    resp.setHeader(&quot;Location&quot;,&quot;/r/img&quot;);
    resp.setstatus(302);
    */
}
</code></pre>
<p>测试</p>
<p>index.jsp</p>
<pre><code class="language-jsp">&lt;html&gt;
	&lt;body&gt;
		&lt;h2&gt;Hel1o World!&lt;/h2&gt;
		
		&lt;%--这里超交的路径,需要寻找到项目的路径--%&gt;
		&lt;%--${pageContext.request.contextPath}代表当前的项目--%&gt;
		&lt;form action=&quot;${pageContext.request.contextPath}/login&quot; method=&quot;get&quot;&gt;
			用户名: &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; &lt;br&gt;
			密码: &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt; &lt;br&gt;
			&lt;input type=&quot;submit&quot;&gt;
		&lt;/form&gt;
	
	&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>RequestTest.java</p>
<pre><code class="language-java">public class RequestTest extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp)
        throws ServletException, IOException {
    //处理方求
    String username = req.getParameter(&quot;username&quot;);
    String password  rea.getParameter(&quot;password&quot;);

    System.out.println(username+&quot;:&quot;+password);

    resp.sendRedirect(&quot;/r/success.jsp&quot;);
}
</code></pre>
<p>success.jsp</p>
<pre><code class="language-jsp">&lt;%@ page contentType=&quot;text/html; charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
    &lt;head&gt;
	    &lt;title&gt;Title&lt;/title&gt;
	    &lt;/head&gt;
    &lt;body&gt;
    	&lt;h1&gt;success&lt;/h1&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>web.xml配置</p>
<pre><code class="language-xml">&lt;servlet&gt;
	&lt;servlet-name&gt;requset&lt;/servlet-name&gt;
    &lt;servlet-class&gt;com.hjc.servlet.RequestTest&lt;/servlet-class&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;requset&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/login&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre>
<h3 id="67-httpservletrequest">6.7 HttpServletRequest</h3>
<p>HttpServletRequest代表客户端的请求，用户通过Http协议访问服务器，Http请求中的所有信息都会被封装到HttpServletRequest，通过这个HttpServletRequest的方法获得客户端的所有信息</p>
<h4 id="1-获取参数">1. 获取参数</h4>
<h4 id="2-请求转发">2. 请求转发</h4>
<pre><code class="language-java">@Override
protected void doGet(HttpservletRequest req. HttpservletResponse resp)
    throws ServletException, IOException {

	req.setcharacterEncoding(&quot;utf-8&quot;);
	resp.setcharacterEncoding(&quot;utf-8&quot;);
	String username = req.getParameter(&quot;username&quot;);
	String password = req.getParameter(&quot;password&quot;);
	String[] hobbies = req.getParameterValues(&quot;hobbys&quot;);
	System.out.println(&quot;==========&quot;);
	//后台接收中文乱码问题
	System.out.println(username);
	System.out.println(password);
	System.out.println(Arrays.tostring(hobbys));
	System.out.println(&quot;============&quot;);
	system.out.println(req.getContextPath());
	//通过请求转发
	//这里的/代表当前的web应用
	req.getRequestDispatcher(&quot;/success.jsp&quot;).forward(req,resp);
}
</code></pre>
<h5 id="重定向和和请求转发的区别">重定向和和请求转发的区别</h5>
<ul>
<li>相同点
<ul>
<li>页面都会实现跳转</li>
</ul>
</li>
<li>不同点
<ul>
<li>请求转发的时候，url不会发生变化，是同一个请求</li>
<li>重定向的时候，url会发生变化，是不同请求</li>
</ul>
</li>
</ul>
<p><a href="/img/javaweb/%e9%87%8d%e5%ae%9a%e5%90%91%e4%b8%8e%e8%af%b7%e6%b1%82%e8%bd%ac%e5%8f%91.png" target="_blank">
    <img src="/img/javaweb/%e9%87%8d%e5%ae%9a%e5%90%91%e4%b8%8e%e8%af%b7%e6%b1%82%e8%bd%ac%e5%8f%91.png" alt="" />
</a></p>
<h2 id="7-cookiesession">7 Cookie、Session</h2>
<h3 id="71-会话">7.1 会话</h3>
<p>会话：用户打开一个浏览器，点击多个超链接，访问多个web资源，关闭浏览器，这个过程可以称为会话</p>
<p>有状态会话：一个同学来过教室，下次再来教室，我们会知道这个同学，曾经来过，称为有状态会话</p>
<h3 id="72-保存会话的两种技术">7.2 保存会话的两种技术</h3>
<p>那么，一个网站，如何证明访问过</p>
<ul>
<li>客户端 cookie
<ul>
<li>服务端给客户端一个信件，客户端下次访问服务器带上信件就可以了</li>
</ul>
</li>
<li>服务端 session
<ul>
<li>服务器登记访问过，下次访问的时候匹配登记信息</li>
</ul>
</li>
</ul>
<p>常见情况：网站登录后，下次访问不用再次登录</p>
<h3 id="73-cookie">7.3 Cookie</h3>
<ol>
<li>从请求中拿到cookie信息</li>
<li>服务器响应给客户端cookie</li>
</ol>
<pre><code class="language-java">Cookie[] cookies = req.getCookies(); //获得Cookie
cookie.getName(); //获得cookie中的key
cookie.getValue(); //获得cookie中的vlaue
new Cookie(&quot;lastLoginTime&quot;, System.currentTimeMillis()+&quot;&quot;); //新建一个cookie
cookie.setMaxAge(24*60*60); //设置cookie的有效期
resp.addCookie(cookie); //响应给客户端一个cookie
</code></pre>
<p>cookie一般会保存在本地的用户目录下appdata</p>
<p>一个网站的cookie存在上限</p>
<ul>
<li>一个cookie只能保存一个信息</li>
<li>一个web站点可以给浏览器发送多个cookie，最多存放20个</li>
<li>cookie大小有限制 4kb</li>
<li>浏览器有cookie上限 300个</li>
</ul>
<ol start="3">
<li>删除cookie
<ul>
<li>自动删除
<ul>
<li>不设置有效期，关闭浏览器，自动失效</li>
<li>设置有效时间为0</li>
</ul>
</li>
<li>手动删除</li>
</ul>
</li>
</ol>
<h3 id="74-session重要">7.4 Session（重要）</h3>
<ul>
<li>服务器会给每个用户（浏览器）创建一个Session对象</li>
<li>一个Session独占一个浏览器，只要浏览器没有关闭，这个Session就存在</li>
<li>用户登录后，整个网站都可以访问
<ul>
<li>保存用户信息</li>
<li>保存购物车信息</li>
</ul>
</li>
</ul>
<p>Session和Cookie的区别</p>
<ul>
<li>Cookie是把用户的数据写给用户的浏览器，浏览器保存</li>
<li>Session是把用户的数据写到用户独占的Session中，服务器保存</li>
</ul>
<h4 id="使用session">使用Session</h4>
<pre><code class="language-java">public class SessionDemo extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp)
        throws ServletException, IOException {
        
        //解决乱码问题
        req.setCharacterEncoding(&quot;UTF-8&quot;);
        resp.setCharacterEncoding(&quot;UTF-8&quot;);
        resp.setContentType(&quot;text/html;charset=utf-8&quot;);
        
        //得到Session
        HttpSession session = req.getSession();
        //给Session中存东西
        session.setAttribute(&quot;name&quot;,new Person(&quot;admin&quot;,1));
        //获取Session的ID
        String sessionId = session.getId();

        //判断Session是不是新创建
        if (session.isNew()){
            resp.getWriter().write(&quot;session创建成功,ID:&quot;+sessionId);
        }else {
            resp.getWriter().write(&quot;session以及在服务器中存在了,ID:&quot;+sessionId);
        }

        //Session创建的时候做了什么事情；
		//Cookie cookie = new Cookie(&quot;JSESSIONID&quot;,sessionId);
		//resp.addCookie(cookie);
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp)
        throws ServletException, IOException {
        doGet(req, resp);
    }
}
</code></pre>
<h4 id="得到session">得到Session</h4>
<pre><code class="language-java">//得到Session
HttpSession session = req.getSession();

Person person = (Person) session.getAttribute(&quot;name&quot;);

System.out.println(person.toString());
</code></pre>
<h4 id="注销session">注销Session</h4>
<ul>
<li>手动注销</li>
</ul>
<pre><code class="language-java">HttpSession session = req.getSession();
session.removeAttribute(&quot;name&quot;);
//手动注销Session
session.invalidate();
</code></pre>
<ul>
<li>自动注销（会话自动过期）</li>
</ul>
<pre><code class="language-xml">&lt;!--设置Session默认的失效时间--&gt;
&lt;session-config&gt;
    &lt;!--15分钟后Session自动失效，以分钟为单位--&gt;
    &lt;session-timeout&gt;15&lt;/session-timeout&gt;
&lt;/session-config&gt;
</code></pre>
<h2 id="8-jsp不重要">8 JSP（不重要）</h2>
<h3 id="81-什么是jsp">8.1 什么是JSP</h3>
<p>Java Server Pages：Java服务器端页面，和Servlet一样，用于动态Web技术</p>
<p>最大的特点</p>
<ul>
<li>写JSP就像在写HTML</li>
<li>区别
<ul>
<li>HTML只给用户提供静态的数据</li>
<li>JSP页面中可以嵌入Java代码，为用户提供动态数据</li>
</ul>
</li>
</ul>
<h3 id="82-jsp原理">8.2 JSP原理</h3>
<p>JSP本质上就是一个Servlet，浏览器向服务器发送请求，不管访问什么资源，其实都是在访问Servlet</p>
<pre><code class="language-java">//初始化
  public void _jspInit() {}
//销毁
  public void _jspDestroy() {}
//JSPService
  public void _jspService(HttpServletRequest request, HttpServletResponse response) {}
</code></pre>
<h3 id="略">略</h3>
<h2 id="9-javabean">9 JavaBean</h2>
<p>实体类</p>
<p>JavaBean有特定的写法</p>
<ul>
<li>必须要有一个无参构造函数</li>
<li>属性必须私有化</li>
<li>必须有对应的get/set方法</li>
</ul>
<p>一般用来和数据库的字段做映射 ORM</p>
<ul>
<li>ORM：对象关系映射
<ul>
<li>表 —&gt; 类</li>
<li>字段 —&gt; 属性</li>
<li>行记录 —&gt; 对象</li>
</ul>
</li>
</ul>
<h2 id="10-mvc三层架构">10 MVC三层架构</h2>
<p>MVC：Model、View、Controller 模型、视图、控制器</p>
<h3 id="101-以前的架构">10.1 以前的架构</h3>
<p><a href="/img/javaweb/%e4%bb%a5%e5%89%8d%e7%9a%84%e6%9e%b6%e6%9e%84.png" target="_blank">
    <img src="/img/javaweb/%e4%bb%a5%e5%89%8d%e7%9a%84%e6%9e%b6%e6%9e%84.png" alt="" />
</a></p>
<p>用户直接访问控制层，控制层就可以直接操作数据库</p>
<pre><code class="language-xml">servlet--CRUD--&gt;数据库
弊端：程序十分臃肿，不利于维护  
servlet的代码中：处理请求、响应、视图跳转、处理JDBC、处理业务代码、处理逻辑代码

架构：没有什么是加一层解决不了的！
程序猿调用
↑
JDBC （实现该接口）
↑
Mysql/Oracle/SqlServer ....（不同厂商）
</code></pre>
<h3 id="102-mvc三层架构">10.2 MVC三层架构</h3>
<p><a href="/img/javaweb/MVC.png" target="_blank">
    <img src="/img/javaweb/MVC.png" alt="" />
</a></p>
<p>Model</p>
<ul>
<li>业务处理：实现业务逻辑（Service）</li>
<li>数据持久层：CRUD（Dao - 数据持久化对象）</li>
</ul>
<p>View</p>
<ul>
<li>展示数据</li>
<li>提供链接发起Servlet请求（a、form、img …）</li>
</ul>
<p>Controller（Servlet）</p>
<ul>
<li>接收用户的请求（req：请求参数、Session信息）</li>
<li>交给业务层处理对应的代码</li>
<li>控制视图的跳转</li>
</ul>
<pre><code class="language-xml">登录 ---&gt; 接收用户的登录请求 ---&gt; 处理用户的请求（获取用户登录的参数，username，password）
    ---&gt; 交给业务层处理登录业务（判断用户名密码是否正确：事务）
    ---&gt; Dao层查询用户名和密码是否正确 ---&gt; 数据库
</code></pre>
<h2 id="11-filter重要">11 Filter（重要）</h2>
<p>过滤器，用来过滤网站的数据</p>
<ul>
<li>处理中文乱码</li>
<li>登陆验证</li>
</ul>
<p><a href="/img/javaweb/%e8%bf%87%e6%bb%a4%e5%99%a8.png" target="_blank">
    <img src="/img/javaweb/%e8%bf%87%e6%bb%a4%e5%99%a8.png" alt="" />
</a></p>
<p>Filter开发步骤</p>
<ol>
<li>
<p>导包</p>
</li>
<li>
<p>编写过滤器</p>
<ol>
<li>实现Filter接口，重写对应方法</li>
</ol>
<pre><code class="language-java">public class CharacterEncodingFilter implements Filter {
 //初始化：web服务器启动，就以及初始化了，随时等待过滤对象出现！
 public void init(FilterConfig filterConfig) throws ServletException {
         System.out.println(&quot;CharacterEncodingFilter初始化&quot;);
 }
       
 //Chain : 链
 /*
 1. 过滤中的所有代码，在过滤特定请求的时候都会执行
 2. 必须要让过滤器继续同行
        chain.doFilter(request,response);
 */
 public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
        throws IOException, ServletException {
     request.setCharacterEncoding(&quot;utf-8&quot;);
     response.setCharacterEncoding(&quot;utf-8&quot;);
     response.setContentType(&quot;text/html;charset=UTF-8&quot;);
     
     System.out.println(&quot;CharacterEncodingFilter执行前....&quot;);
     chain.doFilter(request,response); //让请求继续走，如果不写，程序到这里就被拦截停止！
     System.out.println(&quot;CharacterEncodingFilter执行后....&quot;);
 }
     
 //销毁：web服务器关闭的时候，过滤器会销毁
 public void destroy() {
     System.out.println(&quot;CharacterEncodingFilter销毁&quot;);
 }
}
</code></pre>
<ol start="3">
<li>在web.xml中配置Filter</li>
</ol>
<pre><code class="language-xml">&lt;filter&gt;
    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;com.hjc.filter.CharacterEncodingFilter&lt;/filter-class&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;
    &lt;!--只要是 /servlet的任何请求，会经过这个过滤器--&gt;
    &lt;url-pattern&gt;/servlet/*&lt;/url-pattern&gt;
    &lt;!--&lt;url-pattern&gt;/*&lt;/url-pattern&gt;--&gt;
    &lt;!-- 别偷懒写个 /* --&gt;
&lt;/filter-mapping&gt;
</code></pre>
</li>
</ol>
<h2 id="12-监听器">12 监听器</h2>
<p>实现一个监听器的接口（有n种监听器）</p>
<ol>
<li>
<p>编写一个监听器</p>
<ol>
<li>实现监听器的接口</li>
</ol>
<pre><code class="language-java">//统计网站在线人数 ： 统计session
public class OnlineCountListener implements HttpSessionListener {
     
//创建session监听： 看你的一举一动
//一旦创建Session就会触发一次这个事件！
public void sessionCreated(HttpSessionEvent se) {
    ServletContext ctx = se.getSession().getServletContext();
     
    System.out.println(se.getSession().getId());
     
    Integer onlineCount = (Integer) ctx.getAttribute(&quot;OnlineCount&quot;);
     
    if (onlineCount==null){
        onlineCount = new Integer(1);
    }else {
        int count = onlineCount.intValue();
        onlineCount = new Integer(count+1);
    }
  
    ctx.setAttribute(&quot;OnlineCount&quot;,onlineCount);
}
     
//销毁session监听
//一旦销毁Session就会触发一次这个事件！
public void sessionDestroyed(HttpSessionEvent se) {
    ServletContext ctx = se.getSession().getServletContext();
     
    Integer onlineCount = (Integer) ctx.getAttribute(&quot;OnlineCount&quot;);
     
    if (onlineCount==null){
        onlineCount = new Integer(0);
    }else {
        int count = onlineCount.intValue();
        onlineCount = new Integer(count-1);
    }
     
    ctx.setAttribute(&quot;OnlineCount&quot;,onlineCount);
}
     
/*
Session销毁：
1. 手动销毁  getSession().invalidate();
2. 自动销毁
*/
}
</code></pre>
<p>`</p>
</li>
<li>
<p>在web.xml中注册监听器</p>
</li>
</ol>
<pre><code class="language-xml">&lt;!--注册监听器--&gt;
&lt;listener&gt;
	&lt;listener-class&gt;com.hjc.listener.OnlineCountListener&lt;/listener-class&gt;
&lt;/listener&gt;
</code></pre>
<h2 id="13-过滤器监听器常见应用">13 过滤器、监听器常见应用</h2>
<h3 id="131-监听器">13.1 监听器</h3>
<p>GUI编程中常用</p>
<pre><code class="language-java">public class TestPanel {
	public static void main(String[] args) {
		Frame frame = new Frame(&quot;Test&quot;);  //新建一个窗体
		Panel panel = new Panel(null); //面板
		frame.setLayout(null); //设置窗体的布局
   
		frame.setBounds(300,300,500,500);
		frame.setBackground(new Color(0,0,255)); //设置背景颜色
   
		panel.setBounds(50,50,300,300);
		panel.setBackground(new Color(0,255,0)); //设置背景颜色
   
		frame.add(panel);
   
		frame.setVisible(true);
   
		//监听事件，监听关闭事件
		frame.addWindowListener(new WindowAdapter() {
			@Override
			public void windowClosing(WindowEvent e) {
				super.windowClosing(e);
			}
		});
	}
}
</code></pre>
<h3 id="132-过滤器">13.2 过滤器</h3>
<p>用户登陆后才能进入主页，用户注销后就不能进入主页</p>
<ol>
<li>用户登录后，向Session中放入用户的数据</li>
<li>进入主页的时候要判断用户是否已经登陆，在过滤器中实现</li>
</ol>
<pre><code class="language-java">public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
    throws IOException, ServletException {
	
    HttpServletRequest request = (HttpServletRequest) req;
    HttpServletResponse response = (HttpServletResponse) resp;

    if (request.getSession().getAttribute(Constant.USER_SESSION)==null){
        response.sendRedirect(&quot;/error.jsp&quot;);
    }

    chain.doFilter(request,response);
}
</code></pre>
<h2 id="14-jdbc">14 JDBC</h2>
<p><a href="/img/javaweb/JDBC.png" target="_blank">
    <img src="/img/javaweb/JDBC.png" alt="" />
</a></p>
<h3 id="141-jdbc固定步骤">14.1 JDBC固定步骤</h3>
<ol>
<li>加载驱动</li>
<li>连接数据库</li>
<li>向数据库发送sql的对象Statement：CRUD</li>
<li>编写sql</li>
<li>执行sql</li>
<li>关闭连接（注意先后顺序）</li>
</ol>
<pre><code class="language-java">public class TestJDBC {
    public static void main(String[] args) throws ClassNotFoundException, SQLException {
        //配置信息
        //useUnicode=true&amp;characterEncoding=utf-8 解决中文乱码
        String url=&quot;jdbc:mysql://localhost:3306/jdbc?useUnicode=true&amp;characterEncoding=utf-8&quot;;
        String username = &quot;root&quot;;
        String password = &quot;123456&quot;;

        //1.加载驱动
        Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
        //2.连接数据库,代表数据库
        Connection connection = DriverManager.getConnection(url, username, password);

        //3.向数据库发送SQL的对象Statement,PreparedStatement : CRUD
        Statement statement = connection.createStatement();

        //4.编写SQL
        String sql = &quot;select * from users&quot;;

        //5.执行查询SQL，返回一个 ResultSet  ： 结果集
        ResultSet rs = statement.executeQuery(sql);

        while (rs.next()){
            System.out.println(&quot;id=&quot;+rs.getObject(&quot;id&quot;));
            System.out.println(&quot;name=&quot;+rs.getObject(&quot;name&quot;));
            System.out.println(&quot;password=&quot;+rs.getObject(&quot;password&quot;));
            System.out.println(&quot;email=&quot;+rs.getObject(&quot;email&quot;));
            System.out.println(&quot;birthday=&quot;+rs.getObject(&quot;birthday&quot;));
        }

        //6.关闭连接，释放资源（一定要做） 先开后关
        rs.close();
        statement.close();
        connection.close();
    }
}
</code></pre>
<p>预编译sql</p>
<pre><code class="language-java">public class TestJDBC2 {
    public static void main(String[] args) throws Exception {
        //配置信息
        //useUnicode=true&amp;characterEncoding=utf-8 解决中文乱码
        String url=&quot;jdbc:mysql://localhost:3306/jdbc?useUnicode=true&amp;characterEncoding=utf-8&quot;;
        String username = &quot;root&quot;;
        String password = &quot;123456&quot;;

        //1.加载驱动
        Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
        //2.连接数据库,代表数据库
        Connection connection = DriverManager.getConnection(url, username, password);

        //3.编写SQL
        String sql = &quot;insert into  users(id, name, password, email, birthday) values (?,?,?,?,?);&quot;;

        //4.预编译
        PreparedStatement preparedStatement = connection.prepareStatement(sql);

        preparedStatement.setInt(1,1);//给第一个占位符？的值赋值为1
        preparedStatement.setString(2,&quot;admin&quot;);//给第二个占位符？的值赋值为admin
        preparedStatement.setString(3,&quot;123456&quot;);//给第三个占位符？的值赋值为123456
        preparedStatement.setString(4,&quot;admin@gmail.com&quot;);//给第四个占位符？的值赋值为admin@gmail.com
        preparedStatement.setDate(5,new Date(new java.util.Date().getTime()));
        //给第五个占位符？的值赋值为new Date(new java.util.Date().getTime())

        //5.执行SQL
        int i = preparedStatement.executeUpdate();

        if (i&gt;0){
            System.out.println(&quot;插入成功@&quot;);
        }

        //6.关闭连接，释放资源（一定要做） 先开后关
        preparedStatement.close();
        connection.close();
    }
}
</code></pre>
<h3 id="142-事务">14.2 事务</h3>
<p>要么都成功，要么都失败，ACID原则：保证数据的安全</p>

    </div>
</article>


<div class="license markdown-body">
    <blockquote>
        <p>除特殊注明部分，本站内容采用 <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"
               target="_blank">CC BY-NC-SA 4.0</a> 进行许可。</p>
    </blockquote>
</div>



            </div>
            <aside class="col-12 col-md-3 float-left sidebar">
    
    
    
    <div class="sidebar-item sidebar-toc">
        <h3>目录</h3>
        <nav id="TableOfContents">
  <ul>
    <li><a href="#1-基本概念">1 基本概念</a>
      <ul>
        <li><a href="#11-前言">1.1 前言</a></li>
        <li><a href="#12-web应用程序">1.2 web应用程序</a></li>
        <li><a href="#13-静态web">1.3 静态web</a></li>
        <li><a href="#14-动态web">1.4 动态web</a></li>
      </ul>
    </li>
    <li><a href="#2-web服务器">2 Web服务器</a>
      <ul>
        <li><a href="#21-技术讲解">2.1 技术讲解</a></li>
        <li><a href="#22-web服务器">2.2 web服务器</a></li>
      </ul>
    </li>
    <li><a href="#3-tomcat">3 Tomcat</a>
      <ul>
        <li><a href="#31-安装tomcat">3.1 安装Tomcat</a></li>
        <li><a href="#32-tomcat启动">3.2 Tomcat启动</a></li>
        <li><a href="#33-tomcat配置">3.3 Tomcat配置</a></li>
        <li><a href="#34-发布web网站">3.4 发布web网站</a></li>
      </ul>
    </li>
    <li><a href="#4-http">4 HTTP</a>
      <ul>
        <li><a href="#41-什么是http">4.1 什么是HTTP</a></li>
        <li><a href="#42-两个版本">4.2 两个版本</a></li>
        <li><a href="#43-http请求">4.3 HTTP请求</a></li>
        <li><a href="#44-http响应">4.4 HTTP响应</a></li>
      </ul>
    </li>
    <li><a href="#5-maven">5 Maven</a>
      <ul>
        <li><a href="#51-项目架构管理工具">5.1 项目架构管理工具</a></li>
        <li><a href="#52-下载安装maven">5.2 下载安装Maven</a></li>
        <li><a href="#53-配置环境变量">5.3 配置环境变量</a></li>
        <li><a href="#54-配置阿里云镜像">5.4 配置阿里云镜像</a></li>
      </ul>
    </li>
    <li><a href="#6-servlet">6 Servlet</a>
      <ul>
        <li><a href="#61-servlet简介">6.1 Servlet简介</a></li>
        <li><a href="#62-helloservlet">6.2 HelloServlet</a></li>
        <li><a href="#63-servlet原理">6.3 Servlet原理</a></li>
        <li><a href="#64-mapping问题">6.4 Mapping问题</a></li>
        <li><a href="#65-servletcontext">6.5 ServletContext</a></li>
        <li><a href="#66-httpservletresponse">6.6 HttpServletResponse</a></li>
        <li><a href="#67-httpservletrequest">6.7 HttpServletRequest</a></li>
      </ul>
    </li>
    <li><a href="#7-cookiesession">7 Cookie、Session</a>
      <ul>
        <li><a href="#71-会话">7.1 会话</a></li>
        <li><a href="#72-保存会话的两种技术">7.2 保存会话的两种技术</a></li>
        <li><a href="#73-cookie">7.3 Cookie</a></li>
        <li><a href="#74-session重要">7.4 Session（重要）</a></li>
      </ul>
    </li>
    <li><a href="#8-jsp不重要">8 JSP（不重要）</a>
      <ul>
        <li><a href="#81-什么是jsp">8.1 什么是JSP</a></li>
        <li><a href="#82-jsp原理">8.2 JSP原理</a></li>
        <li><a href="#略">略</a></li>
      </ul>
    </li>
    <li><a href="#9-javabean">9 JavaBean</a></li>
    <li><a href="#10-mvc三层架构">10 MVC三层架构</a>
      <ul>
        <li><a href="#101-以前的架构">10.1 以前的架构</a></li>
        <li><a href="#102-mvc三层架构">10.2 MVC三层架构</a></li>
      </ul>
    </li>
    <li><a href="#11-filter重要">11 Filter（重要）</a></li>
    <li><a href="#12-监听器">12 监听器</a></li>
    <li><a href="#13-过滤器监听器常见应用">13 过滤器、监听器常见应用</a>
      <ul>
        <li><a href="#131-监听器">13.1 监听器</a></li>
        <li><a href="#132-过滤器">13.2 过滤器</a></li>
      </ul>
    </li>
    <li><a href="#14-jdbc">14 JDBC</a>
      <ul>
        <li><a href="#141-jdbc固定步骤">14.1 JDBC固定步骤</a></li>
        <li><a href="#142-事务">14.2 事务</a></li>
      </ul>
    </li>
  </ul>
</nav>
    </div>
    
    
    
    <div class="sidebar-item sidebar-pages">
        <h3>页面</h3>
        <ul>
            
            <li>
                <a href="/">Home</a>
            </li>
            
            <li>
                <a href="/archives/">Archives</a>
            </li>
            
            <li>
                <a href="/about/">About</a>
            </li>
            
            <li>
                <a href="/search/">Search</a>
            </li>
            
            <li>
                <a href="/index.xml">RSS</a>
            </li>
            
        </ul>
    </div>
    
    <div class="sidebar-item sidebar-tags">
        <h3>标签</h3>
        <div>
            
            <span>
                <a href="/tags/c&#43;&#43;/">c&#43;&#43;</a>
            </span>
            
            <span>
                <a href="/tags/css/">css</a>
            </span>
            
            <span>
                <a href="/tags/electron/">electron</a>
            </span>
            
            <span>
                <a href="/tags/java/">java</a>
            </span>
            
            <span>
                <a href="/tags/jdbc/">jdbc</a>
            </span>
            
            <span>
                <a href="/tags/mybatis/">mybatis</a>
            </span>
            
            <span>
                <a href="/tags/network/">network</a>
            </span>
            
            <span>
                <a href="/tags/nodejs/">nodejs</a>
            </span>
            
            <span>
                <a href="/tags/servlet/">servlet</a>
            </span>
            
            <span>
                <a href="/tags/spring/">spring</a>
            </span>
            
            <span>
                <a href="/tags/springmvc/">springmvc</a>
            </span>
            
            <span>
                <a href="/tags/web/">web</a>
            </span>
            
            <span>
                <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
            </span>
            
            <span>
                <a href="/tags/%E7%AE%97%E6%B3%95/">算法</a>
            </span>
            
        </div>
    </div>
    
    <div class="sidebar-item sidebar-links">
        <h3>链接</h3>
        <ul>
            
            <li>
                <a href="https://github.com/keichw" target="_blank"><span>GitHub</span></a>
            </li>
            
        </ul>
    </div>
    
</aside>
        </div>
        <div class="btn">
    <div class="btn-toggle-mode">
        <ion-icon name="contrast"></ion-icon>
    </div>
    <div class="btn-scroll-top">
        <ion-icon name="chevron-up"></ion-icon>
    </div>
</div>
    </main>

    <footer>
    <div class="container-lg clearfix">
        <div class="col-12 footer">
            <span>&copy; 2020 <a href="https://keichw.github.io">Kinopio</a> |
                基于 <a href="https://github.com/amzrk2/hugo-theme-fuji/"
                   target="_blank">Fuji-v2</a> & <a href="https://gohugo.io/"
                   target="_blank">Hugo</a> 构建</span>
        </div>
    </div>
</footer>
    
    <script async type="module" src="https://cdn.jsdelivr.net/npm/ionicons@5.0.1/dist/ionicons/ionicons.esm.js"></script>
<script async nomodule src="https://cdn.jsdelivr.net/npm/ionicons@5.0.1/dist/ionicons/ionicons.js"></script>

<script defer src="https://cdn.jsdelivr.net/npm/prismjs@1.20.0/components/prism-core.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/prismjs@1.20.0/plugins/autoloader/prism-autoloader.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/lazysizes@5.2.2/lazysizes.min.js"></script>

<script defer src="/assets/js/fuji.min.js"></script>

</body>

</html>