[{"content":"首先新建maven项目，导入相关的依赖，junit，mysql，c3p0，servlet，jsp，jstl，mybatis，mybatis-spring，spring-webmvc，spring-jdbc\n建立dao，service，controller，pojo，新建mybatis-config.xml，applicationContext.xml\nMyBatis层  新建数据库配置文件database.properties  jdbc.driver=com.mysql.cj.jdbc.Driver jdbc.url=jdbc:mysql://localhost:3306/ssm?useSSL=false\u0026amp;allowPublicKeyRetrieval=true\u0026amp;serverTimezone=UTC jdbc.username=root jdbc.password=123456  IDEA关联数据库 在mybatis-config.xml中配置  \u0026lt;!--让spring去配置数据源--\u0026gt; \u0026lt;typeAliases\u0026gt; \u0026lt;package name=\u0026quot;com.hjc.pojo\u0026quot;/\u0026gt; \u0026lt;/typeAliases\u0026gt;  编写实体类  public class User { private int userId; private String userName; private String address; //省略get/set，toString方法 }  编写UserMapper接口  public interface UserMapper { int addUser(User user); int deleteUserById(@param(\u0026quot;userId\u0026quot;) int id); int updateUser(User user); User findUserById(@param(\u0026quot;userId\u0026quot;) int id); List\u0026lt;User\u0026gt; findAllUser(); }  在resources文件夹下新建com/hjc/dao/UserMapper.xml，注意不是包路径，是文件夹路径  \u0026lt;mapper namespace=\u0026quot;com.hjc.dao.UserMapper\u0026quot;\u0026gt; \u0026lt;insert id=\u0026quot;addUser\u0026quot; parameterType=\u0026quot;User\u0026quot;\u0026gt; insert into user (userId, userName, address) values (userId, userName, address) \u0026lt;/insert\u0026gt; \u0026lt;delete id=\u0026quot;deleteUserById\u0026quot; parameterType=\u0026quot;int\u0026quot;\u0026gt; delete from user where userId = #{userId} \u0026lt;/delete\u0026gt; \u0026lt;update id=\u0026quot;updateUser\u0026quot; parameterType=\u0026quot;User\u0026quot;\u0026gt; update user set userName = #{userName}, address = #{address} where userId = #{userId} \u0026lt;/update\u0026gt; \u0026lt;select id=\u0026quot;findUserById\u0026quot; parameterType=\u0026quot;int\u0026quot; resultType=\u0026quot;User\u0026quot;\u0026gt; select * from user where userId = #{userId} \u0026lt;/select\u0026gt; \u0026lt;select id=\u0026quot;findAllUser\u0026quot; resultType=\u0026quot;User\u0026quot;\u0026gt; select * from user \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt;  在mybatis-config.xml中注册UserMapper  \u0026lt;mappers\u0026gt; \u0026lt;mapper resource=\u0026quot;com/hjc/dao/UserMapper.xml\u0026quot;/\u0026gt; \u0026lt;/mappers\u0026gt;  编写UserService接口  public interface UserService { int addUser(User user); int deleteUserById(int id); int updateUser(User user); User findUserById(int id); List\u0026lt;User\u0026gt; findAllUser(); }  编写UserService接口的实现类UserServiceImpl  public class UserServiceImpl { private UserMapper userMapper; public void setUserMapper(UserMapper userMapper) { this.userMapper = userMapper; } public int addUser(User user) { return userMapper.addUser(user); } public int deleteUserById(int id) { return userMapper.deleteUserById(id); } public int updateUser(User user) { return userMapper.updateUser(user); } public User findUserById(int id) { return userMapper.findUserById(id); } public List\u0026lt;User\u0026gt; findAllUser() { return userMapper.findAllUser(); } }  Spring层  新建spring-dao.xml注册dao层的类  \u0026lt;!--关联数据库配置文件--\u0026gt; \u0026lt;context:property-placeholder location=\u0026quot;classpath:database.properties\u0026quot;/\u0026gt; \u0026lt;!--配置连接池，使用c3p0，也可以使用Spring原生的连接池或其他连接池--\u0026gt; \u0026lt;bean id=\u0026quot;dataSource\u0026quot; class=\u0026quot;com.mchange.v2.c3p0.ComboPooledDataSource\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;driverClass\u0026quot; value=\u0026quot;${jdbc.driver}\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;jdbcUrl\u0026quot; value=\u0026quot;${jdbc.url}\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;user\u0026quot; value=\u0026quot;${jdbc.username}\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;password\u0026quot; value=\u0026quot;${jdbc.password}\u0026quot;/\u0026gt; \u0026lt;!--还可以配置连接池的其他属性--\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--注册sqlSessionFactory--\u0026gt; \u0026lt;bean id=\u0026quot;sqlSessionFactory\u0026quot; class=\u0026quot;org.mybatis.spring.SqlSessionFactoryBean\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;dataSource\u0026quot; ref=\u0026quot;dataSource\u0026quot;/\u0026gt; \u0026lt;!--绑定mybatis-config.xml--\u0026gt; \u0026lt;property name=\u0026quot;configLocation\u0026quot; value=\u0026quot;classpath:mybatis-config.xml\u0026quot;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--配置sqlSessionTemplate--\u0026gt; \u0026lt;bean id=\u0026quot;sqlSession\u0026quot; class=\u0026quot;org.mybatis.spring.SqlSessionTemplate\u0026quot;\u0026gt; \u0026lt;constructor-arg index=\u0026quot;0\u0026quot; ref=\u0026quot;sqlSessionFactory\u0026quot;/\u0026gt; \u0026lt;/bean\u0026gt;  编写UserMapper接口的实现类UserMapperImpl  public class UserMapperImpl implements UserMapper { private SqlSession sqlSession; public void setSqlSession(SqlSession sqlSession) { this.sqlSession = sqlSession; } public int addUser(User user) { return sqlSession.getMapper(UserMapper.class).addUser(user); } public int deleteUserById(int id) { return sqlSession.getMapper(UserMapper.class).deleteUserById(id); } public int updateUser(User user) { return sqlSession.getMapper(UserMapper.class).updateUser(user); } public User findUserById(int id) { return sqlSession.getMapper(UserMapper.class).findUserById(id); } public List\u0026lt;User\u0026gt; findAllUser() { return sqlSession.getMapper(UserMapper.class).findAllUser(); } }  在spring-dao.xml中配置实现类  \u0026lt;bean id=\u0026quot;userMapper\u0026quot; class=\u0026quot;com.hjc.dao.UserMapperImpl\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;sqlSession\u0026quot; ref=\u0026quot;sqlSession\u0026quot;/\u0026gt; \u0026lt;/bean\u0026gt;  新建spring-service.xml  \u0026lt;!--扫描service包--\u0026gt; \u0026lt;context:component-scan base-package=\u0026quot;com.hjc.service\u0026quot;/\u0026gt; \u0026lt;!--将业务类注入到spring，通过配置或者注解实现--\u0026gt; \u0026lt;bean id=\u0026quot;userService\u0026quot; class=\u0026quot;com.hjc.service.UserServiceImpl\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;userMapper\u0026quot; ref=\u0026quot;userMapper\u0026quot;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--注解实现：在UserServiceImpl类名上加上@Service，在set方法上加上@Autowired--\u0026gt; \u0026lt;!--配置声明式事务--\u0026gt; \u0026lt;bean id=\u0026quot;transactionManager\u0026quot; class=\u0026quot;org.springframework.jdbc.datasource.DataSourceTransactionManager\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;dataSource\u0026quot; ref=\u0026quot;dataSource\u0026quot;/\u0026gt; \u0026lt;/bean\u0026gt;  SpringMVC层  配置web.xml  \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;springmvc\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;org.springframework.web.servlet.DispatcherServlet\u0026lt;/servlet-class\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;contextConfigLocation\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;classpath:applicationContext.xml\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;load-on-startup\u0026gt;1\u0026lt;/load-on-startup\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;springmvc\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;/\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; \u0026lt;filter\u0026gt; \u0026lt;filter-name\u0026gt;encodingFilter\u0026lt;/filter-name\u0026gt; \u0026lt;filter-class\u0026gt;org.springframework.web.filter.CharacterEncodingFilter\u0026lt;/filter-class\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;encoding\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;utf-8\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;/filter\u0026gt; \u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;encodingFilter\u0026lt;/filter-name\u0026gt; \u0026lt;url-pattern\u0026gt;/*\u0026lt;/url-pattern\u0026gt; \u0026lt;/filter-mapping\u0026gt; \u0026lt;session-config\u0026gt; \u0026lt;session-timeout\u0026gt;15\u0026lt;/session-timeout\u0026gt; \u0026lt;/session-config\u0026gt;  配置spring-mvc.xml  \u0026lt;!--注解驱动--\u0026gt; \u0026lt;mvc:annotation-driven/\u0026gt; \u0026lt;!--静态资源过滤--\u0026gt; \u0026lt;mvc:default-servlet-handler/\u0026gt; \u0026lt;!--扫描包--\u0026gt; \u0026lt;context:component-scan base-package=\u0026quot;com.hjc.controller\u0026quot;/\u0026gt; \u0026lt;!--视图解析器--\u0026gt; \u0026lt;bean class=\u0026quot;org.springframework.web.servlet.view.InternalResourceViewResolver\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;prefix\u0026quot; value=\u0026quot;/WEB-INF/jsp/\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;suffix\u0026quot; value=\u0026quot;.jsp\u0026quot;/\u0026gt; \u0026lt;/bean\u0026gt;  在applicationContext.xml中导入三个xml  \u0026lt;import resource=\u0026quot;classpath:spring-dao.xml\u0026quot;/\u0026gt; \u0026lt;import resource=\u0026quot;classpath:spring-service.xml\u0026quot;/\u0026gt; \u0026lt;import resource=\u0026quot;classpath:spring-mvc.xml\u0026quot;/\u0026gt;  至此，基本的环境已经搭建完毕，接下来就是实现业务\n业务 实现查询所有用户的功能\n 编写UserController  @Controller @RequestMapping(\u0026quot;/user\u0026quot;) public class UserController { @Autowired @Qualifier(\u0026quot;userService\u0026quot;) private UserService userService; //查询所有用户 @RequestMapping(\u0026quot;/allUser\u0026quot;) public String getAllUser(Model model) { List\u0026lt;User\u0026gt; userList = userService.findAllUser(); model.addAttribute(\u0026quot;list\u0026quot;, userList); return \u0026quot;allUser\u0026quot; } }  在jsp目录下新建allUser.jsp  \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;所有用户\u0026lt;/title\u0026gt; \u0026lt;%--BootStrap--%\u0026gt; \u0026lt;link rel=\u0026quot;stylesheet\u0026quot; href=\u0026quot;http://cdn.bootcss.com/bootstrap/3.3.0/css/bootstrap.min.css\u0026quot;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026quot;container\u0026quot;\u0026gt; \u0026lt;div class=\u0026quot;row clearfix\u0026quot;\u0026gt; \u0026lt;div class=\u0026quot;col-md-12 column\u0026quot;\u0026gt; \u0026lt;div class=\u0026quot;page-header\u0026quot;\u0026gt; \u0026lt;h1\u0026gt; \u0026lt;small\u0026gt;用户列表---------显示所有用户\u0026lt;/small\u0026gt; \u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026quot;row clearfix\u0026quot;\u0026gt; \u0026lt;div class=\u0026quot;col-md-12 column\u0026quot;\u0026gt; \u0026lt;table class=\u0026quot;table table-hover table-striped\u0026quot;\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;用户编号\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;用户姓名\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;用户地址\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;%--数据从list中遍历出来--%\u0026gt; \u0026lt;tbody\u0026gt; \u0026lt;c:forEach var=\u0026quot;user\u0026quot; items=\u0026quot;${list}\u0026quot;\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;${user.userId}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;${user.userName}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;${user.address}\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/c:forEach\u0026gt; \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  在index.jsp中编写  \u0026lt;%@ page contentType=\u0026quot;text/html;charset=UTF-8\u0026quot; language=\u0026quot;java\u0026quot; %\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;首页\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; a{ text-decoration: none; color: black; font-size: 18px; } h3{ width: 180px; height: 38px; margin: 100px auto; text-align: center; line-height: 38px; background: deepskyblue; border-radius: 5px; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h3\u0026gt; \u0026lt;a href=\u0026quot;${pageContext.request.contextPath}/user/allUser\u0026quot;\u0026gt;查看所有用户\u0026lt;/a\u0026gt; \u0026lt;/h3\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  ","date":"2020-07-20","permalink":"https://example.com/post/ssm-integration/","tags":["spring","springmvc","mybatis","java"],"title":"SSM整合配置笔记"},{"content":"1 简介 1.1 定义 首先，MVC是模型（Model），视图（View），控制器（Controller）的简写，是一种软件设计规范\n 模型（Dao，Service） 视图（jsp/html） 控制器（Servlet）  SpringMVC是Spring Framework的一部分，是基于Java实现MVC的轻量级Web框架\n1.2 设计 Spring的web框架围绕DIspatcherServlet设计，DispatcherServlet的作用是将请求分发到不同处理器，整个框架围绕一个中心Servlet分派请求并提供其他功能\n\n2 HelloSpringMVC 2.1 xml配置   导入SpringMVC的依赖\n  在WEB-INF/jsp下创建hello.jsp\n  \u0026lt;body\u0026gt; ${msg} \u0026lt;/body\u0026gt;  配置web.xml，注册DispatcherServlet  \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;springmvc\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;org.springframework.web.servlet.DispatcherServlet\u0026lt;/servlet-class\u0026gt; \u0026lt;!--绑定Spring的配置文件--\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;contextConfigLocation\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;classpath:springmvc-servelt.xml\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;!--启动级别 1--\u0026gt; \u0026lt;load-on-startup\u0026gt;1\u0026lt;/load-on-startup\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;serlvet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;springmvc\u0026lt;/servlet-name\u0026gt; \u0026lt;!-- / 只匹配所有请求，不匹配jsp页面 /* 匹配所有请求，包括jsp页面 --\u0026gt; \u0026lt;url-pattern\u0026gt;/\u0026lt;/url-pattern\u0026gt; \u0026lt;/serlvet-mapping\u0026gt;  配置springmvc-servlet.xml  \u0026lt;!--配置处理器映射器--\u0026gt; \u0026lt;bean class=\u0026quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping\u0026quot;/\u0026gt; \u0026lt;!--配置处理器适配器--\u0026gt; \u0026lt;bean class=\u0026quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter\u0026quot;/\u0026gt; \u0026lt;!--配置视图解析器--\u0026gt; \u0026lt;bean class=\u0026quot;org.springframework.web.servlet.view.InternalResourceViewResolver\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;prefix\u0026quot; value=\u0026quot;/WEB-INF/jsp/\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;suffix\u0026quot; value=\u0026quot;.jsp\u0026quot;/\u0026gt; \u0026lt;/bean\u0026gt;  创建HelloController，实现Controller接口  public class HelloController implements Controller { @Override public ModelAndView handlerRequest(HttpServletRequest req, HttpServletResponse resp) throws Throwable { ModelAndView mv = new ModelAndView(); String result = \u0026quot;HelloSpringMVC\u0026quot;; mv.addObject(\u0026quot;msg\u0026quot;, result); mv.setViewName(\u0026quot;hello\u0026quot;); return mv; } }  因为使用了BeanNameUrlHandlerMapping处理器映射器，所以要在Spring中注册bean  \u0026lt;bean id=\u0026quot;/hello\u0026quot; class=\u0026quot;com.hjc.controller.HelloController\u0026quot;/\u0026gt;  配置Tomcat，运行，在url输入localhost:8080/hello  在实际开发中，一般不会写这么多配置文件，而是使用注解配置\n2.2 注解配置  导入SpringMVC的依赖 在WEB-INF/jsp下创建hello.jsp  \u0026lt;body\u0026gt; ${msg} \u0026lt;/body\u0026gt;  配置web.xml，注册DispatcherServlet  \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;springmvc\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;org.springframework.web.servlet.DispatcherServlet\u0026lt;/servlet-class\u0026gt; \u0026lt;!--绑定Spring的配置文件--\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;contextConfigLocation\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;classpath:springmvc-servelt.xml\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;!--启动级别 1--\u0026gt; \u0026lt;load-on-startup\u0026gt;1\u0026lt;/load-on-startup\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;serlvet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;springmvc\u0026lt;/servlet-name\u0026gt; \u0026lt;!-- / 只匹配所有请求，不匹配jsp页面 /* 匹配所有请求，包括jsp页面 --\u0026gt; \u0026lt;url-pattern\u0026gt;/\u0026lt;/url-pattern\u0026gt; \u0026lt;/serlvet-mapping\u0026gt;  配置springmvc-servlet.xml  \u0026lt;!--配置自动扫描包--\u0026gt; \u0026lt;context:component-scan base-package=\u0026quot;com.hjc.controller\u0026quot;/\u0026gt; \u0026lt;!--不处理静态资源--\u0026gt; \u0026lt;mvc:default-servlet-handler/\u0026gt; \u0026lt;!--支持mvc注解驱动--\u0026gt; \u0026lt;mvc:annotation-driven/\u0026gt; \u0026lt;!--配置视图解析器--\u0026gt; \u0026lt;bean class=\u0026quot;org.springframework.web.servlet.view.InternalResourceViewResolver\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;prefix\u0026quot; value=\u0026quot;/WEB-INF/jsp/\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;suffix\u0026quot; value=\u0026quot;.jsp\u0026quot;/\u0026gt; \u0026lt;/bean\u0026gt;  创建HelloController  @Controller @RequestMapping(\u0026quot;/hello\u0026quot;) public class HelloController { @RequestMapping(\u0026quot;/test\u0026quot;) public String hello(Model model) { model.addAttribute(\u0026quot;msg\u0026quot;, \u0026quot;HelloSpringMVC\u0026quot;); return \u0026quot;hello\u0026quot;;\t//返回结果会被视图解析器处理 } }  配置Tomcat，运行，在url输入localhost:8080/hello/test  总结\n 不使用注解开发要配置处理器映射器、处理器适配器和视图解析器 使用注解开发只需要配置视图解析器  3. Controller相关配置  控制器提供访问应用程序的行为，通常通过接口定义（2.1）或注解定义（2.2）实现，一般开发中使用注解实现 控制器负责解析用户的请求并将其转化为一个模型 一个控制器可以包含多个方法  3.1 @Controller 这个注解和@Component、@Service、@Repository作用相同，只是为了区分不同的类。@Controller将类注册到Spring容器中，并声明类的实例是一个控制器\n @Component：组件 @Service：service @Controller：controller @Repository：dao  3.2 @RequestMapping 这个注解可以写在类名上或者方法名上，在类名上的注解和方法名上的注解是一种上下级的关系，内部写访问的域名\n3.3 方法返回String 因为配置了视图解析器，Controller内部的方法只要返回String，返回结果会被视图解析器处理\n比如\nreturn \u0026quot;hello\u0026quot;;  视图解析器会根据配置的内容\n\u0026lt;property name=\u0026quot;prefix\u0026quot; value=\u0026quot;/WEB-INF/jsp/\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;suffix\u0026quot; value=\u0026quot;.jsp\u0026quot;/\u0026gt;  去寻找/WEB-INF/jsp/hello.jsp文件\n4 RESTful风格 4.1 概念 RESTful是一个资源定位及资源操作的风格，不是标准也不是协议，只是一种风格。基于这个风格设计的软件可以更加简洁，更有层次，更易于实现缓存机制\n4.2 功能  资源操作：使用POST、DELETE、PUT、GET等不同方法对资源进行操作  传统方式\n@Controller public class HelloController { @RequestMapping(\u0026quot;/add\u0026quot;) public String add(int a, int b, Model model) { int res = a + b; model.addAttribute(\u0026quot;msg\u0026quot;, \u0026quot;answer is \u0026quot; + res); return \u0026quot;hello\u0026quot;; } }  那么，向这个控制器发送请求，我们需要在url中输入localhost:8080/add?a=1\u0026amp;b=2，最后在页面上能显示“answer is 3”\nRESTful风格\n@Controller public class HelloController { @RequestMapping(value=\u0026quot;/add/{a}/{b}\u0026quot;, method=\u0026quot;RequestMethod.GET\u0026quot;) public String add(@PathVariable int a, @PathVariable int b, Model model) { int res = a + b; model.addAttribute(\u0026quot;msg\u0026quot;, \u0026quot;answer is \u0026quot; + res); return \u0026quot;hello\u0026quot;; } }  使用@PathVariable注解，使方法参数的值对应绑定到URI模板变量上。用@RequestMapping来限制请求方法，可以直接用@GetMapping(\u0026quot;/add/{a}/{b}\u0026quot;)来代替。此时，需要在url输入localhost:8080/add/1/2，且请求方法为get才能访问到。如果将method改为RequestMethod.POST，或者注解改为@PostMapping(\u0026quot;/add/{a}/{b}\u0026quot;)，那么url不变，请求方法为post才能访问到\n4.3 优点  使路径变得更加简洁 获得参数更加方便，框架会自动进行类型转换  5 结果跳转方式 5.1 ModelAndView 在控制器方法内部，要设置ModelAndView对象，根据view的名字和视图解析器跳到指定的页面\n 页面 = 视图解析器前缀 + viewName + 视图解析器后缀  5.2 ServletAPI 我们也可以通过ServletAPI，不设置ModelAndView和视图解析器来进行页面跳转\n 通过HttpServletResponse进行输出 通过HttpServletResponse实现重定向 通过HttpServletResponse实现转发  这种方法实际项目中不推荐使用\n5.3 SpringMVC实现转发和重定向  通过SpringMVC实现转发和重定向，没有视图解析器  @Controller public class TestController { @RequestMapping(\u0026quot;/tc/t1\u0026quot;) public String test1() { //实现转发 return \u0026quot;/WEB-INF/jsp/hello.jsp\u0026quot;; } @RequestMapping(\u0026quot;/tc/t2\u0026quot;) public String test2() { //实现转发 return \u0026quot;forward:/WEB-INF/jsp/hello.jsp\u0026quot;; } @RequestMapping(\u0026quot;tc/t3\u0026quot;) public String test3() { //实现重定向 return \u0026quot;redirect:/index.jsp\u0026quot;;\t//重定向无法直接访问到WEB-INF目录下的文件 } }  没有视图解析器，我们在写页面路径的时候要写其对应的全限定名\n 通过SpringMVC来实现转发和重定向，有视图解析器  @Controller public class TestController { @RequestMapping(\u0026quot;/tc/t1\u0026quot;) public String test1() { //实现转发 return \u0026quot;hello\u0026quot;; } @RequestMapping(\u0026quot;/tc/t2\u0026quot;) public String test2() { //实现重定向 return \u0026quot;redirect:/index.jsp\u0026quot;; } }  有了视图解析器，控制器方法返回字符串默认就是转发的情况\n6 数据处理 6.1 数据从前端到控制器 控制器要接收前端的数据进行处理，那么有这么几种情况\n 提交的域名称和处理方法的参数名一致  url：localhost:8080/hello?name=test\n处理方法\n@RequestMapping(\u0026quot;/hello\u0026quot;) public String hello(String name) { System.out.println(name); return \u0026quot;hello\u0026quot;; }  提交的域名称和处理方法的参数不一致  url：localhost:8080/hello?username=test\n处理方法\n@RequestMapping(\u0026quot;/hello\u0026quot;) public String hello(@RequestParam(\u0026quot;username\u0026quot;) String name) { System.out.println(name); return \u0026quot;hello\u0026quot;; }  或者\n@RequestMapping(\u0026quot;/hello\u0026quot;) @RequestParam(\u0026quot;username\u0026quot;) public String hello(String name) { System.out.println(name); return \u0026quot;hello\u0026quot;; }  提交的是一个对象  要求提交的表单域和对象的属性名一致，方法的参数使用对象\nurl：localhost:8080/hello?name=test\u0026amp;id=1\u0026amp;\u0026amp;age=18\n在User实体类中要保证有属性name，id，age\n处理方法\n@RequestMapping(\u0026quot;/hello\u0026quot;) public String hello(User user) { System.out.println(user); return \u0026quot;hello\u0026quot;; }  如果前端传递的参数名和对象属性名不一致，结果会输出null\n6.2 数据从控制器到前端  通过ModelAndView  可以在存储数据的同时，进行设置返回的逻辑视图，进行控制展示层的跳转   通过Model  只有几个方法用于存储数据，简化操作   通过ModelMap  继承自LinkedHashMap    大部分情况下，一般使用Model\n7 乱码问题 从前端提交的数据到控制器会出现乱码问题，我们使用过滤器解决，直接在web.xml中配置SpringMVC提供的过滤器\n\u0026lt;filter\u0026gt; \u0026lt;filter-name\u0026gt;encoding\u0026lt;/filter-name\u0026gt; \u0026lt;filter-class\u0026gt;org.springframework.web.filter.CharacterEncodingFilter\u0026lt;/filter-class\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;encoding\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;utf-8\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;/filter\u0026gt; \u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;encoding\u0026lt;/filter-name\u0026gt; \u0026lt;url-pattern\u0026gt;/*\u0026lt;/url-pattern\u0026gt; \u0026lt;/filter-mapping\u0026gt;  当然，我们也可以用自己编写的过滤器，只要实现Filter接口\n8 JSON 前后端分离，后端部署后端，后端提供接口，前端独立部署，渲染后端数据，前后端通过json格式来交换数据\n8.1 概念 JSON（JavaScript Object Notation，JS对象标记）是一种轻量级数据交换格式，采用完全独立于编程语言的文本格式来存储和表示数据\n8.2 语法  对象表示为键值对，数据由逗号分隔 花括号表示对象 方括号保存数组  JSON是JavaScript对象的字符串表示法，使用文本表示一个JS对象的信息，本质是一个字符串\nvar obj = {a: 'Hello', b: 'world'};\t//这是一个对象，键名也可以使用引号 var json = '{\u0026quot;a\u0026quot;: \u0026quot;Hello\u0026quot;, \u0026quot;b\u0026quot;: \u0026quot;world\u0026quot;}';\t//这是一个JSON字符串  JSON和JavaScript对象互转\nvar obj = JSON.parse('{\u0026quot;a\u0026quot;: \u0026quot;Hello\u0026quot;, \u0026quot;b\u0026quot;: \u0026quot;world\u0026quot;}'); //结果为 {a: 'Hello', b: 'world' } var json = JSON.stringify({a: 'Hello', b: 'world'}); //结果为 '{\u0026quot;a\u0026quot;: \u0026quot;Hello\u0026quot;, \u0026quot;b\u0026quot;: \u0026quot;world\u0026quot;}'  8.3 Controller返回JSON数据 使用JSON解析工具Jackson或者fastjson\n 导入Jackson的包  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.fasterxml.jackson.core\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jackson-databind\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.11.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;  配置web.xml（DispatcherSerlvet、CharacterEncodingFilter） 配置springmvc-servlet.xml（自动扫描包，视图解析器） 编写User实体类  public class User { private String name; private int age; private String sex; //省略get/set方法和构造函数 }  编写UserController  @Controller public class UserController { @RequestMapping(\u0026quot;j1\u0026quot;) @ResponseBody public String json1() throws JsonProcessingException { ObjectMapper mapper = new ObjectMapper(); User user = new User(\u0026quot;test\u0026quot;, 18, \u0026quot;male\u0026quot;); String str = mapper.writeValueAsString(user); return str; } }  使用@ResponseBody，方法返回值不会走视图解析器，会直接返回字符串。在url输入localhost:8080/j1，页面上显示json字符串 {\u0026ldquo;name\u0026rdquo;: \u0026ldquo;test\u0026rdquo;, \u0026ldquo;age\u0026rdquo;: \u0026ldquo;18\u0026rdquo;, \u0026ldquo;sex\u0026rdquo;: \u0026ldquo;male\u0026rdquo;}。除了使用@ResponseBody，还可以在类上使用@RestController，而不使用@Controller，那么类中的所有方法都会返回字符串\n如果出现乱码问题，我们可以在springmvc-serclet.xml文件中配置\n\u0026lt;mvc:annotation-driven\u0026gt; \u0026lt;mvc:message-converters register-defaults=\u0026quot;trued\u0026quot;\u0026gt; \u0026lt;bean class=\u0026quot;org.springframework.http.converter.StringHttpMessageConverter\u0026quot;\u0026gt; \u0026lt;constructor-arg value=\u0026quot;UTF-8\u0026quot;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean class=\u0026quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;objectMapper\u0026quot;\u0026gt; \u0026lt;bean class=\u0026quot;org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;failOnEmptyBeans\u0026quot; value=\u0026quot;false\u0026quot;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/mvc:message-converters\u0026gt; \u0026lt;/mvc:annotation-driven\u0026gt;  如果使用fastjson，使用方法和Jackson类似\n","date":"2020-07-19","permalink":"https://example.com/post/study-springmvc/","tags":["spring","springmvc","java"],"title":"SpringMVC学习笔记"},{"content":"1 简介 1.1 历史   Spring框架以interface21框架为基础，经过重新设计，并不断丰富其内涵，与2004年3月24日发布了1.0正式版\n  作者为Rod Johnson\n  1.2 理念  使现有的技术更加容易使用 本身包括很多内容，并整合了现有的技术框架  1.3 优点  Spring是一个开源的免费的框架（容器） Spring是一个轻量级的、非入侵式的框架 控制反转（IOC） 面向切面编程（AOP） 支持事务的处理  1.4 组成 \n1.5 其他  Spring Boot  一个快速开发的框架 基于Spring Boot可以快速开发单个微服务   Spring Cloud  基于Spring Boot实现    2 IoC 以前的JavaWeb项目开发流程，比如\n 写UserDao接口  public interface UserDao { //方法 }  写UserDaoImpl实现类  public class UserDaoImpl implements UserDao { //方法实现 }  写UserService业务接口  public interface UserService { //方法 }  写UserServiceImpl业务实现类  public class UserServiceImpl implements UserService { private UserDao userDao = new UserDaoImpl(); //方法实现 }  测试  @Test public void test() { UserService userService = new UserServiceImpl(); //调用userService的方法 }  这种方法的弊端在于用户的需求可能会影响代码，需要根据用户需求去修改代码，代价很大\n那么，如果在UserServiceImpl中使用set接口，程序变为\npublic class UserServiceImpl implements UserService { private UserDao userDao; //利用set进行动态注入 public void setUserDao(UserDao userDao) { this.userDao = userDao; } //方法实现 }  测试的时候代码变为\n@Test public void test() { UserService userService = new UserServiceImpl(); (UserServiceImpl) userService.setUserDao(new UserDaoImpl()); //调用userService的方法 }  使用set注入后，程序不再具有主动性，变成了被动的接收对象。主动权转到了用户，用户选择实现类对象\n这种思想从本质上解决了问题，程序员不用管理对象的创建，降低了系统的耦合，从而专注业务的实现，这就是IoC的原型\n2.1 IoC本质 控制反转（IoC, Inversion of Control）是一种设计思想。在没有IoC的程序中，使用面向对象编程，对象的创建和对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制。而控制反转则是将对象的创建转移给第三方\n控制反转是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式，在Spring中实现控制反转的是IoC容器，其实现方法是依赖注入（DI, Dependency Injection）\n3 HelloSpring  编写实体类  public class Hello { private String str; public void setStr(String str) { this.str = str; } public String getStr() { return str; } }  配置xml文件  \u0026lt;bean id=\u0026quot;hello\u0026quot; class=\u0026quot;com.hjc.pojo.Hello\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;str\u0026quot; value=\u0026quot;Hello, world\u0026quot;/\u0026gt; \u0026lt;/bean\u0026gt;  测试  @Test public void test() { ApplicationContext context = new ClassPathXmlApplicationContext(\u0026quot;beans.xml\u0026quot;); Hello hello = (Hello) context.getBean(\u0026quot;hello\u0026quot;); System.out.println(hello); }  要实现不同的操作，我们只需要在xml文件中修改。对象由Spring来创建，管理，装配\n4 IoC创建对象的方式 4.1 无参构造函数创建对象 要用无参构造函数创建对象，那么类中就要保留无参构造函数，要么显示写出无参构造函数，要么就不写构造函数\npublic class User { private int id; private String name; public void setId(int id) { this.id = id; } public void setName(String name) { this.name = name; } //其他函数 }  此时，在配置xml时就如上文那样，数据注入是由set注入的，那么在类中就要写出属性的set方法\n\u0026lt;bean id=\u0026quot;user\u0026quot; class=\u0026quot;com.hjc.pojo.User\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;id\u0026quot; value=\u0026quot;1\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;name\u0026quot; value=\u0026quot;admin\u0026quot;/\u0026gt; \u0026lt;/bean\u0026gt;  用这种方式配置，那么对象是先由类的无参构造函数创建，再由类的set方法进行数据的注入，要注意这个先后顺序\n4.2 有参构造函数创建对象 如果要使用有参构造函数创建对象，那么在类中就要写出有参构造函数。此时，数据是由有参构造函数注入\npublic class User { private int id; private String name; public User(int id, String name) { this.id = id; this.name = name; } }  在配置xml文件时就和上文不太一样\n\u0026lt;bean id=\u0026quot;user\u0026quot; class=\u0026quot;com.hjc.pojo.User\u0026quot;\u0026gt; \u0026lt;constructor-arg index=\u0026quot;0\u0026quot; value=\u0026quot;1\u0026quot;/\u0026gt; \u0026lt;constructor-arg index=\u0026quot;1\u0026quot; value=\u0026quot;admin\u0026quot;/\u0026gt; \u0026lt;/bean\u0026gt;  \u0026lt;bean id=\u0026quot;user\u0026quot; class=\u0026quot;com.hjc.pojo.User\u0026quot;\u0026gt; \u0026lt;constructor-arg type=\u0026quot;int\u0026quot; value=\u0026quot;1\u0026quot;/\u0026gt; \u0026lt;constructor-arg type=\u0026quot;java.lang.String\u0026quot; value=\u0026quot;admin\u0026quot;/\u0026gt; \u0026lt;/bean\u0026gt;  \u0026lt;bean id=\u0026quot;User\u0026quot; class=\u0026quot;com.hjc.pojo.User\u0026quot;\u0026gt; \u0026lt;constructor-arg name=\u0026quot;id\u0026quot; value=\u0026quot;1\u0026quot;/\u0026gt; \u0026lt;constructor-arg name=\u0026quot;name\u0026quot; value=\u0026quot;admin\u0026quot;/\u0026gt; \u0026lt;/bean\u0026gt;  以上三种方法都可以实现相同的效果。以这种方式配置，对象就由类的有参构造函数创建，而数据也是由有参构造函数注入\n不管对象是由无参构造函数还是有参构造函数创建的，在配置文件加载的时候，容器中的对象就已经被初始化了\n5 Spring配置 5.1 别名 Spring中别名的使用和MyBatis中类似，使用别名之后可以省略类的包路径\n5.2 bean的配置 \u0026lt;!-- id: bean的唯一标识符 class: bean对象对应的全限定名 name: 别名，可以取多个别名 scope: bean为单例还是多例 --\u0026gt; \u0026lt;bean id=\u0026quot;user\u0026quot; class=\u0026quot;com.hjc.pojo.User\u0026quot; name=\u0026quot;user2\u0026quot; scope=\u0026quot;singleton\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;id\u0026quot; value=\u0026quot;1\u0026quot;/\u0026gt; \u0026lt;property name=\u0026quot;name\u0026quot; value=\u0026quot;admin\u0026quot;/\u0026gt; \u0026lt;/bean\u0026gt;  5.3 使用import 将多个配置文件导入合并为一个配置文件。比如，在applicationContext.xml文件中导入service.xml和dao.xml配置文件，将这两个配置文件合并为一个applicationContext.xml配置文件\n\u0026lt;import resource=\u0026quot;service.xml\u0026quot;/\u0026gt; \u0026lt;import resource=\u0026quot;dao.xml\u0026quot;/\u0026gt;  6 依赖注入 6.1 构造器注入 参考4.2\n6.2 set方式注入  依赖注入  依赖：bean对象的创建依赖于容器 注入：bean对象的所有属性由容器注入    实例\n 编写实体类  public class Student { private String name; private Address address; private String[] books; private List\u0026lt;String\u0026gt; hobbies; private Map\u0026lt;String, String\u0026gt; scores; private Set\u0026lt;String\u0026gt; games; private String nullPoint; private Properties info; //一定要写各属性的set方法，在此省略 }  public class Address { private String address; public setAddress(String address) { this.address = address; } }  配置xml文件，使用set方法注入  \u0026lt;bean id=\u0026quot;address\u0026quot; class=\u0026quot;com.hjc.pojo.Address\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;address\u0026quot; value=\u0026quot;testAddress\u0026quot;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026quot;student\u0026quot; class=\u0026quot;com.hjc.pojo.Student\u0026quot;\u0026gt; \u0026lt;!--基本类型（包括String）注入，value--\u0026gt; \u0026lt;property name=\u0026quot;name\u0026quot; value=\u0026quot;test\u0026quot;/\u0026gt; \u0026lt;!--bean注入，ref--\u0026gt; \u0026lt;property name=\u0026quot;address\u0026quot; ref=\u0026quot;address\u0026quot;/\u0026gt; \u0026lt;!--数组注入，--\u0026gt; \u0026lt;property name=\u0026quot;books\u0026quot;\u0026gt; \u0026lt;array\u0026gt; \u0026lt;value\u0026gt;testBook1\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;testBook2\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;testBook3\u0026lt;/value\u0026gt; \u0026lt;/array\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;!--list注入--\u0026gt; \u0026lt;property name=\u0026quot;hobbies\u0026quot;\u0026gt; \u0026lt;list\u0026gt; \u0026lt;value\u0026gt;testHobby1\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;testHobby2\u0026lt;/value\u0026gt; \u0026lt;/list\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;!--map注入--\u0026gt; \u0026lt;property name=\u0026quot;scores\u0026quot;\u0026gt; \u0026lt;map\u0026gt; \u0026lt;entry key=\u0026quot;Math\u0026quot; value=\u0026quot;100\u0026quot;/\u0026gt; \u0026lt;entry key=\u0026quot;Physics\u0026quot; value=\u0026quot;100\u0026quot;/\u0026gt; \u0026lt;/map\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;!--set注入--\u0026gt; \u0026lt;property name=\u0026quot;games\u0026quot;\u0026gt; \u0026lt;set\u0026gt; \u0026lt;value\u0026gt;testGame1\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;testGame2\u0026lt;/value\u0026gt; \u0026lt;/set\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;!--null注入--\u0026gt; \u0026lt;property name=\u0026quot;nullPoint\u0026quot;\u0026gt; \u0026lt;null/\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;!--properties注入--\u0026gt; \u0026lt;property name=\u0026quot;info\u0026quot;\u0026gt; \u0026lt;props\u0026gt; \u0026lt;prop key=\u0026quot;testInfo1\u0026quot;\u0026gt;test1\u0026lt;/prop\u0026gt; \u0026lt;prop key=\u0026quot;testInfo2\u0026quot;\u0026gt;test2\u0026lt;/prop\u0026gt; \u0026lt;/props\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt;  测试  @Test public void test() { ApplicationContext context = new ClassPathXmlApplicationContext(\u0026quot;beans.xml\u0026quot;); Student student = (Student) context.getBean(\u0026quot;student\u0026quot;); System.out.println(student); }  6.3 其他方式注入 p命名空间，对应set注入，参考官方文档\nc命名空间，对象构造器注入，参考官方文档\n7 bean的作用域 7.1 singleton 单例模式，也是Spring的默认模式，不显示写出就表示单例\n单例模式表示在容器中对象只会创建一个\n7.2 prototype 原型模式，表示每次从容器中获得对象的时候，容器会创建一个新的对象返回\n7.3 request、session、application 这几个在web开发中使用\n8 bean的自动装配 之前的xml配置都是手动配置的，那么自动装配是Spring会在上下文中自动寻找，自动装配属性\n在Spring中有三种装配的方式\n 在xml中显示配置 在java类中显示配置 隐式自动装配  8.1 byName自动装配 public class Student { private String name; private Computer computer; private KeyBoard keyBoard; //set方法 }  public class Computer { } public class KeyBoard { }  有三个实体类，用byName自动装配配置xml\n\u0026lt;bean id=\u0026quot;computer\u0026quot; class=\u0026quot;com.hjc.pojo.Computer\u0026quot;/\u0026gt; \u0026lt;bean id=\u0026quot;keyBoard\u0026quot; class=\u0026quot;com.hjc.pojo.KeyBoard\u0026quot;/\u0026gt; \u0026lt;!-- byName: 自动在容器上下文中查找和自己对象set方法后面的值对应的bean id 如：类中setComputer方法，Computer对应bean id为computer --\u0026gt; \u0026lt;bean id=\u0026quot;student\u0026quot; class=\u0026quot;com.hjc.pojo.Student\u0026quot; autowire=\u0026quot;byName\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;name\u0026quot; value=\u0026quot;test\u0026quot;/\u0026gt; \u0026lt;/bean\u0026gt;  这种方法要求bean的id不能随便选择，要和自动注入的属性的set方法的值一致，除了首字母大写变成小写\n8.2 byType自动装配 还是上面三个实体类，用byType实现自动装配\n\u0026lt;bean id=\u0026quot;computer\u0026quot; class=\u0026quot;com.hjc.pojo.Computer\u0026quot;/\u0026gt; \u0026lt;bean id=\u0026quot;keyBoard\u0026quot; class=\u0026quot;com.hjc.pojo.KeyBoard\u0026quot;/\u0026gt; \u0026lt;!-- byType: 会自动在容器上下文中查找和自己对象属性类型相同的bean --\u0026gt; \u0026lt;bean id=\u0026quot;student\u0026quot; class=\u0026quot;com.hjc.pojo.Student\u0026quot; autowire=\u0026quot;byType\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;name\u0026quot; value=\u0026quot;test\u0026quot;/\u0026gt; \u0026lt;/bean\u0026gt;  这种方法要求对象中属性类型要唯一，如果有几个相同的属性类型，就不能自动装配\n8.3 注解自动装配 jdk1.5支持注解，spring2.5支持注解\n要使用注解\n 导入约束，context约束 配置注解的支持  \u0026lt;context:annotation-config/\u0026gt;  使用@Autowired注解，直接在属性上使用，或者在set方法上使用。另外，使用@Autowired注解可以不写set方法，前提是属性符合byType的要求\n实体类\npublic class Student { private String name; @Autowired private Computer computer; @Autowired private KeyBoard keyBoard; //set方法 }  xml文件\n\u0026lt;bean id=\u0026quot;computer\u0026quot; class=\u0026quot;com.hjc.pojo.Computer\u0026quot;/\u0026gt; \u0026lt;bean id=\u0026quot;keyBoard\u0026quot; class=\u0026quot;com.hjc.pojo.KeyBoard\u0026quot;/\u0026gt; \u0026lt;bean id=\u0026quot;student\u0026quot; class=\u0026quot;com.hjc.pojo.Student\u0026quot;/\u0026gt;  如果使用@Autowired实现自动装配的环境比较复杂，无法通过一个注解完成的时候，可以配合使用@Qualifier(value=\u0026quot;xxx\u0026rdquo;)来指定唯一的一个bean\n9 使用注解开发 在Spring4之后，要使用注解开发，必须要导入aop的包。另外，需要在xml文件中导入context约束，配置注解的支持\n\u0026lt;context:annotation-config/\u0026gt;  首先，要配置扫描的包，也就是说，在类中配置了注解还要被扫描到才有效\n\u0026lt;context:component-scan base-package=\u0026quot;com.hjc\u0026quot;/\u0026gt;  9.1 @Component 这个注解放在类上，表示这个类被Spring管理了，比如\n@Component public class User { //省略 }  相当于在xml文件中配置bean\n\u0026lt;bean id=\u0026quot;user\u0026quot; class=\u0026quot;com.hjc.pojo.User\u0026quot;/\u0026gt;  9.2 @Value 这个注解放在类中的属性上，表示注入数据，比如\n@Component public class User { @Value(\u0026quot;test\u0026quot;) private String name; }  相当于在xml文件中配置bean，并进行依赖注入\n\u0026lt;bean id=\u0026quot;user\u0026quot; class=\u0026quot;com.hjc.pojo.User\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;name\u0026quot; value=\u0026quot;test\u0026quot;/\u0026gt; \u0026lt;/bean\u0026gt;  @Value注解也可以放在属性的对应set方法上，但这个注解只能进行简单的配置，复杂的配置还是使用xml文件\n9.3 @Component的衍生注解 web项目一般有三层，不同层中的注解名称不同，但作用相同\n Dao层：@Repository Service层：@Service Controller层：@Controller  这几个注解和@Component是一样的，都表示将类注册到Spring中，装配bean\n9.4 @Autowired 这个注解实现自动装配，参考8.3\n9.5 @Scope 这个注解配置类的作用域，是单例模式还是原型模式，比如\n@Component @Scope(\u0026quot;singleton\u0026quot;) public class User { @Value(\u0026quot;test\u0026quot;) private String name; }  总结：\n xml文件配置更加万能，适用于任何场合，维护简单 注解适用于简单的配置，维护相对复杂 项目中一般使用xml管理bean，使用注解完成属性注入  10 使用JavaConfig配置 不使用xml文件配置，都由Java代码配置\nJavaConfig是Spring的一个子项目，在Spring4之后，称为一个核心功能\n10.1 @Configuration、@Bean 要用Java代码进行配置，就要用到@Configuration和@Bean这两个注解，比如\n@Configuration public class AppConfig { @Bean public User getUser() { return new User(); } }  这就相当于在xml中配置\n\u0026lt;bean id=\u0026quot;getUser\u0026quot; class=\u0026quot;com.hjc.pojo.User\u0026quot;/\u0026gt;  测试\n@Test public void test() { ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class); User user = context.getBean(\u0026quot;getUser\u0026quot;); }  注意和xml文件配置实例化对象的不同\n10.2 @ComponentScan 在配置类中使用这个注解表示设置扫描类包\n@Configuration @ComponentScan(\u0026quot;com.hjc\u0026quot;) public class AppConfig { @Bean public User getUser() { return new User(); } }  11 代理模式 代理模式是SpringAOP的底层实现\n代理模式有两种\n 静态代理 动态代理  11.1 静态代理 \n角色分析\n 抽象角色：一般会使用接口或者抽象类来解决 真实角色：被代理角色 代理角色：代理真实角色，代理真实角色后，一般会做附加操作 客户：访问代理对象的人  使用静态代理的例子\n 编写接口（抽象角色）  //租房接口 public interface Rent { void rent(); }  编写被代理类（真实角色）  //房东 public class Host implements Rent { @Override public void rent() { System.out.println(\u0026quot;房东出租房子\u0026quot;); } }  编写代理类（代理角色）  public class Proxy implements Rent { private Host host; public Proxy() { } public Proxy(Host host) { this.host = host; } @Override public void rent() { findHouse(); host.rent(); signContract(); } public void findHouse() { System.out.println(\u0026quot;找到房子\u0026quot;); } public void signContract() { System.out.println(\u0026quot;签合同\u0026quot;); } }  编写客户访问代理角色  public class Client { public static void main(String[] args) { Proxy proxy = new Proxy(new Host()); proxy.rent(); } }  静态代理的好处：\n 可以使真实角色的操作更加纯粹，不用关注一些公共的业务 公共业务交给代理角色，实现了业务的分工 公共业务发生扩展的时候，方便集中管理  缺点：\n 一个真实角色就会产生一个代理角色，增加代码量，开发效率低  在web开发中，如果要对类中的方法进行增强，直接改类中对应方法的代码比较繁琐，而且实际开发不允许直接改代码，我们可以使用静态代理实现，举个例子加深理解\n 编写service接口  public interface UserService { void add(); void delete(); void update(); void query(); }  编写service实现类  public class UserServiceImpl implements UserService { //实现对应方法 }  编写代理类  public class UserServiceProxy implements UserService { private UserService userService; public void setUserService(UserService userService) { this.userService = userService; } public void add() { log(\u0026quot;add\u0026quot;); userService.add(); } public void delete() { log(\u0026quot;delete\u0026quot;); userService.delete(); } public void update() { log(\u0026quot;update\u0026quot;); userService.update(); } public void query() { log(\u0026quot;query\u0026quot;); userService.find(); } public void log(String msg) { System.out.println(\u0026quot;[debug] 使用了\u0026quot; + msg + \u0026quot;方法\u0026quot;); } }  客户访问  public class Client { public static void main(String[] args) { UserServiceProxy proxy = new UserServiceProxy(); proxy.setUserService(new UserServiceImpl); proxy.add(); proxy.delete(); proxy.update(); proxy.query(); } }  这样子就避免修改了原有的service代码，而是通过代理类对service类的方法进行增强\n\n11.2 动态代理  动态代理和静态代理的角色一样 动态代理的代理类是动态生成的，不是直接写好的 动态代理分为两大类  基于接口的动态代理：jdk动态代理 基于类的动态代理：cglib 还有基于java字节码实现：Javassist    需要了解两个类：Proxy，InvocationHandler\n动态代理的好处\n 动态代理有静态代理的优点 另外，一个动态代理类代理的是一个接口，一般对应一类业务，解决了静态代理的缺点  12 AOP 12.1AOP定义 AOP（Aspect Oriented Programming），面向切面编程，通过预编译方式和运行期动态代理实现程序功能统一维护的技术。AOP是OOP的延续，是函数式编程的一种衍生范型\n12.2 AOP在Spring中的作用 提供声明式事务，允许用户自定义切面\n 横切关注点：跨越应用程序多个模块的方法或功能，如日志，安全，缓存，事务等等 切面（Aspect）：横切关注点被模块化的特殊对象，即是一个类 通知（Advice）：切面必须要完成的工作，即是类中的一个方法 目标（Target）：被通知对象 代理（Proxy）：向目标对象应用通知之后创建的对象 切入点（PointCut）：切面通知执行的“地点” 连接点（JointPoint）：与切入点匹配的执行点  \nSpringAOP中，通过Advice定义横切逻辑，Spring支持5种类型的Advice\n 前置通知  连接点：方法前 实现接口：org.springframework.aop.MethodBeforeAdvice   后置通知  连接点：方法后 实现接口：org.springframework.aop.AfterReturningAdvice   环绕通知  连接点：方法前后 实现接口：org.aopalliance.intercept.MethodInterceptor   异常抛出通知  连接点：方法抛出异常 实现接口：org.springframework.aop.ThrowsAdvice   引介通知  连接点：类中增加新的方法属性 实现接口：org.springframework.aop.IntroductionInterceptor    AOP在不改变原有代码的情况下， 增加新的功能\n11.3 使用Spring实现AOP 要使用AOP织入，需要导入包\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.aspectj\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aspectjweaver\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.9.5\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;  假设有service接口和实现类\npublic interface UserService { void add(); void delete(); void update(); void query(); }  public class UserServiceImpl implements UserService { //实现对应方法 }  那么，要对这几个方法使用AOP进行方法增强\n方式一：使用Spring的API实现\n 首先要定义切面和通知，定义类实现对应接口  public class BeforeLog implements MethodBeforeAdvice { //Method: 被代理的目标对象的方法 //args: 方法参数 //target: 被代理的目标对象 @Override public void before(Method method, Object[] args, Object target) throws Throwable { System.out.println(\u0026quot;执行\u0026quot; + target.getClass().getName() + \u0026quot;的\u0026quot; + method.getName()); } }  public class AfterLog implements AfterReturningAdvice { //returnValue: 被代理的方法的返回值 @Override public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable { System.out.println(\u0026quot;执行\u0026quot; + method.getName() + \u0026quot;返回结果\u0026quot; + returnValue); } }  在xml中配置，把这些类注册到Spring中  \u0026lt;!--注册bean--\u0026gt; \u0026lt;bean id=\u0026quot;userService\u0026quot; class=\u0026quot;com.hjc.service.UserServiceImpl\u0026quot;/\u0026gt; \u0026lt;bean id=\u0026quot;beforeLog\u0026quot; class=\u0026quot;com.hjc.log.BeforeLog\u0026quot;/\u0026gt; \u0026lt;bean id=\u0026quot;afterLog\u0026quot; class=\u0026quot;com.hjc.log.AfterLog\u0026quot;/\u0026gt; \u0026lt;!--配置aop，导入aop约束--\u0026gt; \u0026lt;aop:config\u0026gt; \u0026lt;!--切入点，expression表达式--\u0026gt; \u0026lt;aop:pointcut id=\u0026quot;pointcut\u0026quot; expression=\u0026quot;execution(* com.hjc.service.UserServiceImpl.*(..))\u0026quot;/\u0026gt; \u0026lt;!--执行增强--\u0026gt; \u0026lt;aop:advisor advice-ref=\u0026quot;beforeLog\u0026quot; pointcut-ref=\u0026quot;pointcut\u0026quot;/\u0026gt; \u0026lt;aop:advisor advice-ref=\u0026quot;afterLog\u0026quot; pointcut-ref=\u0026quot;pointcut\u0026quot;/\u0026gt; \u0026lt;/aop:config\u0026gt;  测试  @Test public void test() { ApplicationContext context = new ClassPathXmlApplicationContext(\u0026quot;applicationContext.xml\u0026quot;); //动态代理的是接口 UserService userService = (UserService) context.getBean(\u0026quot;userService\u0026quot;); userService.add(); userService.delete(); }  方式二：自定义实现AOP\n不通过实现Spring的接口来实现AOP，而是自己定义切面类和通知\npublic class MyLog { public void beforeLog() { //具体实现 } public void AfterLog() { //具体实现 } }  同样，在xml中配置\n\u0026lt;bean id=\u0026quot;myLog\u0026quot; class=\u0026quot;com.hjc.log.MyLog\u0026quot;/\u0026gt; \u0026lt;aop:config\u0026gt; \u0026lt;!--自定义切面--\u0026gt; \u0026lt;aop:aspect ref=\u0026quot;myLog\u0026quot;\u0026gt; \u0026lt;!--切入点--\u0026gt; \u0026lt;aop:pointcut id=\u0026quot;pointcut\u0026quot; expression=\u0026quot;execution(* com.hjc.service.UserServiceImpl.*(..))\u0026quot;/\u0026gt; \u0026lt;!--通知--\u0026gt; \u0026lt;aop:before method=\u0026quot;beforeLog\u0026quot; pointcut-ref=\u0026quot;pointcut\u0026quot;/\u0026gt; \u0026lt;aop:after method=\u0026quot;afterLog\u0026quot; pointcut-ref=\u0026quot;pointcut\u0026quot;/\u0026gt; \u0026lt;/aop:aspect\u0026gt; \u0026lt;/aop:config\u0026gt;  方式三：注解实现AOP\n使用注解实现AOP，主要是在定义切面类的时候使用注解\n@Aspect public class MyLog { @Before(\u0026quot;execution(* com.hjc.service.UserServiceImpl.*(..))\u0026quot;) public void before() { //具体实现 } @After(\u0026quot;execution(* com.hjc.service.UserServiceImpl.*(..))\u0026quot;) public void after() { //具体实现 } }  在xml中只需注册bean，当然也可以使用注解自动装配。还要开启注解支持\n\u0026lt;bean id=\u0026quot;myLog\u0026quot; class=\u0026quot;com.hjc.log.MyLog\u0026quot;/\u0026gt; \u0026lt;aop:aspectj-autoproxy/\u0026gt;  13 整合MyBatis 步骤\n 导入相关jar包  junit mybatis mysql spring aop织入 mybatis-spring   编写配置文件  13.1 MyBatis 13.2 MyBatis-Spring 参考官方文档\n 编写数据源配置 sqlSessionFactory sqlSessionTemplate 给Dao接口编写实现类 注册实现类到Spring中 测试  14 声明式事务 14.1 事务  事务涉及数据的完整性和一致性问题 事务ACID原则  原子性 一致性 隔离性 持久性    14.2 Spring中的事务管理  声明式事务：AOP 编程式事务：在代码中进行事务管理  一般使用声明式事务，而不是用编程式事务，因为编程式事务会改变代码\n 在xml中配置声明式事务  \u0026lt;bean id=\u0026quot;transactionManager\u0026quot; class=\u0026quot;org.springframework.jdbc.datasource.DataSourceTransactionManager\u0026quot;\u0026gt; \u0026lt;property name=\u0026quot;dataSource\u0026quot; value=\u0026quot;dataSource\u0026quot;/\u0026gt; \u0026lt;/bean\u0026gt;  结合AOP实现事务织入  \u0026lt;!--配置事务通知--\u0026gt; \u0026lt;tx:advice id=\u0026quot;txAdvice\u0026quot; transaction-manager=\u0026quot;transactionManager\u0026quot;\u0026gt; \u0026lt;!--给具体方法配置事务--\u0026gt; \u0026lt;tx:attributes\u0026gt; \u0026lt;tx:method name=\u0026quot;add\u0026quot; propagation=\u0026quot;REQUIRED\u0026quot;/\u0026gt; \u0026lt;tx:method name=\u0026quot;delete\u0026quot; propagation=\u0026quot;REQUIRED\u0026quot;/\u0026gt; \u0026lt;tx:method name=\u0026quot;update\u0026quot; propagation=\u0026quot;REQUIRED\u0026quot;/\u0026gt; \u0026lt;tx:method name=\u0026quot;query\u0026quot; read-only=\u0026quot;true\u0026quot;/\u0026gt; \u0026lt;!--配置所有方法--\u0026gt; \u0026lt;tx:method name=\u0026quot;*\u0026quot; propagation=\u0026quot;REQUIRED\u0026quot;/\u0026gt; \u0026lt;/tx:attributes\u0026gt; \u0026lt;/tx:advice\u0026gt; \u0026lt;!--配置事务切入--\u0026gt; \u0026lt;aop:config\u0026gt; \u0026lt;aop:pointcut id=\u0026quot;txPointCut\u0026quot; expression=\u0026quot;execution(* com.hjc.mapper.*.*(..))\u0026quot;/\u0026gt; \u0026lt;aop:advisor advice-ref=\u0026quot;txAdvice\u0026quot; pointcut-ref=\u0026quot;txPointCut\u0026quot;/\u0026gt; \u0026lt;/aop:config\u0026gt;  ","date":"2020-07-16","permalink":"https://example.com/post/study-spring/","tags":["java","spring"],"title":"Spring学习笔记"},{"content":"1 简介 1.1 什么是MyBatis  持久层框架 定制化SQL、存储过程和高级映射 使用简单的XML或注解配置，映射原生类型、接口和POJO为数据库中的记录  1.2 持久化 数据持久化\n 持久化就是将程序的数据在持久状态和瞬时状态转化的过程 数据库、IO文件持久化  1.3 持久层 Dao层\n 完成持久化工作的代码块  1.4 为什么需要MyBatis  传统的JDBC代码太复杂，需要简化 解除sql和程序代码的耦合 ……  2 第一个MyBatis程序 搭建环境\u0026ndash;\u0026gt;导入MyBatis\u0026ndash;\u0026gt;编写代码\u0026ndash;\u0026gt;测试\n2.1 搭建环境  创建数据库 创建项目 导入JDBC驱动，MyBatis包 配置mybatis的核心xml文件  \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot; ?\u0026gt;\r\u0026lt;!DOCTYPE configuration\rPUBLIC \u0026quot;-//mybatis.org//DTD Config 3.0//EN\u0026quot;\r\u0026quot;http://mybatis.org/dtd/mybatis-3-config.dtd\u0026quot;\u0026gt;\r\u0026lt;configuration\u0026gt;\r\u0026lt;environments default=\u0026quot;development\u0026quot;\u0026gt;\r\u0026lt;environment id=\u0026quot;development\u0026quot;\u0026gt;\r\u0026lt;transactionManager type=\u0026quot;JDBC\u0026quot;/\u0026gt;\r\u0026lt;dataSource type=\u0026quot;POOLED\u0026quot;\u0026gt;\r\u0026lt;property name=\u0026quot;driver\u0026quot; value=\u0026quot;${driver}\u0026quot;/\u0026gt;\r\u0026lt;property name=\u0026quot;url\u0026quot; value=\u0026quot;${url}\u0026quot;/\u0026gt;\r\u0026lt;property name=\u0026quot;username\u0026quot; value=\u0026quot;${username}\u0026quot;/\u0026gt;\r\u0026lt;property name=\u0026quot;password\u0026quot; value=\u0026quot;${password}\u0026quot;/\u0026gt;\r\u0026lt;/dataSource\u0026gt;\r\u0026lt;/environment\u0026gt;\r\u0026lt;/environments\u0026gt;\r\u0026lt;!--每个Mapper.xml都要在核心配置文件中注册--\u0026gt;\r\u0026lt;mappers\u0026gt;\r\u0026lt;mapper resource=\u0026quot;com/hjc/dao/UserMapper.xml\u0026quot;/\u0026gt;\r\u0026lt;/mappers\u0026gt;\r\u0026lt;/configuration\u0026gt;\r 从xml文件中构建SqlSessionFactory，我们把构建SqlSessionFactory的方法放在工具类的静态方法内  public class MyBatisUtils {\rprivate static SqlSessionFactory sqlSessionFactory;\rstatic {\rtry {\rString resource = \u0026quot;mybatis-config.xml\u0026quot;;\rInputStream inputStream = Resources.getResourceAsStream(resource);\rsqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\r} catch (IOException e) {\re.printStackTrace();\r}\r}\rpublic static sqlSession getSqlSession() {\rreturn sqlSessionFactory.openSession();\r}\r}\r 2.2 编写代码  编写实体类（pojo） 编写Dao接口  public interface UserDao {\rList\u0026lt;User\u0026gt; getUserList();\r}\r 编写UserMapper.xml文件（接口实现类由原来的UserDaoImpl转变为Mapper配置文件）  \u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot; ?\u0026gt;\r\u0026lt;!DOCTYPE mapper\rPUBLIC \u0026quot;-//mybatis.org//DTD Mapper 3.0//EN\u0026quot;\r\u0026quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026quot;\u0026gt;\r\u0026lt;!--namespace = 绑定一个对应的Dao/Mapper接口--\u0026gt;\r\u0026lt;mapper namespace=\u0026quot;com.hjc.dao.UserDao\u0026quot;\u0026gt;\r\u0026lt;!--select查询语句--\u0026gt;\r\u0026lt;select id=\u0026quot;getUserList\u0026quot; resultType=\u0026quot;com.hjc.pojo.User\u0026quot;\u0026gt;\rselect * from user;\r\u0026lt;/select\u0026gt;\r\u0026lt;/mapper\u0026gt;\r  在核心配置文件中注册UserMapper.xml\n\u0026lt;!--每个Mapper.xml都要在核心配置文件中注册--\u0026gt;\r\u0026lt;mappers\u0026gt;\r\u0026lt;mapper resource=\u0026quot;com/hjc/dao/UserMapper.xml\u0026quot;/\u0026gt;\r\u0026lt;/mappers\u0026gt;\r  在默认的Maven配置下，UserMapper.xml文件应该放在resources文件夹下，也就是resources/com/hjc/dao/UserMapper.xml路径 要想把UserDao和UserMapper.xml文件放在一起，需要更改Maven构建配置 如果不这样做，在构建时，Mapper文件无法被打包到target文件夹中    \u0026lt;build\u0026gt;\r\u0026lt;resources\u0026gt;\r\u0026lt;resource\u0026gt;\r\u0026lt;directory\u0026gt;src/main/java\u0026lt;/directory\u0026gt;\r\u0026lt;includes\u0026gt;\r\u0026lt;include\u0026gt;**/*.xml\u0026lt;/include\u0026gt;\r\u0026lt;/includes\u0026gt;\r\u0026lt;filtering\u0026gt;false\u0026lt;/filtering\u0026gt;\r\u0026lt;/resource\u0026gt;\r\u0026lt;/resources\u0026gt;\r\u0026lt;/build\u0026gt;\r 2.3 测试代码 public class UserDaoTest {\r@Test\rpublic void testGetUserList() {\r//获得SqlSession对象\rSqlSession sqlSession = MyBatisUtils.getSqlSession();\r//方式一：getMapper\rUserDao userDao = sqlSession.getMapper(UserDao.class);\rList\u0026lt;User\u0026gt; userList = userDao.getUserList();\r//方式二：不建议使用\r//List\u0026lt;User\u0026gt; userList = sqlSession.selectList(\u0026quot;com.hjc.dao.UserDao.getUserList\u0026quot;);\rfor (User user : userList)\rSystem.out.println(user);\r//关闭SqlSession\rsqlSession.close();\r}\r}\r 3 CRUD 3.1 namespace namespace中的包名要和Dao/Mapper接口的包名一致\n3.2 select 查询语句\n id：就是对应的namespace中的方法名 resultType：sql语句执行的返回类型 parameterType：sql语句的参数类型   编写接口  //根据id查询用户\rUser getUserById(int id);\r 编写对应Mapper.xml文件中的sql语句  \u0026lt;select id=\u0026quot;getUserById\u0026quot; parameterType=\u0026quot;Integer\u0026quot; resultType=\u0026quot;com.hjc.pojo.User\u0026quot;\u0026gt;\rselect * from user where id = #{id}\r\u0026lt;/selects\u0026gt;\r 测试  @Test\rpublic void testGetUserById() {\rSqlSession sqlSession = MyBatisUtils.getSqlSession();\rUserDao userDao = sqlSession.getMapper(UserDao.class);\rUser user = userDao.getUserById(1);\rSystem.out.println(user);\rsqlSession.close();\r}\r 3.3 insert  编写接口  //插入用户\rvoid addUser(User user);\r 编写对应Mapper.xml文件中的sql语句  \u0026lt;insert id=\u0026quot;addUser\u0026quot; parameterType=\u0026quot;com.hjc.pojo.User\u0026quot;\u0026gt;\rinsert into user (id, name, pwd) values (#{id}, #{name}, #{pwd})\r\u0026lt;/insert\u0026gt;\r 测试  @Test\rpublic void testAddUser() {\rSqlSession sqlSession = MyBatisUtils.getSqlSession();\rUserDao userDao = sqlSession.getMapper(UserDao.class);\ruserDao.addUser(new User(5, \u0026quot;test\u0026quot;, 123456));\r//需要提交事务\rsqlSession.commit();\rsqlSession.close();\r}\r 3.4 update  编写接口  //更新用户\rvoid updateUse(User user);\r 编写对应Mapper.xml文件中的sql语句  \u0026lt;update id=\u0026quot;updateUser\u0026quot; parameterType=\u0026quot;com.hjc.pojp.User\u0026quot;\u0026gt;\rupdate user set name = #{name}, pwd = #{pwd} where id = #{id}\r\u0026lt;/update\u0026gt;\r 测试  @Test\rpublic void testUpdateUser() {\rSqlSession sqlSession = MyBatisUtils.getSqlSession();\rUserDao userDao = sqlSession.getMapper(UserDao.class);\ruserDao.updateUser(new User(5, \u0026quot;test\u0026quot;, 123456));\r//需要提交事务\rsqlSession.commit();\rsqlSession.close();\r}\r 3.5 delete  编写接口  //删除用户\rvoid deleteUserById(int id);\r 编写对应Mapper.xml文件中的sql语句  \u0026lt;delete id=\u0026quot;deleteUserById\u0026quot; parameter=\u0026quot;Integer\u0026quot;\u0026gt;\rdelete from user where id = #{id}\r\u0026lt;/delete\u0026gt;\r 测试  @Test\rpublic void testDeleteUserById() {\rSqlSession sqlSession = MyBatisUtils.getSqlSession();\rUserDao userDao = sqlSession.getMapper(UserDao.class);\ruserDao.deleteUserById(5);\r//需要提交事务\rsqlSession.commit();\rsqlSession.close();\r}\r 注意点：MyBatis默认不会自动提交事务，需要手动提交事务\n3.6 Map 如果实体类或数据库中表的字段或参数过多，我们应当考虑使用Map作为sql的参数\nvoid addUserByMap(Map\u0026lt;String, Object\u0026gt; map);\r \u0026lt;insert id=\u0026quot;addUserByMap\u0026quot; parameterType=\u0026quot;Map\u0026quot;\u0026gt;\rinsert into user (id, pwd) values (#{userId}, #{userPwd})\r\u0026lt;/insert\u0026gt;\r @Test\rpublic void testAddUserByMap() {\rSqlSession sqlSession = MyBatisUtils.getSqlSession();\rUserDao userDao = sqlSession.getMapper(UserDao.class);\rMap\u0026lt;String, Object\u0026gt; map = new HashMap\u0026lt;\u0026gt;();\rmap.put(\u0026quot;userId\u0026quot;, 6);\rmap.put(\u0026quot;userPwd\u0026quot;, \u0026quot;123456\u0026quot;);\ruserDao.addUserByMap(map);\r//需要提交事务\rsqlSession.commit();\rsqlSession.close();\r}\r  Map传递参数，直接在sql中取出key即可 对象传递参数，直接在sql中取对象的属性即可 只有一个基本类型参数的情况下，可以直接在sql中取到 多个参数的情况，用Map，或者注解  3.7 模糊查询 List\u0026lt;User\u0026gt; getUserLike(String name);\r \u0026lt;select id=\u0026quot;getUserLike\u0026quot; parameterType=\u0026quot;String\u0026quot; resultType=\u0026quot;com.hjc.pojo.User\u0026quot;\u0026gt;\rselect * from user where name like #{name}\r\u0026lt;/select\u0026gt;\r @Test\rpublic void testGetUserLike() {\rSqlSession sqlSession = MyBatisUtils.getSqlSession();\rUserDao userDao = sqlSession.getMapper(UserDao.class);\rList\u0026lt;User\u0026gt; userList = userDao.getUserLike(\u0026quot;%test%\u0026quot;);\rfor (User user : userList)\rSystem.out.println(user);\rsqlSession.close();\r}\r  在Java代码执行的时候，传递通配符\u0026rdquo;% %\u0026rdquo;  List\u0026lt;User\u0026gt; userList = userDao.getUserLike(\u0026quot;%test%\u0026quot;);\r  在sql拼接中使用通配符\u0026rdquo;% %\u0026rdquo;  select * from user where name like \u0026quot;%\u0026quot;#{name}\u0026quot;%\u0026quot;\r 4 配置解析 4.1 核心配置文件  mybatis-config.xml 配置文件会影响MyBatis行为的设置和属性信息  configuration（配置）\rproperties（属性）\rsettings（设置）\rtypeAliases（类型别名）\rtypeHandlers（类型处理器）\robjectFactory（对象工厂）\rplugins（插件）\renvironments（环境配置）\renvironment（环境变量）\rtransactionManager（事务管理器）\rdataSource（数据源）\rdatabaseIdProvider（数据库厂商标识）\rmappers（映射器）\r 4.2 环境配置（environments） MyBatis可以配置成适应多种环境，但每个SqlSessionFactory实例只能选择一种环境\nMyBatis默认的事务管理器就是JDBC，连接池POOLED\n4.3 属性（properties） 可以通过properties属性来实现引用配置文件，属性可以在Java属性文件（properties文件）中配置，也可以通过properties元素的子元素来传递\n 编写外部配置文件db.properties  driver=com.mysql.cj.jdbc.Driver\rurl=jdbc:mysql://localhost:3306/test_demo?useSSL=false\u0026amp;allowPublicKeyRetrieval=true\u0026amp;serverTimezone=UTC\rusername=root\rpassword=123456\r 在核心配置文件中引入properties文件  \u0026lt;properties resource=\u0026quot;db.properties\u0026quot;/\u0026gt;\r 也可以在核心配置文件中增加属性  \u0026lt;properties resource=\u0026quot;db.properties\u0026quot;\u0026gt;\r\u0026lt;property name=\u0026quot;username\u0026quot; value=\u0026quot;root\u0026quot;/\u0026gt;\r\u0026lt;property name=\u0026quot;password\u0026quot; value=\u0026quot;111111\u0026quot;/\u0026gt;\r\u0026lt;/properties\u0026gt;\r 如果两个地方都配置了同一字段，优先使用外部文件配置的信息  4.4 类型别名（typeAliases）  类型别名是为Java类型设置一个短的名字，为了减少全限定类名的冗余  \u0026lt;typeAliases\u0026gt;\r\u0026lt;typeAlias type=\u0026quot;com.hjc.pojo.User\u0026quot; alias=\u0026quot;User\u0026quot;/\u0026gt;\r\u0026lt;/typeAliases\u0026gt;\r  指定一个包名，MyBatis会在包名下面搜索需要的JavaBean，默认别名就是这个类的类名，首字母小写，也可以配合注解@Alias使用  \u0026lt;typeAliases\u0026gt;\r\u0026lt;package name=\u0026quot;com.hjc.pojo\u0026quot;/\u0026gt;\r\u0026lt;/typeAliases\u0026gt;\r  在实体类比较少的时候，使用第一种方式；实体类比较多，建议第二种  4.5 设置（settings）  cacheEnabled：全局开启或关闭所有映射器配置文件中已配置的任何缓存 lazyLoadingEnabled：开启或关闭延迟加载 logImpl：指定MyBatis所有日志的具体实现  \u0026lt;settings\u0026gt;\r\u0026lt;setting name=\u0026quot;cacheEnabled\u0026quot; value=\u0026quot;true\u0026quot;/\u0026gt;\r\u0026lt;setting name=\u0026quot;lazyLoadingEnabled\u0026quot; value=\u0026quot;true\u0026quot;/\u0026gt;\r\u0026lt;setting name=\u0026quot;logImpl\u0026quot; value=\u0026quot;LOG4J\u0026quot;/\u0026gt;\r\u0026lt;/settings\u0026gt;\r 4.6 映射器（mappers） 注册绑定Mapper文件\n 方式一  \u0026lt;mappers\u0026gt;\r\u0026lt;mapper resource=\u0026quot;com/hjc/dao/UserMapper.xml\u0026quot;/\u0026gt;\r\u0026lt;/mappers\u0026gt;\r 方式二：使用class文件绑定注册  \u0026lt;mappers\u0026gt;\r\u0026lt;mapper class=\u0026quot;com.hjc.dao.UserMapper\u0026quot;/\u0026gt;\r\u0026lt;/mappers\u0026gt;\r 注意点\n 接口和其Mapper配置文件必须同名 接口和其Mapper配置文件必须在同一个包下  方式三：使用扫描包进行绑定注册  \u0026lt;mappers\u0026gt;\r\u0026lt;mapper package=\u0026quot;com.hjc.dao\u0026quot;/\u0026gt;\r\u0026lt;/mappers\u0026gt;\r 注意点\n 接口和其Mapper配置文件必须同名 接口和其Mapper配置文件必须在同一个包下  4.7 其他配置  typeHandlers（类型处理器） objectFactory（对象工厂） plugins插件  mybatis-generator-core mybatis-plus 通用mapper    4.8 生命周期和作用域 \n生命周期和作用域至关重要，错误使用会导致并发问题\nSqlSessionFactoryBuilder\n 一旦创建了SqlSessionFactory，就不再需要SqlSessionFactoryBuilder了 局部变量  SqlSessionFactory\n 相当于数据库连接池 一旦被创建就在应用的运行期间一直存在，没有理由丢弃它或重新创建另一个实例 SqlSessionFactory的最佳作用域是应用作用域 使用单例模式或者静态单例模式  SqlSesison\n 相当于连接到连接池的一个请求 不是线程安全的，不能被共享 SqlSession的最佳作用域是请求或方法作用域 用完之后要立即关闭，否则资源被占用  \n图中的每个Mapper代表一个具体的业务\n5 实体类属性名和数据库字段名不一致问题 解决方法：\n5.1 起别名 原来是\n\u0026lt;select id=\u0026quot;getUserById\u0026quot; parameterType=\u0026quot;int\u0026quot; resultType=\u0026quot;com.hjc.pojo.User\u0026quot;\u0026gt;\rselect * from user where id = #{id}\r\u0026lt;/select\u0026gt;\r 改为\n\u0026lt;select id=\u0026quot;getUserById\u0026quot; parameterType=\u0026quot;int\u0026quot; resultType=\u0026quot;com.hjc.pojo.User\u0026quot;\u0026gt;\rselect id, name, pwd from user where id = #{id}\r\u0026lt;/select\u0026gt;\r 5.2 使用resultMap 结果集映射\n\u0026lt;!--结果集映射--\u0026gt;\r\u0026lt;resultMap id=\u0026quot;UserMap\u0026quot; type=\u0026quot;User\u0026quot;\u0026gt;\r\u0026lt;!--column为数据库字段，property为实体类属性--\u0026gt;\r\u0026lt;!--\u0026lt;result column=\u0026quot;id\u0026quot; property=\u0026quot;id\u0026quot;/\u0026gt;--\u0026gt;\r\u0026lt;!--\u0026lt;result column=\u0026quot;name\u0026quot; property=\u0026quot;name\u0026quot;/\u0026gt;--\u0026gt;\r\u0026lt;result column=\u0026quot;pwd\u0026quot; property=\u0026quot;password\u0026quot;/\u0026gt;\r\u0026lt;/resultMap\u0026gt;\r\u0026lt;select id=\u0026quot;getUserById\u0026quot; parameterType=\u0026quot;int\u0026quot; resultMap=\u0026quot;UserMap\u0026quot;\u0026gt;\rselect * from user where id = #{id}\r\u0026lt;/select\u0026gt;\r 对于简单的语句不需要配置显示的结果集映射，而对于复杂一点的语句需要描述它们的关系\n6 日志 6.1 日志工厂 如果数据库操作出现异常，需要排错，那么日志就是最好的助手\n以前可以使用sout打印，debug，现在有日志工厂\nMyBatis使用内置的日志工厂提供日志功能，可以设置具体日志实现\nSTDOUT_LOGGING\n在mybatis核心配置文件中配置日志\n\u0026lt;settings\u0026gt;\r\u0026lt;setting name=\u0026quot;logImpl\u0026quot; value=\u0026quot;STDOUT_LOGGING\u0026quot;/\u0026gt;\r\u0026lt;/settings\u0026gt;\r 可以直接使用\n6.2 LOG4J   LOG4J可以控制日志信息输送的目的地是控制台，文件，GUI组件\n  可以控制每一条日志的输出格式\n  可以定义每一条日志信息的级别\n  LOG4J在配置完后不能直接使用\n   先导入LOG4J的包  \u0026lt;dependency\u0026gt;\r\u0026lt;groupId\u0026gt;log4j\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;log4j\u0026lt;/artifactId\u0026gt;\r\u0026lt;version\u0026gt;1.2.17\u0026lt;/version\u0026gt;\r\u0026lt;/dependency\u0026gt;\r 在resource文件夹下创建log4j.properties文件  #将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码\rlog4j.rootLogger=DEBUG,console,file\r#控制台输出的相关设置\rlog4j.appender.console = org.apache.log4j.ConsoleAppender\rlog4j.appender.console.Target = System.out\rlog4j.appender.console.Threshold=DEBUG\rlog4j.appender.console.layout = org.apache.log4j.PatternLayout\rlog4j.appender.console.layout.ConversionPattern=[%c]-%m%n\r#文件输出的相关设置\rlog4j.appender.file = org.apache.log4j.RollingFileAppender\rlog4j.appender.file.File=./log/hjc.log\rlog4j.appender.file.MaxFileSize=10mb\rlog4j.appender.file.Threshold=DEBUG\rlog4j.appender.file.layout=org.apache.log4j.PatternLayout\rlog4j.appender.file.layout.ConversionPattern=[%p][%d{yy-MM-dd}][%c]%m%n\r#日志输出级别\rlog4j.logger.org.mybatis=DEBUG\rlog4j.logger.java.sql=DEBUG\rlog4j.logger.java.sql.Statement=DEBUG\rlog4j.logger.java.sql.ResultSet=DEBUG\rlog4j.logger.java.sql.PreparedStatement=DEBUG\r 配置log4j为日志实现  \u0026lt;settings\u0026gt;\r\u0026lt;setting name=\u0026quot;logImpl\u0026quot; value=\u0026quot;LOG4J\u0026quot;/\u0026gt;\r\u0026lt;/settings\u0026gt;\r log4j的使用，测试运行  简单使用\n 在要使用log4j的类中，导入包 import org.apache.log4j.Logger; 日志对象，参数为当前类的class  private static Logger logger = Logger.getLogger(UserDaoTest.class);\r 日志级别  logger.info(\u0026quot;info: 开始测试\u0026quot;);\rlogger.debug(\u0026quot;debug: 开始debug\u0026quot;);\rlogger.error(\u0026quot;error: 出现了错误\u0026quot;);\r 7 分页 如果一次查询得到的数据量太大，会产生资源浪费的后果，所以要用到分页\n 减少数据的处理量  7.1 使用limit分页 语法：select * from user limit startIndex, pageSize;\r例子：select * from user limit 1, 3;\r MyBatis中实现分页\n 编写接口，传输参数为map，map内存放start Index和pageSize  //分页查询\rList\u0026lt;User\u0026gt; getUserByLimit(Map\u0026lt;String, Integer\u0026gt; map);\r 编写对应的Mapper.xml文件  \u0026lt;select id=\u0026quot;getUserByLimit\u0026quot; parameterType=\u0026quot;map\u0026quot; resultType=\u0026quot;com.hjc.pojo.User\u0026quot;\u0026gt;\rselect * from user limit #{startIndex}, #{pageSize}\r\u0026lt;/select\u0026gt;\r 测试  @Test\rpublic void testGetUserByLimit() {\rSqlSession sqlSession = MyBatisUtils.getSqlSession();\rUserDao userDao = sqlSession.getMapper(UserDao.class);\rMap\u0026lt;String, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;();\rmap.put(\u0026quot;startIndex\u0026quot;, 1);\rmap.put(\u0026quot;pageSize\u0026quot;, 2);\rList\u0026lt;User\u0026gt; userList = userDao.getUserByLimit(map);\rfor (User user : userList)\rSystem.out.println(user);\rsqlSession.close();\r}\r 7.2 使用RowBounds分页 不在sql中使用limit，使用面向对象思想\n 编写接口  List\u0026lt;user\u0026gt; getUserByRowBounds();\r 编写对应的Mapper.xml文件  \u0026lt;select id=\u0026quot;getUserByRowBounds\u0026quot; resultType=\u0026quot;com.hjc.pojo.User\u0026quot;\u0026gt;\rselect * from user\r\u0026lt;/select\u0026gt;\r 测试  @Test\rpublic void testGetUserByRowBounds() {\rSqlSession sqlSession = MyBatisUtils.getSqlSession();\rRowBounds rowBounds = new RowBounds(1, 2);\r//不使用Mapper来查询，使用以前的selectList来查询\rList\u0026lt;User\u0026gt; userList =\rsqlSession.selectList(\u0026quot;com.hjc.dao.UserDao.getUserByRowBounds\u0026quot;, null, rowBounds);\rfor (User user : userList)\rSystem.out.println(user);\rsqlSession.close();\r}\r 7.3 使用分页插件 MyBatis分页插件PageHelper，了解\n8 使用注解 8.1 面向接口编程 在开发中，会选择面向接口编程\n 根本原因是解耦，可拓展，提高复用 分层开发中，上层不需要管具体的实现 规范性更好  关于接口的理解\n 从深层次的理解，接口是定义（规范、约束）与实现的分离 接口的本身反映了系统设计人员对系统的抽象理解 接口有两类  第一类是对一个个体的抽象，对应为一个抽象体（abstract class） 第二类是对一个个体某一方面的抽象，即形成一个抽象面（interface）   一个个体可能有多个抽象面  8.2 注解  注解在接口内方法名上标注  @Select(\u0026quot;select * from user\u0026quot;)\rList\u0026lt;User\u0026gt; getUsers();\r 需要在核心配置文件中绑定接口  \u0026lt;mappers\u0026gt;\r\u0026lt;mapper class=\u0026quot;com.hjc.dao.UserDao\u0026quot;/\u0026gt;\r\u0026lt;/mappers\u0026gt;\r 测试   本质：反射机制实现 底层：动态代理  8.3 注解实现CRUD 可以在工具类内实现自动提交事务\npublic static sqlSession getSqlSession() {\rreturn sqlSessionFactory.openSession(true);\r}\r  编写接口  public interface UserDao {\r@Select(\u0026quot;select * from user where id = #{id}\u0026quot;)\rUser getUserById(@param(\u0026quot;id\u0026quot;) int id);\r@Insert(\u0026quot;insert into user (id, name, pwd) values (#{id}, #{name}, #{pwd})\u0026quot;)\rint addUser(User user);\r@Update(\u0026quot;update user set name = #{name}, pwd = #{pwd} where id = #{id}\u0026quot;)\rint updateUser(User user);\r@Delete(\u0026quot;delete from user where id = #{uid}\u0026quot;)\rint deleteUser(@Param(\u0026quot;uid\u0026quot;) int id);\r}\r 绑定接口  \u0026lt;mappers\u0026gt;\r\u0026lt;mapper class=\u0026quot;com.hjc.dao.UserDao\u0026quot;/\u0026gt;\r\u0026lt;/mappers\u0026gt;\r 测试  关于@Param注解\n 基本类型的参数或者String类型，需要加上 引用类型不需要加 如果只有一个基本类型参数的话，可以忽略 在sql语句中使用的参数就是注解内设定的属性名  9 MyBatis执行流程 \n10 Lombok lombok是一个插件，通过注解来消除业务中冗长的代码，尤其对于POJO\n使用步骤\n 在IDEA中安装Lombok插件 在项目中导入Lombok包  \u0026lt;dependency\u0026gt;\r\u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt;\r\u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt;\r\u0026lt;version\u0026gt;1.18.10\u0026lt;/version\u0026gt;\r\u0026lt;/dependency\u0026gt;\r 在实体类上加注解  @Data @AllArgsConstructor @NoArgsConstructor ……    11 多对一关系处理 mysql中多对一查询方式\n 子查询 联表查询  假设多个学生对应一个老师，那么先分别写对应实体类\n@Data\rpublic Student implements Serializable {\rprivate int id;\rprivate String name;\r//学生需要关联一个老师\rprivate Teacher teacher;\r}\r @Data\rpublic Teacher implements Serializable {\rprivate int id;\rprivate String name;\r}\r 要查出所有学生以及对应的老师，有两种方法\n11.1 按照查询嵌套处理 思路：\n 查询所有的学生信息 根据查询出的学生tid，查询对应的老师，相当于子查询  \u0026lt;select id=\u0026quot;getStudent\u0026quot; resultMap=\u0026quot;StudentPlusTeacher\u0026quot;\u0026gt;\rselect * from student\r\u0026lt;/select\u0026gt;\r\u0026lt;resultMap id=\u0026quot;StudentPlusTeacher\u0026quot; type=\u0026quot;Student\u0026quot;\u0026gt;\r\u0026lt;!--主键--\u0026gt;\r\u0026lt;id property=\u0026quot;id\u0026quot; column=\u0026quot;id\u0026quot;/\u0026gt;\r\u0026lt;result property=\u0026quot;name\u0026quot; column=\u0026quot;name\u0026quot;/\u0026gt;\r\u0026lt;!--复杂的属性需要单独处理，对象用association，集合用collection\rjavaType表示属性的类型--\u0026gt;\r\u0026lt;association property=\u0026quot;teacher\u0026quot; column=\u0026quot;tid\u0026quot; javaType=\u0026quot;Teacher\u0026quot; select=\u0026quot;getTeacher\u0026quot;/\u0026gt;\r\u0026lt;/resultMap\u0026gt;\r\u0026lt;select id=\u0026quot;getTeacher\u0026quot; parameterType=\u0026quot;int\u0026quot; resultType=\u0026quot;Teacher\u0026quot;\u0026gt;\rselect * form teacher where id = #{id}\r\u0026lt;/select\u0026gt;\r 注：在核心配置文件中已经配置了别名，所以可以省去实体类的包路径\n11.2 按照结果嵌套处理 \u0026lt;select id=\u0026quot;getStudent\u0026quot; resultMap=\u0026quot;StudentPlusTeacher\u0026quot;\u0026gt;\rselect s.id as sid, s.name as sname, t.name as tname\rfrom student s, teacher t\rwhere s.tid = t.id\r\u0026lt;/select\u0026gt;\r\u0026lt;resultMap id=\u0026quot;StudentPlusTeacher\u0026quot; type=\u0026quot;Student\u0026quot;\u0026gt;\r\u0026lt;id property=\u0026quot;id\u0026quot; column=\u0026quot;sid\u0026quot;/\u0026gt;\r\u0026lt;result property=\u0026quot;name\u0026quot; column=\u0026quot;sname\u0026quot;/\u0026gt;\r\u0026lt;association property=\u0026quot;teacher\u0026quot; javaType=\u0026quot;Teacher\u0026quot;\u0026gt;\r\u0026lt;result property=\u0026quot;name\u0026quot; column=\u0026quot;tname\u0026quot;/\u0026gt;\r\u0026lt;/association\u0026gt;\r\u0026lt;/resultMap\u0026gt;\r 12 一对多关系处理 假设一个老师有多个学生，那么先分别写对应的实体类\n@Data\rpublic class Student implements Serializable {\rprivate int id;\rprivate String name;\rprivate int tid;\r}\r @Data\rpublic class Teacher implements Serializable {\rprivate int id;\rprivate String name;\r//一个老师有多个学生\rprivate List\u0026lt;Student\u0026gt; students;\r}\r 要查出指定老师及其对应的所有学生\n12.1 按照结果嵌套处理 \u0026lt;select id=\u0026quot;getTeacher\u0026quot; parameterType=\u0026quot;int\u0026quot; resultMap=\u0026quot;TeacherPlusStudent\u0026quot;\u0026gt;\rselect s.id as sid, s.name as sname, t.name as tname, t.id as tid\rfrom student s, teacher t\rwhere s.tid = t.id and t.id = #{tid}\r\u0026lt;/select\u0026gt;\r\u0026lt;resultMap id=\u0026quot;TeacherPlusStudent\u0026quot; type=\u0026quot;Teacher\u0026quot;\u0026gt;\r\u0026lt;id property=\u0026quot;id\u0026quot; column=\u0026quot;tid\u0026quot;/\u0026gt;\r\u0026lt;result property=\u0026quot;name\u0026quot; column=\u0026quot;tname\u0026quot;/\u0026gt;\r\u0026lt;!--复杂的属性需要单独处理，对象用association，集合用collection\rofType表示集合中的泛型信息--\u0026gt;\r\u0026lt;collection proerty=\u0026quot;students\u0026quot; ofType=\u0026quot;Student\u0026quot;\u0026gt;\r\u0026lt;id property=\u0026quot;id\u0026quot; column=\u0026quot;sid\u0026quot;/\u0026gt;\r\u0026lt;result property=\u0026quot;name\u0026quot; column=\u0026quot;sname\u0026quot;/\u0026gt;\r\u0026lt;result property=\u0026quot;tid\u0026quot; column=\u0026quot;tid\u0026quot;/\u0026gt;\r\u0026lt;/collection\u0026gt;\r\u0026lt;/resultMap\u0026gt;\r 12.2 按照查询嵌套处理 \u0026lt;select id=\u0026quot;getTeacher\u0026quot; parameterType=\u0026quot;int\u0026quot; resultMap=\u0026quot;TeacherPlusStudent\u0026quot;\u0026gt;\rselect * from teacher where id = #{tid}\r\u0026lt;/select\u0026gt;\r\u0026lt;resultMap id=\u0026quot;TeacherPlusStudent\u0026quot; type=\u0026quot;Teacher\u0026quot;\u0026gt;\r\u0026lt;collection property=\u0026quot;students\u0026quot; javaType=\u0026quot;ArrayList\u0026quot; ofType=\u0026quot;Student\u0026quot; select=\u0026quot;getStudentByTeacherId\u0026quot; column=\u0026quot;id\u0026quot;/\u0026gt;\r\u0026lt;/resultMap\u0026gt;\r\u0026lt;select id=\u0026quot;getStudentByTeacherId\u0026quot; parameter=\u0026quot;int\u0026quot; resultType=\u0026quot;Student\u0026quot;\u0026gt;\rselect * from student where tid = #{tid}\r\u0026lt;/select\u0026gt;\r 12.3 总结  关联：association，表示多对一 集合：collection，表示一对多 javaType：用来指定实体类中属性的类型 ofType：用来指定集合中的泛型信息，即集合内的pojo类型  13 动态SQL 动态SQL是指根据不同的条件生成不同的SQL语句，之前的项目写sql时，有时候会根据不同的条件拼接sql语句，现在可以使用动态SQL来实现\n参考mybatis官方文档中对于动态SQL的解释\n13.1 if \u0026lt;select id=\u0026quot;findActiveBlogWithTitleLike\u0026quot; resultType=\u0026quot;Blog\u0026quot;\u0026gt;\rSELECT * FROM BLOG\rWHERE state = ‘ACTIVE’\r\u0026lt;if test=\u0026quot;title != null\u0026quot;\u0026gt;\rAND title like #{title}\r\u0026lt;/if\u0026gt;\r\u0026lt;/select\u0026gt;\r 13.2 choose、when、otherwise 相当于switch语句\n\u0026lt;select id=\u0026quot;findActiveBlogLike\u0026quot; resultType=\u0026quot;Blog\u0026quot;\u0026gt;\rSELECT * FROM BLOG WHERE state = ‘ACTIVE’\r\u0026lt;choose\u0026gt;\r\u0026lt;when test=\u0026quot;title != null\u0026quot;\u0026gt;\rAND title like #{title}\r\u0026lt;/when\u0026gt;\r\u0026lt;when test=\u0026quot;author != null and author.name != null\u0026quot;\u0026gt;\rAND author_name like #{author.name}\r\u0026lt;/when\u0026gt;\r\u0026lt;otherwise\u0026gt;\rAND featured = 1\r\u0026lt;/otherwise\u0026gt;\r\u0026lt;/choose\u0026gt;\r\u0026lt;/select\u0026gt;\r 13.3 where、set、trim 上面几个例子，sql语句中WHERE关键字后面都跟了默认的条件state = ‘ACTIVE’，如果把这条语句删了或者改为动态SQL，那么整个SQL语句会出现问题，比如\n\u0026lt;select id=\u0026quot;findActiveBlogLike\u0026quot; resultType=\u0026quot;Blog\u0026quot;\u0026gt;\rSELECT * FROM BLOG\rWHERE\r\u0026lt;if test=\u0026quot;state != null\u0026quot;\u0026gt;\rstate = #{state}\r\u0026lt;/if\u0026gt;\r\u0026lt;if test=\u0026quot;title != null\u0026quot;\u0026gt;\rAND title like #{title}\r\u0026lt;/if\u0026gt;\r\u0026lt;if test=\u0026quot;author != null and author.name != null\u0026quot;\u0026gt;\rAND author_name like #{author.name}\r\u0026lt;/if\u0026gt;\r\u0026lt;/select\u0026gt;\r 如果if条件一个都不满足，那么sql变为\nSELECT * FROM BLOG WHERE\r 很明显，这条sql语句是错误的\n如果第一个id条件不满足，那么sql变为\nSELECT * FROM BLOG WHERE AND title like #{title} ……\r 很明显，这条sql语句也是错误的\n那么，MyBatis提供了where标签，可以解决这些问题。我们把上面的例子用where标签修改\n\u0026lt;select id=\u0026quot;findActiveBlogLike\u0026quot; resultType=\u0026quot;Blog\u0026quot;\u0026gt;\rSELECT * FROM BLOG\r\u0026lt;where\u0026gt;\r\u0026lt;if test=\u0026quot;state != null\u0026quot;\u0026gt;\rstate = #{state}\r\u0026lt;/if\u0026gt;\r\u0026lt;if test=\u0026quot;title != null\u0026quot;\u0026gt;\rAND title like #{title}\r\u0026lt;/if\u0026gt;\r\u0026lt;if test=\u0026quot;author != null and author.name != null\u0026quot;\u0026gt;\rAND author_name like #{author.name}\r\u0026lt;/if\u0026gt;\r\u0026lt;/where\u0026gt;\r\u0026lt;/select\u0026gt;\r \u0026lt;select id=\u0026quot;findActiveBlogLike\u0026quot; resultType=\u0026quot;Blog\u0026quot;\u0026gt;\rSELECT * FROM BLOG\r\u0026lt;where\u0026gt;\r\u0026lt;choose\u0026gt;\r\u0026lt;when test=\u0026quot;title != null\u0026quot;\u0026gt;\rAND title like #{title}\r\u0026lt;/when\u0026gt;\r\u0026lt;when test=\u0026quot;author != null and author.name != null\u0026quot;\u0026gt;\rAND author_name like #{author.name}\r\u0026lt;/when\u0026gt;\r\u0026lt;otherwise\u0026gt;\rAND featured = 1\r\u0026lt;/otherwise\u0026gt;\r\u0026lt;/choose\u0026gt;\r\u0026lt;/where\u0026gt;\r\u0026lt;/select\u0026gt;\r where 元素只会在子元素返回任何内容的情况下才插入 “WHERE” 子句。而且，若子句的开头为 “AND” 或 “OR”，where 元素也会将它们去除\n另外，set标签类似于where标签，会动态地设置SET关键字，同时也会删掉无关的逗号\n\u0026lt;update id=\u0026quot;updateAuthorIfNecessary\u0026quot;\u0026gt;\rupdate Author\r\u0026lt;set\u0026gt;\r\u0026lt;if test=\u0026quot;username != null\u0026quot;\u0026gt;\rusername = #{username},\r\u0026lt;/if\u0026gt;\r\u0026lt;if test=\u0026quot;password != null\u0026quot;\u0026gt;\rpassword = #{password},\r\u0026lt;/if\u0026gt;\r\u0026lt;if test=\u0026quot;email != null\u0026quot;\u0026gt;\remail = #{email},\r\u0026lt;/if\u0026gt;\r\u0026lt;if test=\u0026quot;bio != null\u0026quot;\u0026gt;\rbio = #{bio}\r\u0026lt;/if\u0026gt;\r\u0026lt;/set\u0026gt;\rwhere id = #{id}\r\u0026lt;/update\u0026gt;\r set会自动在行首插入SET关键字，并根据传进来的参数是否为空决定sql语句的结构\ntrim标签与set标签等价\n13.4 SQL片段 SQL片段：将sql语句的部分提取出来，方便复用\n\u0026lt;sql id=\u0026quot;test\u0026quot;\u0026gt;\r\u0026lt;if test=\u0026quot;state != null\u0026quot;\u0026gt;\rstate = #{state}\r\u0026lt;/if\u0026gt;\r\u0026lt;if test=\u0026quot;title != null\u0026quot;\u0026gt;\rAND title like #{title}\r\u0026lt;/if\u0026gt;\r\u0026lt;if test=\u0026quot;author != null and author.name != null\u0026quot;\u0026gt;\rAND author_name like #{author.name}\r\u0026lt;/if\u0026gt;\r\u0026lt;/sql\u0026gt;\r\u0026lt;select id=\u0026quot;findActiveBlogLike\u0026quot; resultType=\u0026quot;Blog\u0026quot;\u0026gt;\rSELECT * FROM BLOG\r\u0026lt;where\u0026gt;\r\u0026lt;include refid=\u0026quot;test\u0026quot;/\u0026gt;\r\u0026lt;/where\u0026gt;\r\u0026lt;/select\u0026gt;\r 注意：\n 最好基于单表来定义SQL片段 SQL片段内不要存在where标签  13.5 foreach 遇到IN语句的时候，可以使用foreach标签对集合进行遍历\n\u0026lt;select id=\u0026quot;selectPostIn\u0026quot; parameterType=\u0026quot;list\u0026quot; resultType=\u0026quot;domain.blog.Post\u0026quot;\u0026gt;\rSELECT *\rFROM POST P\rWHERE ID in\r\u0026lt;!--传入参数为list集合--\u0026gt;\r\u0026lt;foreach item=\u0026quot;item\u0026quot; index=\u0026quot;index\u0026quot; collection=\u0026quot;list\u0026quot; open=\u0026quot;(\u0026quot; separator=\u0026quot;,\u0026quot; close=\u0026quot;)\u0026quot;\u0026gt;\r#{item}\r\u0026lt;/foreach\u0026gt;\r\u0026lt;/select\u0026gt;\r 可以将任何可迭代对象（如 List、Set 等）、Map 对象或者数组对象作为集合参数传递给 foreach。当使用可迭代对象或者数组时，index 是当前迭代的序号，item 的值是本次迭代获取到的元素。当使用 Map 对象（或者 Map.Entry 对象的集合）时，index 是键，item 是值\n总结\n动态SQL就是在拼接SQL语句，只要保证SQL的正确性，就按照SQL的格式排列组合。先写出完整的SQL语句，再对应修改称为动态SQL实现通用\n14 缓存 14.1 简介  什么是缓存  存在内存中的临时数据 将用户经常查询的数据放在缓存中，下次查询时不用再从数据库中获取，而是从缓存中获取，从而提高查询效率，解决高并发系统的性能问题   为什么使用缓存  减少和数据库的交互次数，减少系统开销，提高系统效率   什么数据能使用缓存  经常查询且不经常改变的数据    14.2 MyBatis缓存  MyBatis包含一个强大的查询缓存特性，可以非常方便地定制和配置缓存 MyBatis默认定义了两级缓存：一级缓存和二级缓存  默认情况下，只有一级缓存开启（SqlSession级别的缓存，也称为本地缓存） 二级缓存需要手动开启和配置，是基于namespace级别的缓存 MyBatis定义了缓存接口Cache，可以通过实现Cache接口来自定义二级缓存    14.3 缓存原理 \n14.4 一级缓存  一级缓存也叫本地缓存：SqlSession  相当于一个map 和数据库同一次会话（同一次SqlSession）期间查询到的数据会放在本地缓存中 以后如果要获取相同的数据，可以直接从缓存中取，不需要从数据库中查询    测试\n@Test\rpublic void test() {\rSqlSession sqlSession = MyBatisUtils.getSqlSession();\rUserDao userDao = sqlSession.getMapper(UserDao.class);\rUser user1 = userDao.getUserById(1);\rUser user2 = userDao.getUserById(1);\rSystem.out.println(user1 == user2);\rsqlSession.close();\r}\r 根据日志，我们可以看到sql只执行了一次，user1和user2是同一个\n 缓存失效的情况  查询不同的数据 增删改操作可能会改变原来的数据，缓存会刷新 使用不同的Mapper进行查询 手动清除缓存    14.5 二级缓存  二级缓存也叫全局缓存，作用域比一级缓存要大 基于namespace级别的缓存，一个命名空间对应一个二级缓存 工作机制  一次会话查询一条数据，这个数据会被放在当前会话的一级缓存中 如果当前会话关闭了，那么对应的一级缓存就没了。但是二级缓存开启后，会话关闭之后，一级缓存中的数据会保存到二级缓存中 新的会话查询数据，就可以从二级缓存中获取数据 不同的Mapper查出的数据会放在对应的缓存中    步骤\n 在核心配置文件中开启全局缓存  \u0026lt;settings\u0026gt;\r\u0026lt;setting name=\u0026quot;cacheEnabled\u0026quot; value=\u0026quot;true\u0026quot;/\u0026gt;\r\u0026lt;/settings\u0026gt;\r 在要使用二级缓存的Mapper.xml中开启二级缓存，可以自定义缓存属性  \u0026lt;cache eviction=\u0026quot;FIFO\u0026quot; flushInterval=\u0026quot;60000\u0026quot; size=\u0026quot;512\u0026quot; readOnly=\u0026quot;true\u0026quot;/\u0026gt;\r 测试  @Test\rpublic void test() {\rSqlSession sqlSession1 = MyBatisUtils.getSqlSession();\rUserDao userDao1 = sqlSession1.getMapper(UserDao.class);\rUser user1 = userDao1.getUserById(1);\rsqlSession1.close();\r//只有sqlSession1关闭后，一级缓存内的数据才会进入二级缓存\rSqlSession sqlSession2 = MyBatisUtils.getSqlSession();\rUserDao userDao2 = sqlSession2.getMapper(UserDao.class);\rUser user2 = userDao2.getUserById(1);\rsqlSession2.close();\rSystem.out.println(user1 == user2);\r}\r 根据日志可以看到sql只执行了一次，且查到的User对象是同一个\n注意：\n 二级缓存对同一个Mapper下的数据才能起到提高效率的效果 数据会先放在一级缓存中，只有当会话提交或者关闭后，才会放到二级缓存中  14.6 自定义缓存EhCache 可以使用自定义的缓存，也可以使用第三方的缓存\n","date":"2020-07-11","permalink":"https://example.com/post/study-mybatis/","tags":["mybatis","java"],"title":"MyBatis学习笔记"},{"content":"最近在重温JavaWeb的内容，特此记录一下。\n1 基本概念 1.1 前言 web开发：\n 静态web  html，css 提供给所有人看的数据始终不会变化   动态web  几乎所有网站，淘宝 提供给所有人看的数据始终会发生变化，每个人在不同的时间、不同的地点看到的信息各不相同 servlet/jsp，asp，php    1.2 web应用程序 可以提供浏览器访问的程序\n a.html、b.html等多个web资源，这些web资源可以被外界访问，对外界提供服务 能访问到的任何一个页面或者资源，都存在于世界某个地方的计算机上 url 统一的web资源会被放在同一个文件夹下，web应用程序—\u0026gt;Tomcat服务器 一个web应用有多个部分组成（静态web、动态web）  html，css，js jsp，servlet Java程序 jar包 配置文件（properties，xml）   web应用程序编写完后，若想要提供给外部访问，需要一个服务器来统一管理  1.3 静态web   *.html，*.html这些都是网站的资源，如果服务器上一直存在这些资源，我们就可以直接进行读取，需要网络\n\n  静态web的缺点\n web页面无法动态更新，所有用户看到的都是一个页面  轮播图，点击特效：伪动态 JavaScript   无法和数据库交互（数据无法持久化，用户无法交互）    1.4 动态web  页面会动态展示，web页面的展示效果因人而异  \n  动态web的缺点\n 如果服务器的动态web资源出现了错误，需要重新编写后台程序，重新发布 停机维护    动态web的优点\n  web页面可以动态更新，所有用户看到的不是同一个页面\n  可以与数据库交互\n\n    2 Web服务器 2.1 技术讲解 ASP  微软：国内最早流行的就是ASP 在html中嵌入了VB的脚本，ASP+COM 在ASP开发中，基本一个页面有几千行的业务代码，页面混乱 维护成本高 C# IIS  PHP  php开发速度很快，功能强大，跨平台，代码简单 无法承载大访问量的情况  servlet/jsp  sun公司主推的B/S架构 基于Java语言 可以承载三高问题带来的影响 语法像ASP  2.2 web服务器 服务器是一种被动的操作，用来处理用户的一些请求和给用户一些响应信息\n IIS，微软的 Tomcat  3 Tomcat 3.1 安装Tomcat 3.2 Tomcat启动 3.3 Tomcat配置 网站是如何进行访问的\n 输入一个域名，回车 检查本机的hosts配置文件内是否存在域名映射  有：直接访问对应的ip地址，找到需要访问的web程序，可以直接访问 没有：去DNS服务器找对应的ip地址，找到则返回    3.4 发布web网站   将自己写的网站，放到服务器（Tomcat）指定的web应用的文件夹（webapps）下，就可以访问了\n  网站应有的架构\n  --webapps ：Tomcat服务器的web目录\r-ROOT\r-testweb ：网站的目录名\r- WEB-INF\r-classes : java程序\r-lib：web应用所依赖的jar包\r-web.xml ：网站配置文件\r- index.html 默认的首页\r- static -css\r-style.css\r-js\r-img\r-.....\r 4 HTTP 4.1 什么是HTTP 超文本传输协议是一个简单的请求-响应协议，通常运行在TCP之上\n 文本：html，字符串，…… 超文本：图片，音乐，视频，定位，地图，…… 端口：80  HTTPS：安全的\n4.2 两个版本  http 1.0  HTTP/1.0：客户端与web服务器连接后，只能获得一个web资源   http 2.0  HTTP/2.0：客户端与web服务器连接后，可以获得多个web资源    4.3 HTTP请求  客户端—request—服务器  Request URL:https://www.baidu.com/ 请求地址\rRequest Method:GET get方法/post方法\rStatus Code:200 OK 状态码：200\rRemote（远程） Address:14.215.177.39:443\rAccept:text/html Accept-Encoding:gzip, deflate, br\rAccept-Language:zh-CN,zh;q=0.9 语言\rCache-Control:max-age=0\rConnection:keep-alive\r 请求行  请求行中的请求方式：GET 请求方式：GET，POST，HEAD，DELETE，PUT，TRACT，……  GET：请求能够携带的参数比较少，大小有限制，会在浏览器的URL地址栏显示数据内容，不安全，但高效 POST：请求能够携带的参数没有限制，大小没有限制，不会在浏览器的URL地址栏显示数据内容，安全，但不高效    消息头 Accept:告诉浏览器支持的数据类型\rAccept-Encoding:支持哪种编码格式 GBK\tUTF-8\tGB2312\tISO8859-1\rAccept-Language:告诉浏览器语言环境\rCache-Control:缓存控制\rConnection:告诉浏览器请求完成是断开还是保持连接\rHOST：主机\r 4.4 HTTP响应  服务器—response—客户端  响应体 Accept：告诉浏览器支持的数据类型\rAccept-Encoding：支持哪种编码格式 GBK UTF-8 GB2312 ISO8859-1\rAccept-Language：告诉浏览器语言环境\rCache-Control：缓存控制\rConnection：告诉浏览器请求完成是断开还是保持连接\rHOST：主机\rRefresh：告诉客户端，多久刷新一次\rLocation：让网页重新定位\r 响应状态码  200：请求响应成功 3xx：请求重定向 4xx：找不到资源404 5xx：服务器代码错误500，502：网关错误  5 Maven 在JavaWeb开发中，需要使用大量的jar包，手动导入很繁琐，如何自动导入和配置jar包\n5.1 项目架构管理工具 Maven的核心思想：约定大于配置。Maven会规定如何编写Java代码\n5.2 下载安装Maven 5.3 配置环境变量 5.4 配置阿里云镜像 6 Servlet 6.1 Servlet简介  Servlet是sun公司开发动态web的一门技术 sun在这些api中提供一个接口叫做Servlet，如果想开发一个Servlet程序，只需要  编写一个类，实现Servlet接口 把开发好的Java类部署到服务器中   把实现了Servlet接口的Java程序叫做Servlet  6.2 HelloServlet   构建一个普通的Maven项目\n  编写一个Serlvet程序\n 编写一个普通类 实现Servlet接口，这里直接继承HttpServlet    public class HelloServlet extends HttpServlet {\r//由于get或者post只是请求实现的不同的方式，可以相互调用，业务逻辑都一样；\r@Override\rprotected void doGet(HttpServletRequest req, HttpServletResponse resp)\rthrows ServletException, IOException {\r//ServletOutputStream outputStream = resp.getOutputStream();\rPrintWriter writer = resp.getWriter(); //响应流\rwriter.print(\u0026quot;Hello,Serlvet\u0026quot;);\r}\r@Override\rprotected void doPost(HttpServletRequest req, HttpServletResponse resp)\rthrows ServletException, IOException {\rdoGet(req, resp);\r}\r}\r  编写Servlet的映射\n为什么需要映射，我们写的是Java程序，但是要通过浏览器访问，而浏览器需要连接web服务器，所以我们需要在web服务中注册我们写的Servlet，还需要定义一个浏览器能够访问的路径\n  \u0026lt;!--注册Servlet--\u0026gt;\r\u0026lt;servlet\u0026gt;\r\u0026lt;servlet-name\u0026gt;hello\u0026lt;/servlet-name\u0026gt;\r\u0026lt;servlet-class\u0026gt;com.hjc.servlet.HelloServlet\u0026lt;/servlet-class\u0026gt;\r\u0026lt;/servlet\u0026gt;\r\u0026lt;!--Servlet的请求路径--\u0026gt;\r\u0026lt;servlet-mapping\u0026gt;\r\u0026lt;servlet-name\u0026gt;hello\u0026lt;/servlet-name\u0026gt;\r\u0026lt;url-pattern\u0026gt;/hello\u0026lt;/url-pattern\u0026gt;\r\u0026lt;/servlet-mapping\u0026gt;\r  配置Tomcat\n  启动测试\n  6.3 Servlet原理 Servlet是由web服务器在收到浏览器请求后调用\n\n6.4 Mapping问题  一个servlet可以指定一个映射路径  \u0026lt;servlet-mapping\u0026gt;\r\u0026lt;servlet-name\u0026gt;hello\u0026lt;/servlet-name\u0026gt;\r\u0026lt;url-pattern\u0026gt;/hello\u0026lt;/url-pattern\u0026gt;\r\u0026lt;/servlet-mapping\u0026gt;\r 一个servlet可以指定多个映射路径  \u0026lt;servlet-mapping\u0026gt;\r\u0026lt;servlet-name\u0026gt;hello\u0026lt;/servlet-name\u0026gt;\r\u0026lt;url-pattern\u0026gt;/hello\u0026lt;/url-pattern\u0026gt;\r\u0026lt;/servlet-mapping\u0026gt;\r\u0026lt;servlet-mapping\u0026gt;\r\u0026lt;servlet-name\u0026gt;hello\u0026lt;/servlet-name\u0026gt;\r\u0026lt;url-pattern\u0026gt;/hello2\u0026lt;/url-pattern\u0026gt;\r\u0026lt;/servlet-mapping\u0026gt;\r\u0026lt;servlet-mapping\u0026gt;\r\u0026lt;servlet-name\u0026gt;hello\u0026lt;/servlet-name\u0026gt;\r\u0026lt;url-pattern\u0026gt;/hello3\u0026lt;/url-pattern\u0026gt;\r\u0026lt;/servlet-mapping\u0026gt;\r\u0026lt;servlet-mapping\u0026gt;\r\u0026lt;servlet-name\u0026gt;hello\u0026lt;/servlet-name\u0026gt;\r\u0026lt;url-pattern\u0026gt;/hello4\u0026lt;/url-pattern\u0026gt;\r\u0026lt;/servlet-mapping\u0026gt;\r\u0026lt;servlet-mapping\u0026gt;\r\u0026lt;servlet-name\u0026gt;hello\u0026lt;/servlet-name\u0026gt;\r\u0026lt;url-pattern\u0026gt;/hello5\u0026lt;/url-pattern\u0026gt;\r\u0026lt;/servlet-mapping\u0026gt;\r 一个servlet可以指定通用映射路径  \u0026lt;servlet-mapping\u0026gt;\r\u0026lt;servlet-name\u0026gt;hello\u0026lt;/servlet-name\u0026gt;\r\u0026lt;url-pattern\u0026gt;/hello/*\u0026lt;/url-pattern\u0026gt;\r\u0026lt;/servlet-mapping\u0026gt;\r 默认请求路径  \u0026lt;!--默认请求路径--\u0026gt;\r\u0026lt;servlet-mapping\u0026gt;\r\u0026lt;servlet-name\u0026gt;hello\u0026lt;/servlet-name\u0026gt;\r\u0026lt;url-pattern\u0026gt;/*\u0026lt;/url-pattern\u0026gt;\r\u0026lt;/servlet-mapping\u0026gt;\r 指定一些后缀或者前缀  \u0026lt;!--可以自定义后缀实现请求映射\r注意点，*前面不能加项目映射的路径\rhello/sajdlkajda.do\r--\u0026gt;\r\u0026lt;servlet-mapping\u0026gt;\r\u0026lt;servlet-name\u0026gt;hello\u0026lt;/servlet-name\u0026gt;\r\u0026lt;url-pattern\u0026gt;*.do\u0026lt;/url-pattern\u0026gt;\r\u0026lt;/servlet-mapping\u0026gt;\r 优先级问题  指定了固有的映射路径优先级最高，如果找不到就会走默认的处理请求\n\u0026lt;!--404--\u0026gt;\r\u0026lt;servlet\u0026gt;\r\u0026lt;servlet-name\u0026gt;error\u0026lt;/servlet-name\u0026gt;\r\u0026lt;servlet-class\u0026gt;com.hjc.servlet.ErrorServlet\u0026lt;/servlet-class\u0026gt;\r\u0026lt;/servlet\u0026gt;\r\u0026lt;servlet-mapping\u0026gt;\r\u0026lt;servlet-name\u0026gt;error\u0026lt;/servlet-name\u0026gt;\r\u0026lt;url-pattern\u0026gt;/*\u0026lt;/url-pattern\u0026gt;\r\u0026lt;/servlet-mapping\u0026gt;\r 6.5 ServletContext web容器在启动的时候，它会为每个web程序都创建一个对应的ServletContext对象，代表当前的web应用\n1. 共享数据 在一个servlet中保存的数据，可以在另一个servlet中得到\npublic class HelloServlet extends HttpServlet {\r@Override\rprotected void doGet(HttpServletRequest req, HttpServletResponse resp)\rthrows ServletException, IOException {\r//this.getInitParameter() 初始化参数\r//this.getServletConfig() Servlet配置\r//this.getServletContext() Servlet上下文\rServletContext context = this.getServletContext();\rString username = \u0026quot;hjc\u0026quot;; //数据\rcontext.setAttribute(\u0026quot;username\u0026quot;,username); //将一个数据保存在了ServletContext中，名字为username，值为username\r}\r}\r public class GetServlet extends HttpServlet {\r@Override\rprotected void doGet(HttpServletRequest req, HttpServletResponse resp)\rthrows ServletException, IOException {\rServletContext context = this.getServletContext();\rString username = (String) context.getAttribute(\u0026quot;username\u0026quot;);\rresp.setContentType(\u0026quot;text/html\u0026quot;);\rresp.setCharacterEncoding(\u0026quot;utf-8\u0026quot;);\rresp.getWriter().print(\u0026quot;名字\u0026quot;+username);\r}\r}\r \u0026lt;servlet\u0026gt;\r\u0026lt;servlet-name\u0026gt;hello\u0026lt;/servlet-name\u0026gt;\r\u0026lt;servlet-class\u0026gt;com.hjc.servlet.HelloServlet\u0026lt;/servlet-class\u0026gt;\r\u0026lt;/servlet\u0026gt;\r\u0026lt;servlet-mapping\u0026gt;\r\u0026lt;servlet-name\u0026gt;hello\u0026lt;/servlet-name\u0026gt;\r\u0026lt;url-pattern\u0026gt;/hello\u0026lt;/url-pattern\u0026gt;\r\u0026lt;/servlet-mapping\u0026gt;\r\u0026lt;servlet\u0026gt;\r\u0026lt;servlet-name\u0026gt;get\u0026lt;/servlet-name\u0026gt;\r\u0026lt;servlet-class\u0026gt;com.hjc.servlet.GetServlet\u0026lt;/servlet-class\u0026gt;\r\u0026lt;/servlet\u0026gt;\r\u0026lt;servlet-mapping\u0026gt;\r\u0026lt;servlet-name\u0026gt;get\u0026lt;/servlet-name\u0026gt;\r\u0026lt;url-pattern\u0026gt;/get\u0026lt;/url-pattern\u0026gt;\r\u0026lt;/servlet-mapping\u0026gt;\r 2. 获取初始化参数 \u0026lt;!--配置一些web应用初始化参数--\u0026gt;\r\u0026lt;context-param\u0026gt;\r\u0026lt;param-name\u0026gt;url\u0026lt;/param-name\u0026gt;\r\u0026lt;param-value\u0026gt;jdbc:mysql://localhost:3306/mybatis\u0026lt;/param-value\u0026gt;\r\u0026lt;/context-param\u0026gt;\r public class HelloServlet extends HttpServlet {\r@Override\rprotected void doGet(HttpServletRequest req, HttpServletResponse resp)\rthrows ServletException, IOException {\rServletContext context = this.getServletContext();\rString url = context.getInitParameter(\u0026quot;url\u0026quot;);\rresp.getWriter().print(url);\r}\r}\r 3. 请求转发 public class HelloServlet extends HttpServlet {\r@Override\rprotected void doGet(HttpServletRequest req, HttpServletResponse resp)\rthrows ServletException, IOException {\rServletContext context = this.getServletContext();\rcontext.getRequestDispatcher(\u0026quot;/gp\u0026quot;).forward(req, resp);\t// gp为转发路径\r}\r}\r 4. 读取资源文件 Properties\n 在java目录下新建properties 在resources目录下新建properties  username=root\rpassword=123456\r public class ServletDemo extends HttpServlet {\r@Override\rprotected void doGet(HttpServletRequest req, HttpServletResponse resp)\rthrows ServletException, IOException {\rInputStream is = this.getServletContext()\r.getResourceAsStream(\u0026quot;/WEB-INF/classes/com/hjc/servlet/test.properties\u0026quot;);\rProperties prop = new Properties();\rprop.load(is);\rString user = prop.getProperty(\u0026quot;username\u0026quot;);\rString pwd = prop.getProperty(\u0026quot;password\u0026quot;);\rresp.getWriter().print(user+\u0026quot;:\u0026quot;+pwd);\r}\r@Override\rprotected void doPost(HttpServletRequest req, HttpServletResponse resp)\rthrows ServletException, IOException {\rdoGet(req, resp);\r}\r}\r 6.6 HttpServletResponse  web服务器接收到客户端的http请求，针对这个请求，分别创建一个代表请求的HttpServletRequest对象和代表相应的HttpServletResponse对象 如果要获取客户端请求过来的参数，找HttpServletRequest 如果要给客户端响应一些信息，找HttpServletResponse  1. 简单分类 负责向浏览器发送数据的方法\nservletOutputstream getOutputstream() throws IOException;\rPrintwriter getwriter() throws IOException;\r 负责向浏览器发送响应头的方法\nvoid setCharacterEncoding(String var1)；\rvoid setContentLength(int var1)；\rvoid setContentLengthLong(long var1);\rvoid setContentType(String var1)；\rvoid setDateHeader(String varl,long var2)\rvoid addDateHeader(String var1,long var2)\rvoid setHeader(String var1,String var2);\rvoid addHeader(String var1,String var2)；\rvoid setIntHeader(String var1,int var2);\rvoid addIntHeader(String varl,int var2);\r 2. 下载文件  向浏览器输出消息 下载文件  获取下载文件的路径 获取下载文件的文件名 设置让浏览器支持下载需要的东西 获取下载文件的输入流 创建缓冲区 获取OutputStream对象 将FileOutputStream流写入到buffer缓冲区 使用OutputStream将缓冲区内的数据输出到客户端    @Override\rprotected void doGet(HttpServletRequest req, HttpServletResponse resp)\rthrows ServletException, IOException {\r// 1. 要获取下载文件的路径\rString realPath = path;\t//路径\rSystem.out.println(\u0026quot;下载文件的路径：\u0026quot;+realPath);\r// 2. 下载的文件名是啥？\rString fileName = realPath.substring(realPath.lastIndexOf(\u0026quot;\\\\\u0026quot;) + 1);\r// 3. 设置想办法让浏览器能够支持(Content-Disposition)下载我们需要的东西,中文文件名URLEncoder.encode编码，否则有可能乱码\rresp.setHeader(\u0026quot;Content-Disposition\u0026quot;,\u0026quot;attachment;filename=\u0026quot;+URLEncoder.encode(fileName,\u0026quot;UTF-8\u0026quot;));\r// 4. 获取下载文件的输入流\rFileInputStream in = new FileInputStream(realPath);\r// 5. 创建缓冲区\rint len = 0;\rbyte[] buffer = new byte[1024];\r// 6. 获取OutputStream对象\rServletOutputStream out = resp.getOutputStream();\r// 7. 将FileOutputStream流写入到buffer缓冲区,使用OutputStream将缓冲区中的数据输出到客户端！\rwhile ((len=in.read(buffer))\u0026gt;0){\rout.write(buffer,0,len);\r}\rin.close();\rout.close();\r}\r 3. 验证码功能 验证码实现\n 前端实现 后端实现，需要用到Java的图片类，生产一个图片  public class ImageServlet extends HttpServlet {\r@Override\rprotected void doGet(HttpServletRequest req, HttpServletResponse resp)\rthrows ServletException, IOException {\r//如何让浏览器3秒自动刷新一次;\rresp.setHeader(\u0026quot;refresh\u0026quot;,\u0026quot;3\u0026quot;);\r//在内存中创建一个图片\rBufferedImage image = new BufferedImage(80,20,BufferedImage.TYPE_INT_RGB);\r//得到图片\rGraphics2D g = (Graphics2D) image.getGraphics(); //笔\r//设置图片的背景颜色\rg.setColor(Color.white);\rg.fillRect(0,0,80,20);\r//给图片写数据\rg.setColor(Color.BLUE);\rg.setFont(new Font(null,Font.BOLD,20));\rg.drawString(makeNum(),0,20);\r//告诉浏览器，这个请求用图片的方式打开\rresp.setContentType(\u0026quot;image/jpeg\u0026quot;);\r//网站存在缓存，不让浏览器缓存\rresp.setDateHeader(\u0026quot;expires\u0026quot;,-1);\rresp.setHeader(\u0026quot;Cache-Control\u0026quot;,\u0026quot;no-cache\u0026quot;);\rresp.setHeader(\u0026quot;Pragma\u0026quot;,\u0026quot;no-cache\u0026quot;);\r//把图片写给浏览器\rImageIO.write(image,\u0026quot;jpg\u0026quot;, resp.getOutputStream());\r}\r//生成随机数\rprivate String makeNum(){\rRandom random = new Random();\rString num = random.nextInt(9999999) + \u0026quot;\u0026quot;;\rStringBuffer sb = new StringBuffer();\rfor (int i = 0; i \u0026lt; 7-num.length() ; i++) {\rsb.append(\u0026quot;0\u0026quot;);\r}\rnum = sb.toString() + num;\rreturn num;\r}\r@Override\rprotected void doPost(HttpServletRequest req, HttpServletResponse resp)\rthrows ServletException, IOException {\rdoGet(req, resp);\r}\r}\r \u0026lt;servlet\u0026gt;\r\u0026lt;servlet-name\u0026gt;ImageServlet\u0026lt;/servlet-name\u0026gt;\r\u0026lt;servlet-class\u0026gt;com.hjc.servlet.ImageServlet\u0026lt;/servlet-class\u0026gt;\r\u0026lt;/servlet\u0026gt;\r\u0026lt;servlet-mapping\u0026gt;\r\u0026lt;servlet-name\u0026gt;ImageServlet\u0026lt;/servlet-name\u0026gt;\r\u0026lt;url-pattern\u0026gt;/img\u0026lt;/url-pattern\u0026gt;\r\u0026lt;/servlet-mapping\u0026gt;\r 4. 实现重定向 void sendRedirect(String var1) throws IOException;\r 常见场景\n 用户登录  @Override\rprotected void doGet(HttpservletRequest req, HttpservletResponse resp)\rthrows ServletException, IOException {\rresp.sendRedirect(\u0026quot;/r/img\u0026quot;);//重定向\r/*\rresp.setHeader(\u0026quot;Location\u0026quot;,\u0026quot;/r/img\u0026quot;);\rresp.setstatus(302);\r*/\r}\r 测试\nindex.jsp\n\u0026lt;html\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;h2\u0026gt;Hel1o World!\u0026lt;/h2\u0026gt;\r\u0026lt;%--这里超交的路径,需要寻找到项目的路径--%\u0026gt;\r\u0026lt;%--${pageContext.request.contextPath}代表当前的项目--%\u0026gt;\r\u0026lt;form action=\u0026quot;${pageContext.request.contextPath}/login\u0026quot; method=\u0026quot;get\u0026quot;\u0026gt;\r用户名: \u0026lt;input type=\u0026quot;text\u0026quot; name=\u0026quot;username\u0026quot;\u0026gt; \u0026lt;br\u0026gt;\r密码: \u0026lt;input type=\u0026quot;password\u0026quot; name=\u0026quot;password\u0026quot;\u0026gt; \u0026lt;br\u0026gt;\r\u0026lt;input type=\u0026quot;submit\u0026quot;\u0026gt;\r\u0026lt;/form\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r RequestTest.java\npublic class RequestTest extends HttpServlet {\r@Override\rprotected void doGet(HttpServletRequest req, HttpServletResponse resp)\rthrows ServletException, IOException {\r//处理方求\rString username = req.getParameter(\u0026quot;username\u0026quot;);\rString password rea.getParameter(\u0026quot;password\u0026quot;);\rSystem.out.println(username+\u0026quot;:\u0026quot;+password);\rresp.sendRedirect(\u0026quot;/r/success.jsp\u0026quot;);\r}\r success.jsp\n\u0026lt;%@ page contentType=\u0026quot;text/html; charset=UTF-8\u0026quot; language=\u0026quot;java\u0026quot; %\u0026gt;\r\u0026lt;html\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;h1\u0026gt;success\u0026lt;/h1\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r web.xml配置\n\u0026lt;servlet\u0026gt;\r\u0026lt;servlet-name\u0026gt;requset\u0026lt;/servlet-name\u0026gt;\r\u0026lt;servlet-class\u0026gt;com.hjc.servlet.RequestTest\u0026lt;/servlet-class\u0026gt;\r\u0026lt;/servlet\u0026gt;\r\u0026lt;servlet-mapping\u0026gt;\r\u0026lt;servlet-name\u0026gt;requset\u0026lt;/servlet-name\u0026gt;\r\u0026lt;url-pattern\u0026gt;/login\u0026lt;/url-pattern\u0026gt;\r\u0026lt;/servlet-mapping\u0026gt;\r 6.7 HttpServletRequest HttpServletRequest代表客户端的请求，用户通过Http协议访问服务器，Http请求中的所有信息都会被封装到HttpServletRequest，通过这个HttpServletRequest的方法获得客户端的所有信息\n1. 获取参数 2. 请求转发 @Override\rprotected void doGet(HttpservletRequest req. HttpservletResponse resp)\rthrows ServletException, IOException {\rreq.setcharacterEncoding(\u0026quot;utf-8\u0026quot;);\rresp.setcharacterEncoding(\u0026quot;utf-8\u0026quot;);\rString username = req.getParameter(\u0026quot;username\u0026quot;);\rString password = req.getParameter(\u0026quot;password\u0026quot;);\rString[] hobbies = req.getParameterValues(\u0026quot;hobbys\u0026quot;);\rSystem.out.println(\u0026quot;==========\u0026quot;);\r//后台接收中文乱码问题\rSystem.out.println(username);\rSystem.out.println(password);\rSystem.out.println(Arrays.tostring(hobbys));\rSystem.out.println(\u0026quot;============\u0026quot;);\rsystem.out.println(req.getContextPath());\r//通过请求转发\r//这里的/代表当前的web应用\rreq.getRequestDispatcher(\u0026quot;/success.jsp\u0026quot;).forward(req,resp);\r}\r 重定向和和请求转发的区别  相同点  页面都会实现跳转   不同点  请求转发的时候，url不会发生变化，是同一个请求 重定向的时候，url会发生变化，是不同请求    \n7 Cookie、Session 7.1 会话 会话：用户打开一个浏览器，点击多个超链接，访问多个web资源，关闭浏览器，这个过程可以称为会话\n有状态会话：一个同学来过教室，下次再来教室，我们会知道这个同学，曾经来过，称为有状态会话\n7.2 保存会话的两种技术 那么，一个网站，如何证明访问过\n 客户端 cookie  服务端给客户端一个信件，客户端下次访问服务器带上信件就可以了   服务端 session  服务器登记访问过，下次访问的时候匹配登记信息    常见情况：网站登录后，下次访问不用再次登录\n7.3 Cookie  从请求中拿到cookie信息 服务器响应给客户端cookie  Cookie[] cookies = req.getCookies(); //获得Cookie\rcookie.getName(); //获得cookie中的key\rcookie.getValue(); //获得cookie中的vlaue\rnew Cookie(\u0026quot;lastLoginTime\u0026quot;, System.currentTimeMillis()+\u0026quot;\u0026quot;); //新建一个cookie\rcookie.setMaxAge(24*60*60); //设置cookie的有效期\rresp.addCookie(cookie); //响应给客户端一个cookie\r cookie一般会保存在本地的用户目录下appdata\n一个网站的cookie存在上限\n 一个cookie只能保存一个信息 一个web站点可以给浏览器发送多个cookie，最多存放20个 cookie大小有限制 4kb 浏览器有cookie上限 300个  删除cookie  自动删除  不设置有效期，关闭浏览器，自动失效 设置有效时间为0   手动删除    7.4 Session（重要）  服务器会给每个用户（浏览器）创建一个Session对象 一个Session独占一个浏览器，只要浏览器没有关闭，这个Session就存在 用户登录后，整个网站都可以访问  保存用户信息 保存购物车信息    Session和Cookie的区别\n Cookie是把用户的数据写给用户的浏览器，浏览器保存 Session是把用户的数据写到用户独占的Session中，服务器保存  使用Session public class SessionDemo extends HttpServlet {\r@Override\rprotected void doGet(HttpServletRequest req, HttpServletResponse resp)\rthrows ServletException, IOException {\r//解决乱码问题\rreq.setCharacterEncoding(\u0026quot;UTF-8\u0026quot;);\rresp.setCharacterEncoding(\u0026quot;UTF-8\u0026quot;);\rresp.setContentType(\u0026quot;text/html;charset=utf-8\u0026quot;);\r//得到Session\rHttpSession session = req.getSession();\r//给Session中存东西\rsession.setAttribute(\u0026quot;name\u0026quot;,new Person(\u0026quot;admin\u0026quot;,1));\r//获取Session的ID\rString sessionId = session.getId();\r//判断Session是不是新创建\rif (session.isNew()){\rresp.getWriter().write(\u0026quot;session创建成功,ID:\u0026quot;+sessionId);\r}else {\rresp.getWriter().write(\u0026quot;session以及在服务器中存在了,ID:\u0026quot;+sessionId);\r}\r//Session创建的时候做了什么事情；\r//Cookie cookie = new Cookie(\u0026quot;JSESSIONID\u0026quot;,sessionId);\r//resp.addCookie(cookie);\r}\r@Override\rprotected void doPost(HttpServletRequest req, HttpServletResponse resp)\rthrows ServletException, IOException {\rdoGet(req, resp);\r}\r}\r 得到Session //得到Session\rHttpSession session = req.getSession();\rPerson person = (Person) session.getAttribute(\u0026quot;name\u0026quot;);\rSystem.out.println(person.toString());\r 注销Session  手动注销  HttpSession session = req.getSession();\rsession.removeAttribute(\u0026quot;name\u0026quot;);\r//手动注销Session\rsession.invalidate();\r  自动注销（会话自动过期）  \u0026lt;!--设置Session默认的失效时间--\u0026gt;\r\u0026lt;session-config\u0026gt;\r\u0026lt;!--15分钟后Session自动失效，以分钟为单位--\u0026gt;\r\u0026lt;session-timeout\u0026gt;15\u0026lt;/session-timeout\u0026gt;\r\u0026lt;/session-config\u0026gt;\r 8 JSP（不重要） 8.1 什么是JSP Java Server Pages：Java服务器端页面，和Servlet一样，用于动态Web技术\n最大的特点\n 写JSP就像在写HTML 区别  HTML只给用户提供静态的数据 JSP页面中可以嵌入Java代码，为用户提供动态数据    8.2 JSP原理 JSP本质上就是一个Servlet，浏览器向服务器发送请求，不管访问什么资源，其实都是在访问Servlet\n//初始化\rpublic void _jspInit() {}\r//销毁\rpublic void _jspDestroy() {}\r//JSPService\rpublic void _jspService(HttpServletRequest request, HttpServletResponse response) {}\r 略 9 JavaBean 实体类\nJavaBean有特定的写法\n 必须要有一个无参构造函数 属性必须私有化 必须有对应的get/set方法  一般用来和数据库的字段做映射 ORM\n ORM：对象关系映射  表 —\u0026gt; 类 字段 —\u0026gt; 属性 行记录 —\u0026gt; 对象    10 MVC三层架构 MVC：Model、View、Controller 模型、视图、控制器\n10.1 以前的架构 \n用户直接访问控制层，控制层就可以直接操作数据库\nservlet--CRUD--\u0026gt;数据库\r弊端：程序十分臃肿，不利于维护 servlet的代码中：处理请求、响应、视图跳转、处理JDBC、处理业务代码、处理逻辑代码\r架构：没有什么是加一层解决不了的！\r程序猿调用\r↑\rJDBC （实现该接口）\r↑\rMysql/Oracle/SqlServer ....（不同厂商）\r 10.2 MVC三层架构 \nModel\n 业务处理：实现业务逻辑（Service） 数据持久层：CRUD（Dao - 数据持久化对象）  View\n 展示数据 提供链接发起Servlet请求（a、form、img …）  Controller（Servlet）\n 接收用户的请求（req：请求参数、Session信息） 交给业务层处理对应的代码 控制视图的跳转  登录 ---\u0026gt; 接收用户的登录请求 ---\u0026gt; 处理用户的请求（获取用户登录的参数，username，password）\r---\u0026gt; 交给业务层处理登录业务（判断用户名密码是否正确：事务）\r---\u0026gt; Dao层查询用户名和密码是否正确 ---\u0026gt; 数据库\r 11 Filter（重要） 过滤器，用来过滤网站的数据\n 处理中文乱码 登陆验证  \nFilter开发步骤\n  导包\n  编写过滤器\n 实现Filter接口，重写对应方法  public class CharacterEncodingFilter implements Filter {\r//初始化：web服务器启动，就以及初始化了，随时等待过滤对象出现！\rpublic void init(FilterConfig filterConfig) throws ServletException {\rSystem.out.println(\u0026quot;CharacterEncodingFilter初始化\u0026quot;);\r}\r//Chain : 链\r/*\r1. 过滤中的所有代码，在过滤特定请求的时候都会执行\r2. 必须要让过滤器继续同行\rchain.doFilter(request,response);\r*/\rpublic void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)\rthrows IOException, ServletException {\rrequest.setCharacterEncoding(\u0026quot;utf-8\u0026quot;);\rresponse.setCharacterEncoding(\u0026quot;utf-8\u0026quot;);\rresponse.setContentType(\u0026quot;text/html;charset=UTF-8\u0026quot;);\rSystem.out.println(\u0026quot;CharacterEncodingFilter执行前....\u0026quot;);\rchain.doFilter(request,response); //让请求继续走，如果不写，程序到这里就被拦截停止！\rSystem.out.println(\u0026quot;CharacterEncodingFilter执行后....\u0026quot;);\r}\r//销毁：web服务器关闭的时候，过滤器会销毁\rpublic void destroy() {\rSystem.out.println(\u0026quot;CharacterEncodingFilter销毁\u0026quot;);\r}\r}\r 在web.xml中配置Filter  \u0026lt;filter\u0026gt;\r\u0026lt;filter-name\u0026gt;CharacterEncodingFilter\u0026lt;/filter-name\u0026gt;\r\u0026lt;filter-class\u0026gt;com.hjc.filter.CharacterEncodingFilter\u0026lt;/filter-class\u0026gt;\r\u0026lt;/filter\u0026gt;\r\u0026lt;filter-mapping\u0026gt;\r\u0026lt;filter-name\u0026gt;CharacterEncodingFilter\u0026lt;/filter-name\u0026gt;\r\u0026lt;!--只要是 /servlet的任何请求，会经过这个过滤器--\u0026gt;\r\u0026lt;url-pattern\u0026gt;/servlet/*\u0026lt;/url-pattern\u0026gt;\r\u0026lt;!--\u0026lt;url-pattern\u0026gt;/*\u0026lt;/url-pattern\u0026gt;--\u0026gt;\r\u0026lt;!-- 别偷懒写个 /* --\u0026gt;\r\u0026lt;/filter-mapping\u0026gt;\r   12 监听器 实现一个监听器的接口（有n种监听器）\n  编写一个监听器\n 实现监听器的接口  //统计网站在线人数 ： 统计session\rpublic class OnlineCountListener implements HttpSessionListener {\r//创建session监听： 看你的一举一动\r//一旦创建Session就会触发一次这个事件！\rpublic void sessionCreated(HttpSessionEvent se) {\rServletContext ctx = se.getSession().getServletContext();\rSystem.out.println(se.getSession().getId());\rInteger onlineCount = (Integer) ctx.getAttribute(\u0026quot;OnlineCount\u0026quot;);\rif (onlineCount==null){\ronlineCount = new Integer(1);\r}else {\rint count = onlineCount.intValue();\ronlineCount = new Integer(count+1);\r}\rctx.setAttribute(\u0026quot;OnlineCount\u0026quot;,onlineCount);\r}\r//销毁session监听\r//一旦销毁Session就会触发一次这个事件！\rpublic void sessionDestroyed(HttpSessionEvent se) {\rServletContext ctx = se.getSession().getServletContext();\rInteger onlineCount = (Integer) ctx.getAttribute(\u0026quot;OnlineCount\u0026quot;);\rif (onlineCount==null){\ronlineCount = new Integer(0);\r}else {\rint count = onlineCount.intValue();\ronlineCount = new Integer(count-1);\r}\rctx.setAttribute(\u0026quot;OnlineCount\u0026quot;,onlineCount);\r}\r/*\rSession销毁：\r1. 手动销毁 getSession().invalidate();\r2. 自动销毁\r*/\r}\r `\n  在web.xml中注册监听器\n  \u0026lt;!--注册监听器--\u0026gt;\r\u0026lt;listener\u0026gt;\r\u0026lt;listener-class\u0026gt;com.hjc.listener.OnlineCountListener\u0026lt;/listener-class\u0026gt;\r\u0026lt;/listener\u0026gt;\r 13 过滤器、监听器常见应用 13.1 监听器 GUI编程中常用\npublic class TestPanel {\rpublic static void main(String[] args) {\rFrame frame = new Frame(\u0026quot;Test\u0026quot;); //新建一个窗体\rPanel panel = new Panel(null); //面板\rframe.setLayout(null); //设置窗体的布局\rframe.setBounds(300,300,500,500);\rframe.setBackground(new Color(0,0,255)); //设置背景颜色\rpanel.setBounds(50,50,300,300);\rpanel.setBackground(new Color(0,255,0)); //设置背景颜色\rframe.add(panel);\rframe.setVisible(true);\r//监听事件，监听关闭事件\rframe.addWindowListener(new WindowAdapter() {\r@Override\rpublic void windowClosing(WindowEvent e) {\rsuper.windowClosing(e);\r}\r});\r}\r}\r 13.2 过滤器 用户登陆后才能进入主页，用户注销后就不能进入主页\n 用户登录后，向Session中放入用户的数据 进入主页的时候要判断用户是否已经登陆，在过滤器中实现  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)\rthrows IOException, ServletException {\rHttpServletRequest request = (HttpServletRequest) req;\rHttpServletResponse response = (HttpServletResponse) resp;\rif (request.getSession().getAttribute(Constant.USER_SESSION)==null){\rresponse.sendRedirect(\u0026quot;/error.jsp\u0026quot;);\r}\rchain.doFilter(request,response);\r}\r 14 JDBC \n14.1 JDBC固定步骤  加载驱动 连接数据库 向数据库发送sql的对象Statement：CRUD 编写sql 执行sql 关闭连接（注意先后顺序）  public class TestJDBC {\rpublic static void main(String[] args) throws ClassNotFoundException, SQLException {\r//配置信息\r//useUnicode=true\u0026amp;characterEncoding=utf-8 解决中文乱码\rString url=\u0026quot;jdbc:mysql://localhost:3306/jdbc?useUnicode=true\u0026amp;characterEncoding=utf-8\u0026quot;;\rString username = \u0026quot;root\u0026quot;;\rString password = \u0026quot;123456\u0026quot;;\r//1.加载驱动\rClass.forName(\u0026quot;com.mysql.jdbc.Driver\u0026quot;);\r//2.连接数据库,代表数据库\rConnection connection = DriverManager.getConnection(url, username, password);\r//3.向数据库发送SQL的对象Statement,PreparedStatement : CRUD\rStatement statement = connection.createStatement();\r//4.编写SQL\rString sql = \u0026quot;select * from users\u0026quot;;\r//5.执行查询SQL，返回一个 ResultSet ： 结果集\rResultSet rs = statement.executeQuery(sql);\rwhile (rs.next()){\rSystem.out.println(\u0026quot;id=\u0026quot;+rs.getObject(\u0026quot;id\u0026quot;));\rSystem.out.println(\u0026quot;name=\u0026quot;+rs.getObject(\u0026quot;name\u0026quot;));\rSystem.out.println(\u0026quot;password=\u0026quot;+rs.getObject(\u0026quot;password\u0026quot;));\rSystem.out.println(\u0026quot;email=\u0026quot;+rs.getObject(\u0026quot;email\u0026quot;));\rSystem.out.println(\u0026quot;birthday=\u0026quot;+rs.getObject(\u0026quot;birthday\u0026quot;));\r}\r//6.关闭连接，释放资源（一定要做） 先开后关\rrs.close();\rstatement.close();\rconnection.close();\r}\r}\r 预编译sql\npublic class TestJDBC2 {\rpublic static void main(String[] args) throws Exception {\r//配置信息\r//useUnicode=true\u0026amp;characterEncoding=utf-8 解决中文乱码\rString url=\u0026quot;jdbc:mysql://localhost:3306/jdbc?useUnicode=true\u0026amp;characterEncoding=utf-8\u0026quot;;\rString username = \u0026quot;root\u0026quot;;\rString password = \u0026quot;123456\u0026quot;;\r//1.加载驱动\rClass.forName(\u0026quot;com.mysql.jdbc.Driver\u0026quot;);\r//2.连接数据库,代表数据库\rConnection connection = DriverManager.getConnection(url, username, password);\r//3.编写SQL\rString sql = \u0026quot;insert into users(id, name, password, email, birthday) values (?,?,?,?,?);\u0026quot;;\r//4.预编译\rPreparedStatement preparedStatement = connection.prepareStatement(sql);\rpreparedStatement.setInt(1,1);//给第一个占位符？的值赋值为1\rpreparedStatement.setString(2,\u0026quot;admin\u0026quot;);//给第二个占位符？的值赋值为admin\rpreparedStatement.setString(3,\u0026quot;123456\u0026quot;);//给第三个占位符？的值赋值为123456\rpreparedStatement.setString(4,\u0026quot;admin@gmail.com\u0026quot;);//给第四个占位符？的值赋值为admin@gmail.com\rpreparedStatement.setDate(5,new Date(new java.util.Date().getTime()));\r//给第五个占位符？的值赋值为new Date(new java.util.Date().getTime())\r//5.执行SQL\rint i = preparedStatement.executeUpdate();\rif (i\u0026gt;0){\rSystem.out.println(\u0026quot;插入成功@\u0026quot;);\r}\r//6.关闭连接，释放资源（一定要做） 先开后关\rpreparedStatement.close();\rconnection.close();\r}\r}\r 14.2 事务 要么都成功，要么都失败，ACID原则：保证数据的安全\n","date":"2020-07-06","permalink":"https://example.com/post/javaweb/","tags":["java","web","servlet","jdbc"],"title":"JavaWeb技术原理"},{"content":"基本概念 拓扑序：如果图中从V到W有一条有向路径，则V一定排在W之前。满足此条件的顶点序列称为一个拓扑序，那么拓扑排序就是获得一个拓扑序的过程。另外，如果有合理的拓扑序，则必定是有向无环图。\n拓扑排序算法 下面介绍一个比较好的拓扑排序算法\n伪代码如下：\nvoid TopSort(){\rfor(图中每个顶点V)\rif(Indegree[V]==0)\rEnqueue(Q,V);\rwhile(!IsEmpty(Q)){\rV=Dequeue(Q);\r输出V，或者记录V的输出序号；\rcnt++;\rfor(V的每个邻接点W)\rif(--Indegree[W]==0)\rEnqueue(Q,W);\r}\rif(cnt!=|V|)\rERROR(\u0026quot;图中有回路\u0026quot;);\r}\r C语言实现如下：\nbool TopSort(LGraph Graph, Vertex TopOrder[]){\t//对Graph进行拓扑排序，TopOrder[]顺序存储排序后的顶点下标\rint Indegree[MaxVertexNum],cnt;\rVertex V;\rPtrToAdjVNode W;\rQueue Q=CreateQueue(Graph-\u0026gt;Nv);\rfor(V=0;V\u0026lt;Graph-\u0026gt;Nv;V++)\t//初始化Indegree[]\rIndegree[V]=0;\rfor(V=0;V\u0026lt;Graph-\u0026gt;Nv;V++)\t//遍历图，得到Indegree[]\rfor(W=Graph-\u0026gt;G[V].FirstEdge;W;W=W-\u0026gt;Next)\rIndegree[W-\u0026gt;AdjV]++;\t//对有向边\u0026lt;V,W-\u0026gt;AdjV\u0026gt;累计终点的入度\rfor(V=0;V\u0026lt;Graph-\u0026gt;Nv;V++)\rif(Indegree[V]==0)\t//将所有入度为0的顶点入队\rAddQ(Q,V);\rcnt=0;\rwhile(!IsEmpty(Q)){\rV=DeleteQ(Q);\t//弹出一个入度为0的顶点\rTopOrder[cnt++]=V;\t//将V存为结果序列的下一个元素\rfor(W=Graph-\u0026gt;G[V].FirstEdge;W;W=W-\u0026gt;Next)\t//对于V的每一个邻接点W-\u0026gt;AdjV\rif(--Indegree[W-\u0026gt;AdjV]==0)\t//若删除V使得W-\u0026gt;AdjV的入度为0\rAddQ(Q,W-\u0026gt;AdjV);\t//则将W-\u0026gt;AdjV入队\r}\rif(cnt!=Graph-\u0026gt;Nv)\t//图中有回路\rreturn fasle;\relse\rreturn true;\r}\r 时间复杂度T=O(|V|+|E|)，此算法也可以用来检测有向图是否是无环图。\n","date":"2019-07-30","permalink":"https://example.com/post/topsort/","tags":["算法"],"title":"拓扑排序"},{"content":"基本概念 最小生成树\n 是一棵树  无回路，向生成树中任加一条边都一定构成回路 |V|个顶点一定有|V|-1条边   是生成树  包含全部顶点 |V|-1条边都在图里   边的权重最小  贪心算法 对于如何最小生成树的算法，我们使用贪心算法。\n 什么是“贪”：每一步都要好的 什么是“好”：权重最小的边 需要约束  只能用图里有的边 只能正好用掉|V|-1条边 不能有回路    Prim算法 类似Dijkstra算法\nVertex FindMinDist(MGraph Graph, WeightType dist[]){\t//返回未被收录顶点中dist最小者\rVertex MinV,V;\rWeightType MinDist=INFINITY;\rfor(V=0;V\u0026lt;Graph-\u0026gt;Nv;V++){\t//对于图中每个顶点V\rif(dist[V]!=0\u0026amp;\u0026amp;dist[V]\u0026lt;MinDist){\t//若V未被收录且dist[V]更小\rMinDist=dist[V];\t//更新最小距离\rMinV=V;\t//更新对应顶点\r}\r}\rif(MinDist\u0026lt;INFINITY)\rreturn MinV;\relse\rreturn false;\r}\rint Prim(MGraph Graph, LGraph MST){\t//将最小生成树保存为邻接表存储的图MST，返回最小权重和\rWeightType dist[MaxVertexNum],TotalWeight;\rVertex parent[MaxVertexNum],V,W;\rint VCount;\rEdge E;\rfor(V=0;V\u0026lt;Graph-\u0026gt;Nv;V++){\t//初始化，默认初始顶点下标为0\rdist[V]=Graph-\u0026gt;G[0][V];\rparent[V]=0;\r}\rTotalWeight=0;\rVCount=0;\rMST=CreateGraph(Graph-\u0026gt;Nv);\t//创建包含所有顶点但没有边的邻接表存储的图\rE=(Edge)malloc(sizeof(struct ENode));\t//建立空的边结点\rdist[0]=0;\rVCount++;\rparent[0]=-1;\rwhile(1){\rV=FindMinDist(Graph, dist);\t//找到未被收录顶点中dist最小者\rif(V==ERROR)\rbreak;\rE-\u0026gt;V1=parent[V];\t//将V及相应的边\u0026lt;parent[V],V\u0026gt;收录进MST\rE-\u0026gt;V2=V;\rE-\u0026gt;Weight=dist[V];\rInsertEdge(MST,E);\rTotalWeight+=dist[V];\rdist[V]=0;\rVCount++;\rfor(W=0;W\u0026lt;Graph-\u0026gt;Nv;W++)\rif(dist[W]!=0\u0026amp;\u0026amp;Graph-\u0026gt;G[V][W]\u0026lt;INFINITY){\t//若W未被收录且W是V的邻接点\rif(Graph-\u0026gt;G[V][W]\u0026lt;dist[W]){\t//收录进V使得dist[W]变小\rdist[W]=Graph-\u0026gt;G[V][W];\t//更新dist[W]\rparent[W]=V;\t//更新树\r}\r}\t}\rif(VCount\u0026lt;Graph-\u0026gt;Nv)\t//MST中的顶点不到|V|个\rTotalWeight=ERROR;\rreturn TotalWeight;\r}\r 对于稠密图，时间复杂度T=O(|V|^2)\nKruskal算法 Kruskal算法是将森林合并成树。 伪代码如下：\nvoid Kruskal(Graph G){\rMST={ };\rwhile(MST中不到|V|-1条边 \u0026amp;\u0026amp; E中还有边){\r从E中取一条权重最小的边E(V,W);\t//最小堆\r将E(V,W)从E中删除;\rif(E(V,W)不在MST中构成回路)\t//并查集\r将E(V,W)加入MST;\relse\r彻底无视E(V,W);\r}\rif(MST中不到|V|-1条边)\rERROR(\u0026quot;生成树不存在\u0026quot;);\r}\r C语言代码如下，摘自浙大陈越奶奶数据结构：\n/* 邻接表存储 - Kruskal最小生成树算法 */\r/*-------------------- 顶点并查集定义 --------------------*/\rtypedef Vertex ElementType; /* 默认元素可以用非负整数表示 */\rtypedef Vertex SetName; /* 默认用根结点的下标作为集合名称 */\rtypedef ElementType SetType[MaxVertexNum]; /* 假设集合元素下标从0开始 */\rvoid InitializeVSet( SetType S, int N )\r{ /* 初始化并查集 */\rElementType X;\rfor ( X=0; X\u0026lt;N; X++ ) S[X] = -1;\r}\rvoid Union( SetType S, SetName Root1, SetName Root2 )\r{ /* 这里默认Root1和Root2是不同集合的根结点 */\r/* 保证小集合并入大集合 */\rif ( S[Root2] \u0026lt; S[Root1] ) { /* 如果集合2比较大 */\rS[Root2] += S[Root1]; /* 集合1并入集合2 */\rS[Root1] = Root2;\r}\relse { /* 如果集合1比较大 */\rS[Root1] += S[Root2]; /* 集合2并入集合1 */\rS[Root2] = Root1;\r}\r}\rSetName Find( SetType S, ElementType X )\r{ /* 默认集合元素全部初始化为-1 */\rif ( S[X] \u0026lt; 0 ) /* 找到集合的根 */\rreturn X;\relse\rreturn S[X] = Find( S, S[X] ); /* 路径压缩 */\r}\rbool CheckCycle( SetType VSet, Vertex V1, Vertex V2 )\r{ /* 检查连接V1和V2的边是否在现有的最小生成树子集中构成回路 */\rVertex Root1, Root2;\rRoot1 = Find( VSet, V1 ); /* 得到V1所属的连通集名称 */\rRoot2 = Find( VSet, V2 ); /* 得到V2所属的连通集名称 */\rif( Root1==Root2 ) /* 若V1和V2已经连通，则该边不能要 */\rreturn false;\relse { /* 否则该边可以被收集，同时将V1和V2并入同一连通集 */\rUnion( VSet, Root1, Root2 );\rreturn true;\r}\r}\r/*-------------------- 并查集定义结束 --------------------*/\r/*-------------------- 边的最小堆定义 --------------------*/\rvoid PercDown( Edge ESet, int p, int N )\r{ /* 改编代码4.24的PercDown( MaxHeap H, int p ) */\r/* 将N个元素的边数组中以ESet[p]为根的子堆调整为关于Weight的最小堆 */\rint Parent, Child;\rstruct ENode X;\rX = ESet[p]; /* 取出根结点存放的值 */\rfor( Parent=p; (Parent*2+1)\u0026lt;N; Parent=Child ) {\rChild = Parent * 2 + 1;\rif( (Child!=N-1) \u0026amp;\u0026amp; (ESet[Child].Weight\u0026gt;ESet[Child+1].Weight) )\rChild++; /* Child指向左右子结点的较小者 */\rif( X.Weight \u0026lt;= ESet[Child].Weight ) break; /* 找到了合适位置 */\relse /* 下滤X */\rESet[Parent] = ESet[Child];\r}\rESet[Parent] = X;\r}\rvoid InitializeESet( LGraph Graph, Edge ESet )\r{ /* 将图的边存入数组ESet，并且初始化为最小堆 */\rVertex V;\rPtrToAdjVNode W;\rint ECount;\r/* 将图的边存入数组ESet */\rECount = 0;\rfor ( V=0; V\u0026lt;Graph-\u0026gt;Nv; V++ )\rfor ( W=Graph-\u0026gt;G[V].FirstEdge; W; W=W-\u0026gt;Next )\rif ( V \u0026lt; W-\u0026gt;AdjV ) { /* 避免重复录入无向图的边，只收V1\u0026lt;V2的边 */\rESet[ECount].V1 = V;\rESet[ECount].V2 = W-\u0026gt;AdjV;\rESet[ECount++].Weight = W-\u0026gt;Weight;\r}\r/* 初始化为最小堆 */\rfor ( ECount=Graph-\u0026gt;Ne/2; ECount\u0026gt;=0; ECount-- )\rPercDown( ESet, ECount, Graph-\u0026gt;Ne );\r}\rint GetEdge( Edge ESet, int CurrentSize )\r{ /* 给定当前堆的大小CurrentSize，将当前最小边位置弹出并调整堆 */\r/* 将最小边与当前堆的最后一个位置的边交换 */\rSwap( \u0026amp;ESet[0], \u0026amp;ESet[CurrentSize-1]);\r/* 将剩下的边继续调整成最小堆 */\rPercDown( ESet, 0, CurrentSize-1 );\rreturn CurrentSize-1; /* 返回最小边所在位置 */\r}\r/*-------------------- 最小堆定义结束 --------------------*/\rint Kruskal( LGraph Graph, LGraph MST )\r{ /* 将最小生成树保存为邻接表存储的图MST，返回最小权重和 */\rWeightType TotalWeight;\rint ECount, NextEdge;\rSetType VSet; /* 顶点数组 */\rEdge ESet; /* 边数组 */\rInitializeVSet( VSet, Graph-\u0026gt;Nv ); /* 初始化顶点并查集 */\rESet = (Edge)malloc( sizeof(struct ENode)*Graph-\u0026gt;Ne );\rInitializeESet( Graph, ESet ); /* 初始化边的最小堆 */\r/* 创建包含所有顶点但没有边的图。注意用邻接表版本 */\rMST = CreateGraph(Graph-\u0026gt;Nv);\rTotalWeight = 0; /* 初始化权重和 */\rECount = 0; /* 初始化收录的边数 */\rNextEdge = Graph-\u0026gt;Ne; /* 原始边集的规模 */\rwhile ( ECount \u0026lt; Graph-\u0026gt;Nv-1 ) { /* 当收集的边不足以构成树时 */\rNextEdge = GetEdge( ESet, NextEdge ); /* 从边集中得到最小边的位置 */\rif (NextEdge \u0026lt; 0) /* 边集已空 */\rbreak;\r/* 如果该边的加入不构成回路，即两端结点不属于同一连通集 */\rif ( CheckCycle( VSet, ESet[NextEdge].V1, ESet[NextEdge].V2 )==true ) {\r/* 将该边插入MST */\rInsertEdge( MST, ESet+NextEdge );\rTotalWeight += ESet[NextEdge].Weight; /* 累计权重 */\rECount++; /* 生成树中边数加1 */\r}\r}\rif ( ECount \u0026lt; Graph-\u0026gt;Nv-1 )\rTotalWeight = -1; /* 设置错误标记，表示生成树不存在 */\rreturn TotalWeight;\r}\r 时间复杂度T=O(|E|log|E|)\n","date":"2019-07-30","permalink":"https://example.com/post/minimum-spanning-tree/","tags":["数据结构"],"title":"最小生成树"},{"content":"最短路径问题的抽象 在网络中，求两个不同顶点之间的所有路径中，边的权值之和最小的那一条路径。\n 这条路径就是两点之间的最短路径 第一个顶点为源点 最后一个顶点为终点  问题分类 单源最短路径问题：从某固定源点出发，求其到所有其他顶点的最短路径。\n （有向）无权图 （有向）有权图 多源最短路径问题：求任意两顶点之间的最短路径  无权图的单源最短路径算法 按照递增(非递减)的顺序找出到各个顶点的最短路，类似BFS。\nvoid Unweighted(LGraph Graph, int dist[], int path[], Vertex S){\t//dist[]和path[]全部初始化为-1\rQueue Q;\rVertex V;\rPtrToAdjVNode W;\rQ=CreateQueue(Graph-\u0026gt;Nv);\t//创建空队列\rdist[S]=0;\t//S为源点\rAddQ(Q,S);\rwhile(!IsEmpty(Q)){\rV=DeleteQ(Q);\rfor(W=Graph-\u0026gt;G[V].FirstEdge;W;W=W-\u0026gt;Next)\t//对V的每个邻接点W-\u0026gt;AdjV\rif(dist[W-\u0026gt;AdjV]==-1){\t//若W-\u0026gt;AdjV未被访问过\rdist[W-\u0026gt;AdjV]=dist[V]+1;\t//S到W-\u0026gt;AdjV的距离更新\rpath[W-\u0026gt;AdjV]=V;\t//将V记录在S到W-\u0026gt;AdjV的路径上\rAddQ(Q,W-\u0026gt;AdjV);\r}\r}\r}\r 时间复杂度T=O(|V|+|E|)\n有权图的单源最短路径算法 按照递增的顺序找出到各个顶点的最短路径，我们使用Dijkstra算法。\n Dijkstra算法  令S={源点s+已经确定了最短路径的顶点vi} 对任一未收录的顶点v，定义dist[v]为s到v的最短路径长度，但该路径仅经过S中的顶点。即路径{s-\u0026gt;(vi)-\u0026gt;v}的最小长度 若路径是按照递增(非递减)的顺序生成的，则  真正的最短路径必须只经过S中的顶点 每次从未收录的顶点中选一个dist最小的收录(贪心) 增加一个v进入S，可能影响另外一个w的dist值  dist[w]=min{dist[w], dist[v]+\u0026lt;v,w\u0026gt;的权重}        Vertex FindMinDist(MGraph Graph, int dist[], int collected[]){\t//返回未被收录顶点中dist最小者\rVertex MinV,V;\rint MinDist=INFINITY;\rfor(V=0;V\u0026lt;Graph-\u0026gt;Nv;V++){\rif(collected[V]==false\u0026amp;\u0026amp;dist[V]\u0026lt;MinDist){\t//若V未被收录，且dist[V]更小\rMinDist=dist[V];\t//更新最小距离\rMinV=V;\t//更新对应顶点\r}\r}\rif(MinDist\u0026lt;INFINITY)\t//若找到最小dist\rreturn MinV;\t//返回对应顶点\relse\rreturn ERROR;\r}\rbool Dijkstra(MGraph Graph, int dist[], int path[], Vertex S){\rint collected[MaxVertexNum];\rVertex V,W;\rfor(V=0;V\u0026lt;Graph-\u0026gt;Nv;V++){\t//初始化，默认邻接矩阵中不存在的边用INFINITY表示\rdist[V]=Graph-\u0026gt;G[S][V];\rif(dist[V]\u0026lt;INFINITY)\rpath[V]=S;\relse\rpath[V]=-1;\rcollected[V]=false;\r}\rdist[S]=0;\t//源点S\rcollected[S]=true;\rwhile(1){\rV=FindMinDist(Graph, dist, collected);\t//找到未被收录顶点中dist最小者V\rif(V==ERROR)\rbreak;\rcollected[V]=true;\t//收录V\rfor(W=0;W\u0026lt;Graph-\u0026gt;Nv;W++)\t//对图中的每个顶点W\rif(collected[W]==false\u0026amp;\u0026amp;Graph-\u0026gt;G[V][W]\u0026lt;INFINITY){\t//若W未被收录且W是V的邻接点\rif(Graph-\u0026gt;G[V][W]\u0026lt;0)\t//若有副边，不能正确解决\rreturn false;\rif(dist[V]+Graph-\u0026gt;G[V][W]\u0026lt;dist[W]){\t//若收录V使得dist[W]变小\rdist[W]=dist[V]+Graph-\u0026gt;G[V][W];\t//更新dist[W]\rpath[W]=V;\t//更新S到W的路径\r}\r}\r}\rreturn true;\r}\r 多源最短路径算法 对于多源最短路径算法，有两种方法\n 方法1：直接将单源最短路径算法调用|V|遍  T=O(|V|^3+|E|*|V|) 对于稀疏图效果比较好   方法2：Floyd算法  T=O(|V|^3) 对于稠密图效果比较好    在这里我们介绍Floyd算法\n Floyd算法  Dk[i][j]=路径{i-\u0026gt;{l\u0026lt;=k}-\u0026gt;j}的最小长度 D0，D1，···，D|V|-1[i][j]即给出了i到j的真正最短距离 当Dk-1已经完成，递推到Dk时：  如果k不在最短路径{i-\u0026gt;{l\u0026lt;=k}-\u0026gt;j}里面，则Dk=Dk-1 如果k在最短路径{i-\u0026gt;{l\u0026lt;=k}-\u0026gt;j}里面，则该路径必定由两段最短路径组成：Dk[i][j]=Dk-1[i][k]+Dk-1[k][j]      bool Floyd(MGraph Graph, WeightType D[][MaxVertexNum], Vertex path[][MaxVertexNum]){\rVertex i,j,k;\rfor(i=0;i\u0026lt;Graph-\u0026gt;Nv;i++)\t//初始化\rfor(j=0;j\u0026lt;Graph-\u0026gt;Nv;j++){\rD[i][j]=Graph-\u0026gt;G[i][j];\rpath[i][j]=-1;\r}\rfor(k=0;k\u0026lt;Graph-\u0026gt;Nv;k++)\rfor(i=0;i\u0026lt;Graph-\u0026gt;Nv;i++)\rfor(j=0;j\u0026lt;Graph-\u0026gt;Nv;j++)\rif(D[i][k]+D[k][j]\u0026lt;D[i][j]){\rD[i][j]=D[i][k]+D[k][j];\rif(i==j\u0026amp;\u0026amp;D[i][j]\u0026lt;0)\t//若发现负值圈\rreturn false;\t//不能正确解决，返回错误\rpath[i][j]=k;\r}\rreturn true;\r}\r ","date":"2019-07-30","permalink":"https://example.com/post/shortest-path/","tags":["数据结构"],"title":"最短路径问题"},{"content":"基本概念 图表示多对多的关系。包含\n 一组顶点：通常用V(Vertex)表示顶点集合 一组边：通常用E(Edge)表示边的集合  边是顶点对：(v,w)是集合E的元素，其中v，w是集合V的元素 有向边\u0026lt;v,w\u0026gt;表示从v指向w的边(单行线) 不考虑重边和自回路    抽象数据类型定义 类型名称：图 数据对象集：G(V,E)由一个非空的有限顶点集合V和一个有限边集合E组成 操作集：对于任意图G，以及v，e\n Graph Create()：建立并返回空图 Graph InsertVertex(Graph G, Vertex v)：将v插入G Graph InsertEdge(Graph G, Edge e)：将e插入G void DFS(Graph G, Vertex v)：从顶点v出发深度优先遍历图G void BFS(Graph G, Vertex v)：从顶点v出发广度优先遍历图G void ShortestPath(Graph G, Vertex v, int Dist[])：计算图G中顶点v到任意其他顶点的最短距离 void MST(Graph G)：计算图G的最小生成树  图的表示 图有两种表示方法，邻接矩阵和邻接表\n我们可以创建一个二维数组G[N][N]，若\u0026lt;vi,vj\u0026gt;是G中的边，则G[i][j]=1，否则为0。对于有向图，邻接矩阵是对称的，而对于无向图则不是。对于网络，G[i][j]的值是边\u0026lt;vi,vj\u0026gt;的权重，如果没有边，则为-∞。\n邻接矩阵的优点\n 直观、简单、好理解 方便检查任意一对顶点间是否存在边 方便找任一顶点的所有“邻接点”（有边直接相连的顶点） 方便计算任一顶点的“度”（从该点出发的边数为“出度”，指向该点的边数为“入度”）  无向图：对应行（或列）非0元素的个数 有向图：对应行非0元素的个数是“出度”，对应列非0元素的个数是“入度”    邻接矩阵的缺点\n 浪费空间：存稀疏图（点很多而边很少）有大量无效元素  对稠密图（特别是完全图）还是很合算的   浪费时间：统计稀疏图中一共有多少条边  同时，我们可以创建一个指针数组G[N]，对应矩阵每行一个链表，只存非0元素。对于网络，链表结构中要增加权重的域。\n邻接表的优点\n 方便找任一顶点的所有“邻接点” 节约稀疏图的空间  需要N个头指针+2E个结点（每个结点至少2个域）   方便计算任一顶点的“度”  无向图：任一顶点的度就是链表的长度 有向图：只能计算“出度”，需要构造“逆邻接表”（存指向自己的边）来方便计算“出度”    邻接表的缺点\n 不方便检查任意一对顶点间是否存在边  邻接矩阵表示 结构体定义 #define MaxVertexNum 100\r#define INFINITY 65535\rtypedef int Vertex; //用顶点下标表示顶点，为整型\rtypedef int WeightType;\rtypedef char DataType;\rtypedef struct ENode *PtrToENode;\rstruct ENode{\t//边的定义\rVertex V1,V2;\t//有向边\u0026lt;v1,v2\u0026gt;\rWeightType Weight;\t//权重\r};\rtypedef PtrToENode Edge;\rtypedef struct GNode *PtrToGNode;\rstruct GNode{\t//图结点的定义\rint Nv;\t//顶点数\rint Ne;\t//边数\rWeightType G[MaxVertexNum][MaxVertexNum];\t//邻接矩阵\rDataType Data[MaxVertexNum];\t//存顶点的数据，如果顶点不存数据，可以省略\r};\rtypedef PtrToGNode MGraph;\r 图的初始化 MGraph CreateGraph(int VertexNum){ //初始化一个有VertexNum个顶点但没有边的图\rVertex V,W;\rMGraph Graph;\rGraph=(MGraph)malloc(sizeof(struct GNode)); //建立图\rGraph-\u0026gt;Nv=VertexNum;\rGraph-\u0026gt;Ne=0;\rfor(V=0;V\u0026lt;Graph-\u0026gt;Nv;V++) //初始化邻接矩阵，顶点编号为0-(Nv-1)\rfor(W=0;W\u0026lt;Graph-\u0026gt;Nv;W++)\rGraph-\u0026gt;G[V][W]=INFINITY;\rreturn Graph;\r}\r 边的插入 void InsertEdge(MGraph Graph, Edge E){\rGraph-\u0026gt;G[E-\u0026gt;V1][E-\u0026gt;V2]=E-\u0026gt;Weight; //插入边\u0026lt;V1,V2\u0026gt;\rGraph-\u0026gt;G[E-\u0026gt;V2][E-\u0026gt;V1]=E-\u0026gt;Weight; //若是无向图，还要插入边\u0026lt;V2,V1\u0026gt;\r}\r 图的建立 MGraph BuildGraph(){\rMGraph Graph;\rEdge E;\rVertex V;\rint Nv,i;\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;Nv); //读入顶点个数\rGraph=CreateGraph(Nv); //初始化有Nv个顶点但没有边的图\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;(Graph-\u0026gt;Ne)); //读入边数\rif(Graph-\u0026gt;Ne!=0){\rE=(Edge)malloc(sizeof(struct ENode)); //建立边结点\rfor(i=0;i\u0026lt;Graph-\u0026gt;Ne;i++){\rscanf(\u0026quot;%d %d %d\u0026quot;,\u0026amp;(E-\u0026gt;V1),\u0026amp;(E-\u0026gt;V2),\u0026amp;(E-\u0026gt;Weight)); //读入边\rInsertEdge(Graph,E); //插入边\r}\r}\rfor(V=0;V\u0026lt;Graph-\u0026gt;Nv;V++)\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;(Graph-\u0026gt;Data[V])); //如果顶点有数据，则读入数据\rreturn Graph;\r}\r 邻接表表示 结构体定义 #define MaxVertexNum 100\rtypedef int Vertex; //顶点下标表示顶点，为整型\rtypedef int WeightType;\rtypedef char DataType;\rtypedef struct ENode *PtrToENode;\rstruct ENode{ //边的定义\rVertex V1,V2; //有向边\u0026lt;V1,V2\u0026gt;\rWeightType Weight;\r};\rtypedef PtrToENode Edge;\rtypedef struct AdjVNode *PtrToAdjVNode;\rstruct AdjVNode{ //邻接点的定义\rVertex AdjV; //邻接点下标\rWeightType Weight; //边权重\rPtrToAdjVNode Next; //指向下一个邻接点的指针\r};\rtypedef struct Vnode{ //顶点表头结点的定义\rPtrToAdjVNode FirstEdge; //边表头指针\rDataType Data; //存顶点的数据\r}AdjList[MaxVertexNum]; //AdjList是邻接表类型的数组\rtypedef struct GNode *PtrToGNode;\rstruct GNode{ //图结点的定义\rint Nv; //顶点数\rint Ne; //边数\rAdjList G; //邻接表\r};\rtypedef PtrToGNode LGraph;\r 图的初始化 LGraph CreateGraph(int VertexNum){ //初始化一个有VertexNum个顶点但没有边的图\rVertex V;\rLGraph Graph;\rGraph=(LGraph)malloc(sizeof(struct GNode)); //建立图\rGraph-\u0026gt;Nv=VertexNum;\rGraph-\u0026gt;Ve=0;\rfor(V=0;V\u0026lt;Graph-\u0026gt;Nv;V++) //初始化邻接表头指针，定点编号0-(Graph-\u0026gt;Nv-1)\rGraph-\u0026gt;G[V].FirstEdge=NULL;\rreturn Graph;\r}\r 边的插入 void InsertEdge(LGraph Graph, Edge E){\rPtrToAdjVNode NewNode;\r//插入边\u0026lt;V1,V2\u0026gt;\rNewNode=(PtrToAdjVNode)malloc(sizeof(struct AdjVNode)); //为V2建立新的邻接点\rNewNode-\u0026gt;AdjV=E-\u0026gt;V2;\rNewNode-\u0026gt;Weight=E-\u0026gt;Weight;\r//将V2插入V1的表头\rNewNode-\u0026gt;Next=Graph-\u0026gt;G[E-\u0026gt;V1].FirstEdge;\rGraph-\u0026gt;G[E-\u0026gt;V1].FirstEdge=NewNode;\r//若是无向图，还要插入边\u0026lt;V2,V1\u0026gt;\rNewNode=(PtrToAdjVNode)malloc(sizeof(struct AdjVNode)); //为V1建立新的邻接点\rNewNode-\u0026gt;AdjV=E-\u0026gt;V1;\rNewNode-\u0026gt;Weight=E-\u0026gt;Weight;\r//将V1插入V2的表头\rNewNode-\u0026gt;Next=Graph-\u0026gt;G[E-\u0026gt;V2].FirstEdge;\rGraph-\u0026gt;G[E-\u0026gt;V1].FirstEdge=NewNode;\r}\r 图的建立 LGraph BuildGraph(){\rLGraph Graph;\rEdge E;\rVertex V;\rint Nv,i;\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;Nv); //读入顶点个数\rGraph=CreateGraph(Nv); //初始化有Nv个顶点但没有边的图\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;(Graph-\u0026gt;Ne)); //读入边数\rif(Graph-\u0026gt;Ne!=0){\rE=(Edge)malloc(sizeof(struct ENode)); //建立边结点\rfor(i=0;i\u0026lt;Graph-\u0026gt;Ne;i++){\rscanf(\u0026quot;%d %d %d\u0026quot;,\u0026amp;(E-\u0026gt;V1),\u0026amp;(E-\u0026gt;V2),\u0026amp;(E-\u0026gt;Weight)); //读入边的起点、终点、权重\rInsertEdge(Graph,E); //插入边\r}\r}\rfor(V=0;V\u0026lt;Graph-\u0026gt;Nv;V++) //如果顶点有数据，读入数据\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;(Graph-\u0026gt;G[V].Data));\rreturn Graph;\r}\r 图的遍历 图的遍历有两种方法，深度优先搜索(DFS)和广度优先搜索(BFS)。\n深度优先搜索 图的深度优先搜索类似于树的先序遍历。若有N个顶点、E条边，时间复杂度为\n 用邻接表存储图，有O(N+E) 用邻接矩阵存储图，有O(N^2)  伪代码如下：\nvoid DFS(Vertex V){\rvisited[V]=true;\rfor(V的每个邻接点W)\rif(!visited[W])\rDFS(W);\r}\r C语言代码如下：\nvoid Visit(Vertex V){\rprintf(\u0026quot;正在访问顶点%d\u0026quot;,V);\r}\rvoid DFS(LGraph Graph, Vertex V, void (*Visit)(Vertex)){ //以V为出发点对邻接表存储的图Graph进行DFS\rPtrToAdjVNode W;\rVisit(V); //访问第V个顶点\rVisited[V]=true; //Visited[]为全局变量，初始化为false，已访问则标记为true\rfor(W=Graph-\u0026gt;G[V].FirstEdge;W;W=W-\u0026gt;Next) //对V的每个邻接点W-\u0026gt;AdjV\rif(!Visited[W-\u0026gt;AdjV]) //若W-\u0026gt;AdjV未被访问\rDFS(Graph,W-\u0026gt;AdjV,Visit); //则递归访问\r}\r 广度优先搜索 图的广度优先搜索类似于树的层序遍历，需要使用队列。若有N个顶点、E条边，时间复杂度为\n 用邻接表存储图，有O(N+E) 用邻接矩阵存储图，有O(N^2)  伪代码如下：\nvoid BFS(Vertex V){\rvisited[V]=true;\rEnqueue(V,Q);\rwhile(!IsEmpty(Q)){\rV=Dequeue(Q);\rfor(V的每个邻接点W)\rif(!visited[W]){\rvisited[W]=true;\rEnqueue(W,Q);\r}\r}\r}\r C语言代码如下：\nbool IsEdge(MGraph Graph, Vertex V, Vertex W){ //判断\u0026lt;V,W\u0026gt;是否是图Graph中的一条边，即W是否是V的邻接点\rreturn Graph-\u0026gt;G[V][W]\u0026lt;INFINITY?true:false;\r}\rvoid BFS(MGraph Graph, Vertex S, void (*Visit)(Vertex)){ //以S为出发点对邻接矩阵存储的图Graphj进行BFS\rQueue Q;\rVertex V,W;\rQ=CreateQueue(MaxSize); //创建空队列\rVisit(S);\rVisited[S]=true;\rAddQ(Q,S); //S入队\rwhile(!IsEmpty(Q)){\rV=DeleteQ(Q); //出队\rfor(W=0;W,Graph-\u0026gt;Nv;W++) //对于图中的每个顶点W\rif(!Visited[W]\u0026amp;\u0026amp;IsEdge(Graph,V,W)){ //如果W是V的临界点且未被访问过\rVisit(W);\rVisited[W]=true;\rAddQ(Q,W);\r}\r}\r}\r ","date":"2019-07-27","permalink":"https://example.com/post/graph/","tags":["数据结构"],"title":"图"},{"content":"基本概念 void X_Sort(ElementType A[], int N)\r  N是正整数 只讨论基于比较的排序(\u0026lt;、=、\u0026gt;有定义) 只讨论内部排序 稳定性：任意两个相等的数据，排序前后的相对位置不发生变化 没有一种排序是任何情况下都表现最好的  简单排序 冒泡排序 每一趟冒泡可以确定至少一个元素的位置，确定一个最大值，也就是说，排序过程中序列尾部是排好序的。冒泡排序是稳定的算法。\nvoid Bubble_Sort(ElementType A[], int N){\rint P,i;\rfor(P=N-1;P\u0026gt;=0;P--){\rint flag=0;\rfor(i=0;i\u0026lt;P;i++){\t//一趟冒泡\rif(A[i]\u0026gt;A[i+1]){\rSwap(A[i],A[i+1]);\rflag=1;\t//标识发生了交换\r}\r}\rif(flag==0)\t//全程无交换\rbreak;\r}\r}\r 最好情况：顺序 T=O(N)，最坏情况：逆序 T=O(N^2)\n插入排序 从1号元素开始，依次取出元素与其前面的元素比较，将其插入到合适的位置，排序过程中序列前部是排好序的。插入排序是稳定的算法。\nvoid Insertion_Sort(ElementType A[], int N){\rint P,i;\rElementType Tmp;\rfor(P=1;P\u0026lt;N;P++){\rTmp=A[P];\t//取出未排序序列中的第一个元素\rfor(i=P;i\u0026gt;0\u0026amp;\u0026amp;A[i-1]\u0026gt;Tmp;i--)\rA[i]=A[i-1];\t//依次与已排序序列中的元素比较并右移\rA[i]=Tmp;\t//放入适合的位置\r}\r}\r 最好情况：顺序 T=O(N)，最坏情况：逆序 T=O(N^2)\n 简单排序的平均时间复杂度为O(N^2)。\n希尔排序 希尔排序是由Donald Shell提出的，所以叫希尔排序。 要进行希尔排序，首先要定义增量序列Dm \u0026gt; Dm-1 \u0026gt; ··· \u0026gt; D1 = 1，然后就在待排序列上对每个增量序列Dk进行“Dk-间隔”排序(k=m,m-1,···,1)。其中要注意的是，“Dk-间隔”有序的序列，在执行“Dk-1-间隔”排序后，仍然是“Dk-间隔”有序的。 那么，希尔排序的关键就是确定增量序列，之后的每个“Dk-间隔”排序就可以采用简单排序来做。\n 原始希尔排序 Dm=[N/2], Dk=[Dk+1/2] 向下取整  void Shell_Sort(ElementType A[], int N){\rfor(D=N/2;D\u0026gt;0;D/=2){\t//希尔增量序列\rfor(P=D;P\u0026lt;N;P++){\t//插入排序\rTmp=A[P];\rfor(i=P;i\u0026gt;=D\u0026amp;\u0026amp;A[i-D]\u0026gt;Tmp;i-=D)\rA[i]=A[i-D];\rA[i]=Tmp;\r}\r}\r}\r 最坏情况：T=O(N^2)\n但是这样选取增量序列有个问题，增量元素不互质，那么小增量可能根本不起作用。\n这样也就产生了跟多增量序列\n  Hibbard增量序列\n Dk=2^k-1 —— 相邻元素互质 最坏情况：T=O(N^3/2) 猜想：Tavg=O(N^5/4)    Sedgewick增量序列\n {1,5,19,41,109,···} —— 9×4^i-9×2^i+1或4^i-3×2^i+1 猜想：Tavg=O(N^7/6), Tworst=O(N^4/3)    void Shell_Sort(ElementType A[], int N){\r//希尔排序 - 用Sedgewick增量序列\rint Si,D,P,i;\rElementTypde Tmp;\r//只列出一小部分增量\rint Sedgewick[]={929,505,209,109,41,19,5,1,0};\rfor(Si=0;Sedgewick[Si]\u0026gt;=N;Si++)\r;\t//初始的增量Sedgewick[Si]不能超过待排序列的长度，把超过的部分滤除\rfor(D=Sedgewick[Si];D\u0026gt;0;D=Sedgewick[++Si]){\rfor(P=D;P\u0026lt;N;P++){\t//插入排序\rTmp=A[P];\rfor(i=P;i\u0026gt;=D\u0026amp;\u0026amp;A[i-D]\u0026gt;Tmp;i-=D)\rA[i]=A[i-D];\rA[i]=Tmp;\r}\r}\r}\r 堆排序 堆排序是利用最小堆的特性来对待排序列进行排序。\n 算法1 用待排序列中的元素建最小堆，再从堆中返回最小元素到新的数组中，最后把新的排好序的数组复制到原序列中。  void Heap_Sort(ElementType A[], int N){\rBuildHeap(A);\t//O(N)\rfor(i=0;i\u0026lt;N;i++)\rTmpA[i]=DeleteMin(A);\t//O(logN)\rfor(i=0;i\u0026lt;N;i++)\t//O(N)\rA[i]=TmpA[i];\r}\r T=O(NlogN)，需要额外O(N)的空间，并且复制元素需要时间。\n 算法2 用待排序列中的元素建最大堆，再对堆直接操作，把根结点最大值和堆的最后一个元素交换，则确定了最大值的位置，然后对其余元素进行调整(下滤)，依次进行上述操作。相比算法1不需要额外的空间。  void Swap(ElementType *a, ElementType *b){\rElementType t=*a;\r*a=*b;\r*b=t;\r}\rvoid PercDown(ElementType A[], int p, int N){\r//改编自堆的下滤操作PrecDown(MaxHeap H, int p)，参考堆的那篇博客\r//将N个元素的数组中以A[p]为根的子堆调整为最大堆\rint Parent,Child;\rElementType X;\rX=A[p];\t//取出根结点的值\rfor(Parent=p;Parent*2+1\u0026lt;N;Parent=Child){\rChild=Parent*2+1;\rif((Child!=N-1)\u0026amp;\u0026amp;(A[Child]\u0026lt;A[Child+1]))\rChild++;\t//Child指向左右子结点的最大者\rif(X\u0026gt;=A[Child])\tbreak;\t//找到了合适位置\relse\rA[Parent]=A[Child];\t//下滤\r}\rA[Parent]=X;\r}\rvoid Heap_Sort(ElementType A[], int N){\rint i;\rfor(i=N/2-1;i\u0026gt;=0;i--)\rPercDown(A,i,N);\t//建最大堆，从最后一个父结点开始往前，依次下滤\rfor(i=N-1;i\u0026gt;0;i--){\rSwap(\u0026amp;A[0],\u0026amp;A[i]);\t//交换最大值和末尾的值，相当于删除最大堆顶\rPercDown(A,0,i);\t//对剩余子堆进行调整(下滤)\r}\r}\r 堆排序处理N个不同元素的随机排列的平均比较次数是2NlogN-O(NloglogN)。虽然堆排序给出最佳平均复杂度，但实际效果不如用Sedgewick增量序列的希尔排序。\n归并排序 归并排序先将待排序列分成多个序列，每个序列各自排序，最后多个有序序列合并成一个有序序列。归并算法的核心便是有序子列的归并。\nvoid Merge(ElementType A[], ElementType TmpA[], int L, int R, int RightEnd){\r//L=左边起始位置，R=右边起始位置，RightEnd=右边终点位置\r//将有序的A[L]-A[R-1]和A[R]-A[RightEnd]归并成一个有序序列\rint LeftEnd,NumElements,Tmp;\rint i;\rLeftEnd=R-1;\t//左边重点位置\rTmp=L;\t//有序序列的起始位置\rNumElements=RightEnd-L+1;\rwhile(L\u0026lt;=LeftEnd\u0026amp;\u0026amp;R\u0026lt;=RightEnd){\rif(A[L]\u0026lt;=A[R])\rTmpA[Tmp++]=A[L++];\t//将左边元素复制到TmpA\relse\rTmpA[Tmp++]=A[R++];\t//将右边元素复制到TmpA\r}\rwhile(L\u0026lt;=LeftEnd)\rTmpA[Tmp++]=A[L++];\t//直接复制左边剩下的\rwhile(R\u0026lt;=RightEnd)\rTmpA[Tmp++]=A[R++];\t//直接复制右边剩下的\rfor(i=0;i\u0026lt;NumElements;i++,RightEnd--)\rA[RightEnd]=TmpA[Rightend];\t//将有序的TmpA复制回A\r}\r 归并排序有两种实现方式，递归算法和非递归算法。\n递归算法 归并排序的递归算法采用的是分而治之的思想。\nvoid MSort(ElementType A[], ElementType TmpA[], int L, int RightEnd){\r//核心递归排序函数\rint Center;\rif(L\u0026lt;RightEnd){\rCenter=(L+RightEnd)/2;\rMSort(A, TmpA, L, Center);\t//递归解决左边\rMSort(A, TmpA, Center+1, RightEnd);\t//递归解决右边\rMerge(A, TmpA, L, Center+1, RightEnd);\t//合并两段有序序列\r}\r}\r T=O(NlogN)，是稳定的算法。\n统一函数接口\nvoid Merge_Sort(ElementType A[], int N){\rElementType *TmpA;\rTmpA=(ElementType *)malloc(N*sizeof(ElementType));\rif(TmpA!=NULL){\rMSort(A, TmpA, 0, N-1);\rfree(TmpA);\r}\relse\rprintf(\u0026quot;空间不足\u0026quot;);\r}\r 非递归算法 归并排序的非递归算法由循环实现。\nvoid Merge_pass(ElementType A[], ElementType TmpA[], int N, int length){\t//length是当前有序子序列的长度\r//两两归并相邻有序子序列\rint i,j;\rfor(i=0;i\u0026lt;=N-2*length;i+=2*length)\rMerge(A, TmpA, i, i+length, i+2*length-1);\rif(i+length\u0026lt;N)\t//归并最后2个子列\rMerge(A, TmpA, i, i+length, N-1);\relse //最后只剩1个子列\rfor(j=i;j\u0026lt;N;j++)\rTmpA[j]=A[j];\r}\rvoid Merge_Sort(ElementType A[], int N){\rint length;\rElementType *TmpA;\rlength=1;\t//初始化子序列长度\rTmpA=(ElementType *)malloc(N*sizeof(ElementType));\rif(TmpA!=NULL){\rwhile(length\u0026lt;N){\rMerge_pass(A, TmpA, N, length);\rlength*=2;\rMerge_pass(TmpA, A, N, length);\rlength*=2;\r}\rfree(TmpA);\r}\relse\rprintf(\u0026quot;空间不足\u0026quot;);\r}\r 快速排序 快速排序采用分而治之的思想，先选取一个主元pivot，比主元小的元素放在前面，而比主元大的元素放在后面。问题就是如何选取主元，这里有个方法是取头、中、尾的中位数，比如8、12、3的中位数是8。另外，如果数据规模较小，快速排序的效率可能还不如插入排序快，所以，当递归的数据规模充分小，则停止递归，直接调用简单排序。\nElementType Median3(ElementType A[], int Left, int Right){\rint Center=(Left+Right)/2;\rif(A[Left]\u0026gt;A[Center])\rSwap(\u0026amp;A[Left],\u0026amp;A[Center]);\rif(A[Left]\u0026gt;A[Right])\rSwap(\u0026amp;A[Left],\u0026amp;A[Right]);\rif(A[Center]\u0026gt;A[Right])\rSwap(\u0026amp;A[Center],\u0026amp;A[Right]);\r//此时，A[Left]\u0026lt;=A[Center]\u0026lt;=A[Right]\rSwap(\u0026amp;A[Center],\u0026amp;A[Right-1]);\t//将基准Pivot藏到右边\r//只需要考虑A[Left+1],···,A[Right-2]\rreturn A[Right-1];\r}\rvoid Qsort(ElementType A[], int Left, int Right){\rint Pivot,Cutoff,Low,High;\rif(Cutoff\u0026lt;=Right-Left){\t//如果序列元素充分多，则进入快速排序\rPivot=Median3(A,Left,Right);\t//选取主元pivot\rLow=Left;\rHigh=Right-1;\rwhile(1){\t//将序列中比基准小的移到基准左边，大的移到基准右边\rwhile(A[++Low]\u0026lt;Pivot);\rwhile(A[--High]\u0026gt;Pivot);\rif(Low\u0026lt;High)\rSwap(\u0026amp;A[Low],\u0026amp;A[High]);\relse\rbreak;\r}\rSwap(\u0026amp;A[Low],\u0026amp;A[Right-1]);\t//将基准放到正确的位置\rQsort(A,Left,Low-1);\t//递归解决左边\rQsort(A,Low+1,Right);\t//递归解决右边\r}\relse\rInsertion_Sort(A+Left,Right-Left+1);\t//元素太少，用插入排序\r}\rvoid Quick_Sort(ElementType A[], int N){\t//统一接口\rQsort(A,0,N-1);\r}\r 如果pivot选取的好，那么快速排序的时间复杂度为T=O(NlogN)。\n基数排序 /* 假设元素最多有MaxDigit个关键字，基数全是同样的Radix */\r#define MaxDigit 4\r#define Radix 10\rtypedef struct Node *PtrToNode;\rstruct Node{\t//桶元素结点\rint key;\rPtrToNode next;\r};\rstruct HeadNode{\t//桶头结点\rPtrToNode head, tail;\r};\rtypedef struct HeadNode Bucket[Radix];\rint GetDigit(int X, int D){\r/* 默认次位D=1, 主位D\u0026lt;=MaxDigit */\rint d, i;\rfor(i=1; i\u0026lt;=D; i++){\rd = X % Radix;\rX /= Radix;\r}\rreturn d;\r}\rvoid LSDRadixSort(ElementType A[], int N){ //基数排序-次位优先\rint D, Di, i;\rBucket B;\rPtrToNode tmp, p, List = NULL; for(i=0; i\u0026lt;Radix; i++) /* 初始化每个桶为空链表 */\rB[i].head = B[i].tail = NULL;\rfor(i=0; i\u0026lt;N; i++){ /* 将原始序列逆序存入初始链表List */\rtmp = (PtrToNode)malloc(sizeof(struct Node));\rtmp-\u0026gt;key = A[i];\rtmp-\u0026gt;next = List;\rList = tmp;\r}\r/* 下面开始排序 */ for(D=1; D\u0026lt;=MaxDigit; D++){ /* 对数据的每一位循环处理 */\r/* 下面是分配的过程 */\rp = List;\rwhile(p){\rDi = GetDigit(p-\u0026gt;key, D); /* 获得当前元素的当前位数字 */\r/* 从List中摘除 */\rtmp = p; p = p-\u0026gt;next;\r/* 插入B[Di]号桶尾 */\rtmp-\u0026gt;next = NULL;\rif(B[Di].head == NULL)\rB[Di].head = B[Di].tail = tmp;\relse{\rB[Di].tail-\u0026gt;next = tmp;\rB[Di].tail = tmp;\r}\r}\r/* 下面是收集的过程 */\rList = NULL; for(Di=Radix-1; Di\u0026gt;=0; Di--){ /* 将每个桶的元素顺序收集入List */\rif(B[Di].head){ /* 如果桶不为空 */\r/* 整桶插入List表头 */\rB[Di].tail-\u0026gt;next = List;\rList = B[Di].head;\rB[Di].head = B[Di].tail = NULL; /* 清空桶 */\r}\r}\r}\r/* 将List倒入A[]并释放空间 */\rfor(i=0; i\u0026lt;N; i++){\rtmp = List;\rList = List-\u0026gt;next;\rA[i] = tmp-\u0026gt;key;\rfree(tmp);\r} }\r//基数排序-主位优先\rvoid MSD(ElementType A[], int L, int R, int D){ /* 核心递归函数: 对A[L]...A[R]的第D位数进行排序 */\rint Di, i, j;\rBucket B;\rPtrToNode tmp, p, List = NULL; if (D==0) return; /* 递归终止条件 */\rfor(i=0; i\u0026lt;Radix; i++) /* 初始化每个桶为空链表 */\rB[i].head = B[i].tail = NULL;\rfor(i=L; i\u0026lt;=R; i++){ /* 将原始序列逆序存入初始链表List */\rtmp = (PtrToNode)malloc(sizeof(struct Node));\rtmp-\u0026gt;key = A[i];\rtmp-\u0026gt;next = List;\rList = tmp;\r}\r/* 下面是分配的过程 */\rp = List;\rwhile (p){\rDi = GetDigit(p-\u0026gt;key, D); /* 获得当前元素的当前位数字 */\r/* 从List中摘除 */\rtmp = p; p = p-\u0026gt;next;\r/* 插入B[Di]号桶 */\rif(B[Di].head == NULL) B[Di].tail = tmp;\rtmp-\u0026gt;next = B[Di].head;\rB[Di].head = tmp;\r}\r/* 下面是收集的过程 */\ri = j = L; /* i, j记录当前要处理的A[]的左右端下标 */\rfor(Di=0; Di\u0026lt;Radix; Di++){ /* 对于每个桶 */\rif(B[Di].head){ /* 将非空的桶整桶倒入A[], 递归排序 */\rp = B[Di].head;\rwhile(p){\rtmp = p;\rp = p-\u0026gt;next;\rA[j++] = tmp-\u0026gt;key;\rfree(tmp);\r}\r/* 递归对该桶数据排序, 位数减1 */\rMSD(A, i, j-1, D-1);\ri = j; /* 为下一个桶对应的A[]左端 */\r} } }\rvoid MSDRadixSort(ElementType A[], int N){\t//统一接口\rMSD(A, 0, N-1, MaxDigit); }\r 排序算法的比较    排序算法 平均时间复杂度 最坏情况下时间复杂度 额外空间复杂度 稳定性     简单选择排序 O(N^2) O(N^2) O(1) 不稳定   冒泡排序 O(N^2) O(N^2) O(1) 稳定   直接插入排序 O(N^2) O(N^2) O(1) 稳定   希尔排序 O(N^d) O(N^2) O(1) 不稳定   堆排序 O(NlogN) O(NlogN) O(1) 不稳定   快速排序 O(NlogN) O(N^2) O(logN) 不稳定   归并排序 O(NlogN) O(NlogN) O(N) 稳定   基数排序 O(P(N+B)) O(P(N+B)) O(N+B) 稳定    ","date":"2019-07-21","permalink":"https://example.com/post/sort/","tags":["算法"],"title":"排序算法"},{"content":"基本概念 堆是一种用数组来实现的完全二叉树。堆分为两种：最大堆(大顶堆)和最小堆(小顶堆)，差别在于结点的排序方式。在最大堆中，任一结点的关键字是其子树所有结点的最大值，而在最小堆中，任一结点的关键字是其子树所有节点的最小值。\n在此我们暂时只讨论最大堆，也叫做优先队列。\n抽象数据类型描述 类型名称：最大堆(MaxHeap) 数据对象集：完全二叉树，每个结点的元素值不小于其子结点的元素值 操作集：最大堆H是MaxHeap类型，元素item是ElementType类型\n MaxHeap Create(int MaxSize)：创建一个空的最大堆 bool IsFull(MaxHeap H)：判断最大堆H是否已满 void Insert(MaxHeap H, ElementType item)：将元素item插入最大堆H bool IsEmpty(MaxHeap H)：判断最大堆H是否为空 ElementType DeleteMax(MaxHeap H)：返回H中最大元素(高优先级)  结构体定义 typedef struct HNode *Heap;\rstruct HNode{\rElementType *Data;\t//存储元素的数组\rint Size;\t//堆中当前元素个数\rint Capacity;\t//堆的最大容量\r};\rtypedef Heap MaxHeap;\t//最大堆\rtypedef Heap MinHeap;\t//最小堆\r 最大堆的创建 MaxHeap Create(int MaxSize){\rMaxHeap H=(MaxHeap)malloc(sizeof(struct HNode));\rH-\u0026gt;Data=(ElementType *)malloc((MaxSize+1)*sizeof(ElementType));\rH-\u0026gt;Size=0;\rH-\u0026gt;Capacity=MaxSize;\rH-\u0026gt;Data[0]=MAXDATA;\t//定义哨兵为大于堆中所有可能元素的值 #define MAXDATA 1000\rreturn H;\r}\r 判断是否为满 bool IsFull(MaxHeap H){\rreturn (H-\u0026gt;Size==H-\u0026gt;Capacity);\r}\r 最大堆的插入 把新元素插入最大堆时，先把新元素放在最大堆的末尾，再与父结点比较大小，如果比父结点大，则交换位置，直到小于父结点，便确定好了插入位置。这一过程叫做上滤。\nvoid Insert(MaxHeap H, ElementType X){\rint i;\rif(IsFull(H)){\rprintf(\u0026quot;最大堆已满\u0026quot;);\rreturn;\r}\ri=++H-\u0026gt;Size;\t//先把新元素放在最大堆的末尾\rfor(;H-\u0026gt;Data[i/2]\u0026lt;X;i/=2)\t//依次与父结点比较\rH-\u0026gt;Data[i]=H-\u0026gt;Data[i/2];\t//上滤X\rH-\u0026gt;Data[i]=X;\r}\r 判断是否为空 bool IsEmpty(MaxHeap H){\rreturn (H-\u0026gt;Size==0);\r}\r 最大元素的返回 因为最大堆的最大元素是根结点，如果直接返回根结点的话，整个堆就被删除了，所以我们把最大元素和最大堆的末尾元素交换，返回并删除末尾元素，再对最大堆进行调整。调整的过程叫做下滤(PercDown)，具体来说就是从根结点开始，与两个子结点的最大值进行比较，小于便与之交换，知道大于子结点的最大值。\nElementType DeleteMax(Heap H){\rint Parent,Child;\rElementType MaxItem,X;\rif(IsEmpty(H)){\rprintf(\u0026quot;最大堆已空\u0026quot;);\rreturn ERROR;\t//#define ERROR -1\r}\rMaxItem=H-\u0026gt;Data[1];\t//取出根结点存放的最大元素\rX=H-\u0026gt;Data[H-\u0026gt;Size--];\t//最大堆的规模-1\rfor(Parent=1;Parent*2\u0026lt;=H-\u0026gt;Size;Parent=Child){\rChild=Parent*2;\rif((Child!=H-\u0026gt;Size)\u0026amp;\u0026amp;(H-\u0026gt;Data[Child]\u0026lt;H-\u0026gt;Data[Child+1]))\rChild++;\t//Child指向左右子结点中的最大值\rif(X\u0026gt;=H-\u0026gt;Data[Child])\rbreak;\t//大于子结点，则找到了位置\relse\rH-\u0026gt;Data[Parent]=H-\u0026gt;Data[Child];\t//下滤X\r}\rH-\u0026gt;Data[Parent]=X;\rreturn MaxItem;\r}\r 最大堆的建立 建立最大堆：将已经存在的N个元素按最大堆的要求存放在一个一维数组中。有两种方法\n 通过插入操作，将N个元素一个个相继插入到一个初始为空的最大堆中，其时间复杂度为O(NlogN)。 在线性复杂度下建立最大堆，将N个元素按输入顺序存入，先满足完全二叉树的结构特性，再调整各结点位置，以满足最大堆的有序特性。具体过程则是从最后一个父结点开始，到根结点，依次进行下滤操作。  我们讨论第2种方法。\nvoid PercDown(MaxHeap H, int p);\rvoid BuildHeap(MaxHeap H){\rint i;\rfor(i=H-\u0026gt;Size/2;i\u0026gt;0;i--)\t//从最后一个父结点k开始，到根结点1\rPercDown(H, i);\r}\rvoid PercDown(MaxHeap H, int p){\rint Parent,Child;\rElementType X;\rX=H-\u0026gt;Data[p];\t//取出父结点存放的值\rfor(Parent=p;Parent*2\u0026lt;=H-\u0026gt;Size;Parent=Child){\rChild=Parent*2;\rif((Child!=H-\u0026gt;Size)\u0026amp;\u0026amp;(H-\u0026gt;Data[Child]\u0026lt;H-\u0026gt;Data[Child+1]))\rChild++;\t//Child指向左右子结点的最大值\rif(X\u0026gt;=H-\u0026gt;Data[Child])\rbreak;\t//大于子结点，则找到了位置\relse\rH-\u0026gt;Data[Parent]=H-\u0026gt;Data[Child];\t//下滤X\r}\rH-\u0026gt;Data[Parent]=X;\t//X放入合适位置\r}\r ","date":"2019-07-18","permalink":"https://example.com/post/heap/","tags":["数据结构"],"title":"堆"},{"content":"对于一般的二叉搜索树，搜索树结点不同插入次序，将导致不同的深度和平均查找长度ASL。甚至在极端的情况下，二叉搜索树会退化称线性的链表，导致插入和查找的复杂度下降到O(n)，所以便提出了平衡二叉树的概念。\n基本概念 平衡因子(Balance Factor, BF)：BF(T)=hL-hR，其中hL、hR分别是T的左、右子树的高度 平衡二叉树(Balanced Binary Tree, AVL树)：一棵二叉树，可以为空；或者任一结点左、右子树高度差的绝对值不超过1，即|BF(T)|\u0026lt;=1\n 给定结点数为n的AVL树的最大高度为O(logn)\n 抽象数据类型描述 类型名称：平衡二叉树 数据对象集：一棵二叉树，任一结点左、右子树高度差的绝对值不超过1 操作集：\n Position Rotation(Position A)：二叉树位置A的平衡调整 AVLTree Insert(AVLTree T, ElementType X)：在平衡二叉树T中插入元素X  结构体定义 typedef struct AVLNode *Position;\rtypedef Position AVLTree;\rstruct AVLNode{\rElementType Data;\t//结点数据\rAVLTree Left;\t//指向左子树\rAVLTree Right;\t//指向右子树\rint Height;\t//树的高度\r};\r 平衡二叉树的调整 在插入一个新的结点后，那些从插入点到根结点的路径上的结点的平衡可能会被改变，导致平衡二叉树的不平衡。 我们把平衡因子大于1且高度最低(深度最深)的结点叫做不平衡的“发现者”，把插入后导致不平衡的新结点叫做“麻烦结点”。那么，不平衡一共有4种不同的情况：\n  对发现者的左孩子的左子树进行一次插入 对发现者的左孩子的右子树进行一次插入 对发现者的右孩子的左子树进行一次插入 对发现者的右孩子的右子树进行一次插入   其中，情况1和4是关于不平衡发现者的镜像对称，而2和3是关于发现者的镜像对称。前一种情况是插入发生在“外边”的情况(即左-左或右-右)，该情况通过对树的一次单旋转完成调整。后一种情况是插入发生在“内部”的情况(即左-右或右-左)，该情况通过稍微复杂些的双旋转来处理。\nLL旋转 对于情况1，麻烦结点是发现者的左子树的左孩子，需要LL旋转来调整(实际上旋转方向是右旋转)。\nint Max(int a, int b){\rreturn a\u0026gt;b?a:b;\r}\rint GetHeight(Position P){\rif(P==NULL)\rreturn -1;\relse\rreturn P-\u0026gt;Height;\r}\rPosition SingleLeftRotation(Position A){\t//A必须要有左子结点B\r//将A与B做左单旋，更新A与B的高度，返回新的根结点B\rPosition B=A-\u0026gt;Left;\rA-\u0026gt;Left=B-\u0026gt;Right;\t//开始旋转\rB-\u0026gt;Right=A;\rA-\u0026gt;Height=Max(GetHeight(A-\u0026gt;Left),GetHeight(A-\u0026gt;Right))+1;\t//更新高度\rB-\u0026gt;Height=Max(GetHeight(B-\u0026gt;Left),A-\u0026gt;Height)+1;\rreturn B;\r}\r RR旋转 对于情况4，麻烦结点是发现者的右子树的右孩子，需要RR旋转来调整(实际上旋转方向是左旋转)。\nPosition SingleRightRotation(Position A){\t//A必须要有右子结点B\r//将A与B做右单旋，更新A与B的高度，返回新的根结点B\rPosition B=A-\u0026gt;Right;\rA-Right=B-\u0026gt;Left;\t//开始旋转\rB-\u0026gt;Left=A;\rA-\u0026gt;Height=Max(GetHeight(A-\u0026gt;Left),GetHeight(A-\u0026gt;Right))+1;\t//更新高度\rB-\u0026gt;Height=Max(A-\u0026gt;Height,GetHeight(B-\u0026gt;Right))+1;\rreturn B;\r}\r LR旋转 对于情况2，麻烦结点是发现者的左子树的右孩子，需要LR旋转来调整(先RR旋转，再LL旋转)\nPosition DoubleLeftRightRotation(Position A){\t//A必须要有左子结点B，B必须要有右子结点C\r//将A、B与C做两次单旋，返回新的根结点C\rA-\u0026gt;Left=SingleRightRotation(A-\u0026gt;Left);\t//将B与C做RR旋转(右单旋)，C被返回\rreturn SingleLeftRotation(A);\t//将A与C做LL旋转(左单旋)，C被返回\r}\r RL旋转 对于情况3，麻烦结点是发现者的右子树的左孩子，需要RL旋转来调整(先LL旋转，再RR旋转)\nPosition DoubleRightLeftRotation(Position A){\t//A必须要有右子结点B，B必须要有左子结点C\r//将A、B与C做两次单旋，返回新的根节点C\rA-\u0026gt;Right=SingleLeftRotation(A-\u0026gt;Right);\t//将B与C做LL旋转(左单旋)，C被返回\rreturn SingleRightRotation(A);\t//将A与C做RR旋转(右单旋)，C被返回\r}\r 插入 在平衡二叉树中插入新结点，通过比较新元素与原有结点元素的大小，确定插入位置(通过递归)，创建新结点，在调整平衡二叉树(上文4种情况)。\nAVLTree Insert(AVLTree T, ElementType X){\t//将X插入AVL树T中，并返回调整后的AVL树\rif(T==NULL){\rT=(AVLTree)malloc(sizeof(struct AVLTree));\t//空子树，则创建一个结点的树\rT-\u0026gt;Data=X;\rT-\u0026gt;Left=T-\u0026gt;Right=NULL;\rT-\u0026gt;Height=0;\r}\relse if(X\u0026lt;T-\u0026gt;Data){\t//如果插入到左子树\rT-\u0026gt;Left=Insert(T-\u0026gt;Left, X);\t//向下递归\rif(GetHeight(T-\u0026gt;Left)-GetHeight(T-\u0026gt;Right)==2)\t//如果不平衡\rif(X\u0026lt;T-\u0026gt;Left-\u0026gt;Data)\t//插入结点是T的左孩子的左结点\rT=SingleLeftRotation(T);\t//左单旋\relse\t//插入结点是T的左孩子的右结点\rT=DoubleLeftRightRotation(T);\t//左-右双旋\r}\relse if(X\u0026gt;T-\u0026gt;Data){\t//如果插入到右子树\rT-\u0026gt;Right=Insert(T-\u0026gt;Right, X);\t//向下递归\rif(GetHeight(T-\u0026gt;Left)-GetHeight(T-\u0026gt;Right)==-2)\t//如果不平衡\rif(X\u0026gt;T-\u0026gt;Right-\u0026gt;Data)\t//插入结点是T的右孩子的右结点\rT=SingleRightRotation(T);\t//右-左双旋\relse\t//插入结点是T的右孩子的左结点\rT=DoubleRightLeftRotation(T);\t//右单旋\r}\r//else X==T-\u0026gt;Data，什么也不做\rT-\u0026gt;Height=Max(GetHeight(T-\u0026gt;Left),GetHeight(T-\u0026gt;Right))+1;\t//更新树高\rreturn T;\r}\r ","date":"2019-06-30","permalink":"https://example.com/post/balanced-binary-tree/","tags":["数据结构"],"title":"平衡二叉树"},{"content":"二叉搜索树是为了解决动态查找问题而提出来的，也叫做二叉排序树或二叉查找树。\n基本概念 二叉搜索树(BST, Binary Search Tree)：一棵二叉树，可以为空；如果不为空，则要满足以下性质：\n 非空左子树的所有键值小于其根结点的键值 非空右子树的所有键值大于其根结点的键值 左、右子树都是二叉搜索树 对二叉搜索树进行中序遍历，即可得到有序的数列\n 抽象数据类型描述 类型名称：二叉搜索树 数据对象集：一棵二叉树，对于树中每个结点X，它的左子树中所有关键字值小于X的关键字值，而它的右子树中所有关键字值大于X的关键字值 操作集：BST是SearchTree类型，X是ElementType类型\n Position Find(SearchTree BST, ElementType X)：从二叉搜索树BST中查找元素X，返回其所在结点的位置 Position FindMin(SearchTree BST)：从二叉搜索树BST中查找并返回最小元素所在结点的位置 Position FindMax(SearchTree BST)：从二叉搜索树BST中查找并返回最大元素所在结点的位置 SearchTree Insert(SearchTree BST, ElementType X)：把元素X插入到二叉搜索树BST中 SearchTree Delete(SearchTree BST, ElementType X)：把元素X从二叉搜索树BST中删除  查找操作 递归形式\nPosition Find(SearchTree BST, ElementType X){\rif(BST=NULL)\rreturn NULL;\rif(X\u0026lt;BST-\u0026gt;Data)\rreturn Find(BST-\u0026gt;Left,X);\t//尾递归\relse if(X\u0026gt;BST-\u0026gt;Data)\rreturn Find(BST-\u0026gt;Right,X);\relse\rreturn BST;\r}\r 迭代形式，执行效率较高\nPosition Find(SearchTree BST, ElementType X){\rwhile(BST){\rif(X\u0026gt;BST-\u0026gt;Data)\rBST=BST-\u0026gt;Right;\relse if(X\u0026lt;BST-\u0026gt;Data)\rBST=BST-\u0026gt;Left;\relse\rreturn BST;\r}\rreturn NULL;\r}\r 查找最大最小元素 最大元素一定在树的最右分支的端结点上，而最小元素一定在树的最左分支的端结点上。 递归实现\nPosition FindMin(SearchTree BST){\rif(!BST)\rreturn NULL;\relse if(BST-\u0026gt;Left==NULL)\rreturn BST;\relse\rreturn FindMin(BST-\u0026gt;Left);\r}\rPosition FindMax(SearchTree BST){\rif(!BST)\rreturn NULL;\relse if(BST-\u0026gt;Right==NULL)\rreturn BST;\relse\rreturn FindMax(BST-\u0026gt;Right);\r}\r 迭代实现\nPosition FindMin(SearchTree BST){\rif(BST)\rwhile(BST-\u0026gt;Left!=NULL)\rBST=BST-\u0026gt;Left;\rreturn BST;\r}\rPosition FindMax(SearchTree BST){\rif(BST)\rwhile(BST-\u0026gt;Right!=NULL)\rBST=BST-\u0026gt;Right;\rreturn BST;\r}\r 插入 二叉搜索树的插入操作，可以采用与Find类似的方法，确定插入位置\nSearchTree Insert(SearchTree BST, ElementType X){\rif(BST==NULL){\t//原树为空，则先创建一棵树，生成一个结点\rBST=(SearchTree)malloc(sizeof(struct TNode));\rBST-\u0026gt;Data=X;\rBST-Left=BST-\u0026gt;Right=NULL;\r}\relse{\rif(X\u0026lt;BST-\u0026gt;Data)\rBST-\u0026gt;Left=Insert(BST-\u0026gt;Left,X); //递归插入左子树\relse if(X\u0026gt;BST-\u0026gt;Data)\rBST-\u0026gt;Right=Insert(BST-\u0026gt;Right,X);\t//递归插入右子树\r//else X在树中已存在，则什么都不做\r}\rreturn BST;\r}\r 删除 删除一个元素，要考虑三种情况：\n 要删除的是叶结点：直接删除，再修改其父结点指针，置为NULL 要删除的结点只有一个孩子结点：将其父结点的指针指向要删除的孩子结点 要删除的结点有左、右两颗子树：用右子树的最小元素或者左子树的最大元素替代被删除结点  SearchTree Delete(SearchTree BST, ElementType X){\rPosition tmp;\rif(BST==NULL)\rprintf(\u0026quot;要删除的元素未找到\\n\u0026quot;);\relse{\rif(X\u0026lt;BST-\u0026gt;Data)\rBST-\u0026gt;Left=Delete(BST-\u0026gt;Left,X);\t//从左子树递归删除\relse if(X\u0026gt;BST-\u0026gt;Data)\rBST-\u0026gt;Right=Delete(BST-\u0026gt;Right,X);\t//从右子树递归删除\relse{\t//找到了要被删除元素的位置\rif(BST-\u0026gt;Left\u0026amp;\u0026amp;BST-\u0026gt;Right){\t//被删除结点有两个子节点\rtmp=FindMin(BST-\u0026gt;Right);\t//找到右子树的最小元素\rBST-\u0026gt;Data=tmp-\u0026gt;Data;\t//替代被删除结点\rBST-\u0026gt;Right=Delete(BST-\u0026gt;Right,BST-\u0026gt;Data);\t//删除右子树的最小元素\r}\relse{\t//被删除结点有一个或零个子结点\rtmp=BST;\rif(BST-\u0026gt;Left==NULL)\t//只有右孩子或无子结点\rBST=BST-\u0026gt;Right;\relse\t//只有左孩子\rBST=BST-\u0026gt;Left;\rfree(tmp);\r}\r}\r}\rreturn BST;\r}\r ","date":"2019-06-30","permalink":"https://example.com/post/binary-search-tree/","tags":["数据结构"],"title":"二叉搜索树"},{"content":"基本概念 二叉树：一个有穷的结点的集合，这个集合可以为空，若不为空，则它是由根节点和称为其左子树和右子树的两个不相交的二叉树组成。\n有几种特殊的二叉树，分别是斜二叉树、完全二叉树和满二叉树。 二叉树的几个重要性质：\n 一个二叉树第i层的最大结点数为：2^(i-1)，i\u0026gt;=1 深度为k的二叉树有最大结点总数为：2^k-1，k\u0026gt;=1 对任何非空二叉树T，若n0表示叶结点的个数，n2是度为2的非叶结点的个数，那么二者满足关系n0=n2+1\n 抽象数据类型描述 类型名称：二叉树 数据对象集：一个有穷的结点集合，若不为空，则由根结点和其左、右二叉子树组成 操作集：BT是BinTree类型，Item是ElementType类型\n BinTree CreateBinTree()：创建一个二叉树 bool IsEmpty(BinTree BT)：判断BT是否为空 void Traversal(BinTree BT)：遍历，按某顺序访问每个结点 常用的遍历方法有： void PreOrderTraversal(BinTree BT)：先序遍历——根、左子树、右子树 void InOrderTraversal(BinTree BT)：中序遍历——左子树、根、右子树 void PostOrderTraversal(BinTree BT)：后序遍历——左子树、右子树、根 void LevelOrderTraversal(BinTree BT)：层次遍历——从上到下、从左到右  顺序存储结构 对于完全二叉树，我们可以按从上至下、从左到右的顺序进行存储 若二叉树根节点的序号为1，则n个结点的完全二叉树的结点父子关系为：\n 非根结点(序号i\u0026gt;1)的父结点的序号是i/2(向下取整) 结点(序号i)的左孩子结点的序号是2i(2i\u0026lt;=n，否则没有左孩子) 结点(序号i)的右孩子结点的序号是2i+1(2i+1\u0026lt;=n，否则没有右孩子)\n 对于一般二叉树，我们也可以采取这种结构，但是会造成空间浪费，所以二叉树普遍采用链式存储。\n链式存储结构 结构体定义 typedef struct TNode *Position;\rtypedef Position BinTree;\t//二叉树类型\rstruct TNode{\rElementType Data;\t//结点数据\rBinTree Left;\t//指向左子树\rBinTree Right;\t//指向右子树\r};\r 先序遍历 递归形式\nvoid PreOrderTraversal(BinTree BT){\rif(BT){\rprintf(\u0026quot;%d \u0026quot;,BT-\u0026gt;Data);\rPreOrderTraversal(BT-\u0026gt;Left);\rPreOrderTraversal(BT-\u0026gt;Right);\r}\r}\r 非递归形式 一般而言，递归算法转化为非递归形式的基本思路是使用堆栈。\nvoid PreOrderTraversal(BinTree BT){\rBinTree T=BT;\rStack S=CreateStack(MaxSize);\rwhile(T||!IsEmpty(S)){\rwhile(T){\rprintf(\u0026quot;%d \u0026quot;,T-\u0026gt;Data);\t//先打印根结点\rPush(S,T);\t//一直向左并沿途结点压入堆栈直到没有左孩子结点\rT=T-\u0026gt;Left;\r}\rif(!IsEmpty(S)){\rT=Pop(S);\t//弹出结点\rT=T-\u0026gt;Right;\t//转向右子树\r}\r}\r}\r 中序遍历 递归形式\nvoid InOrderTraversal(BinTree BT){\rif(BT){\rInOrderTraversal(BT-\u0026gt;Left);\rprintf(\u0026quot;%d \u0026quot;,BT-\u0026gt;Data);\rInOrderTraversal(BT-\u0026gt;Right);\r}\r}\r 非递归形式\nvoid InOrderTraversal(BinTree BT){\rBinTree T=BT;\rStack S=CreateStack(MaxSize);\rwhile(T||!IsEmpty(S)){\rwhile(T){\rPush(S,T);\t//一直向左并将沿途结点压入堆栈\rT=T-\u0026gt;Left;\r}\rif(!IsEmpty(S)){\rT=Pop(S);\rprintf(\u0026quot;%d \u0026quot;,T-\u0026gt;Data);\rT=T-\u0026gt;Right;\r}\r}\r}\r 后序遍历 递归形式\nvoid PostOrderTraversal(BinTree BT){\rif(BT){\rPostOrderTraversal(BT-\u0026gt;Left);\rPostOrderTraversal(BT-\u0026gt;Right);\rprintf(\u0026quot;%d \u0026quot;,BT-\u0026gt;Data);\r}\r}\r 非递归形式(较为复杂)\n\r 层序遍历 二叉树的层序遍历实现需要借助队列\nvoid LevelOrderTraversal(BinTree BT){\rQueue Q;\rBinTree T;\rif(!BT)\t//空树直接返回\rreturn;\rQ=CreateQueue();\rAddQ(Q,BT);\t//根结点入队\rwhile(!IsEmpty(Q)){\rT=DeleteQ(Q);\rprintf(\u0026quot;%d \u0026quot;,T-\u0026gt;Data);\rif(T-\u0026gt;Left)\rAddQ(Q,T-\u0026gt;Left);\t//左结点入队\rif(T-\u0026gt;Right)\rAddQ(Q,T-\u0026gt;Right);\t//右结点入队\r}\r}\r ","date":"2019-06-29","permalink":"https://example.com/post/binary-tree/","tags":["数据结构"],"title":"二叉树"},{"content":"队列是一种基本的数据结构\n基本概念 队列(Queue)：具有一定操作约束的线性表\n 只能在一端插入，而在另一端删除 数据插入：入队列(AddQ) 数据删除：出队列(DeleteQ) 先进先出：First In First Out(FIFO)\n 抽象数据类型描述 类型名称：队列 数据对象集：一个有0个或多个元素的有穷线性表 操作集：长度为MaxSize的队列Q是Queue，队列元素item是ElementType类型\n Queue CreateQueue(int MaxSize)：生成长度为MaxSize的空队列 int IsFullQ(Queue Q)：判断队列Q是否已满 void AddQ(Queue Q, ElementType item)：将数据元素item插入队列Q中 int IsEmptyQ(Queue Q)：判断队列Q是否已空 ElementType DeleteQ(Queue Q)：删除队头数据元素并返回  顺序存储实现 队列的顺序存储结构通常由一个一维数组和一个记录队列头元素位置的变量front以及一个记录队列尾元素位置的变量rear组成。我们通常使用循环队列，即队列头尾相连，这样就不会造成空间浪费。\n结构体定义 typedef int Position\rstruct QNode{\rElementType *Data;\rPosition Front,Rear;\rint MaxSize;\r};\rtypedef struct QNode *Queue;\r 初始化队列 Queue CreateQueue(int MaxSize){\rQueue Q=(Queue)malloc(sizeof(struct QNode));\rQ-\u0026gt;Data=(ElementType *)malloc(MaxSize*sizeof(ElementType));\rQ-\u0026gt;Front=Q-\u0026gt;Rear=0;\rQ-\u0026gt;MaxSize=MaxSize;\rreturn Q;\r}\r 是否满队列 Rear是队列尾的位置，Front是队列头的位置，但也有一种情况是Rear是队列尾再后一个的位置，Front是队列头的位置，这样的话程序略有不同。\nbool IsFull(Queue Q){\rreturn ((Q-\u0026gt;Rear+1)%Q-\u0026gt;MaxSize==Q-\u0026gt;Front);\r}\r 入队 void AddQ(Queue Q, ElementType X){\rif(IsFull(Q))\rprintf(\u0026quot;队列满\u0026quot;);\relse{\rQ-\u0026gt;Rear=(Q-\u0026gt;Rear+1)%Q-\u0026gt;MaxSize;\rQ-\u0026gt;Data[Q-\u0026gt;Rear]=X;\r}\r}\r 是否空队列 bool IsEmpty(Queue Q){\rreturn (Q-\u0026gt;Front==Q-\u0026gt;Rear);\r}\r 具体实现的时候还要加一个flag变量，来确认是出队还是入队以判断是队列空还是满。\n出队 ElementType DeleteQ(Queue Q){\rif(IsEmpty(Q)){\rprintf(\u0026quot;队列空\u0026quot;);\rreturn ERROR;\r}\relse{\rElementType X=Q-\u0026gt;Data[Q-\u0026gt;Front];\rQ-\u0026gt;Front=(Q-\u0026gt;Front+1)%MaxSize;\rreturn X;\r}\r}\r 链式存储实现 队列的链式存储结构可以用一个单链表实现，插入和删除操作分别在链表的两端进行，front指向链表头，rear指向链表尾。\n结构体定义 typedef struct Node *PtrToNode;\rstruct Node{\t//队列中的结点\rElementType Data;\rPtrToNode Next;\r};\rtypedef PtrToNode Position;\rstruct QNode{\rPosition Front,Rear;\t//队列头尾指针\rint MaxSize;\r};\rtypedef struct QNode *Queue;\r 初始化队列 Queue CreateQueue(int MaxSize){\rQueue Q=(Queue)malloc(sizeof(struct QNode));\rQ-\u0026gt;Front=Q-\u0026gt;Rear=NULL;\rQ-\u0026gt;MaxSize=MaxSize;\rreturn Q:\r}\r 是否空队列 bool IsEmpty(Queue Q){\rreturn (Q-\u0026gt;Front==NULL);\r}\r 入队 void AddQ(Queue Q, ElementType X){\rPosition tmp=(PtrToNode)malloc(sizeof(struct Node));\rtmp-\u0026gt;Data=X;\rtmp-\u0026gt;Next=NULL;\rQ-\u0026gt;Rear=tmp;\r}\r 出队 ElementType DeleteQ(Queue Q){\rPosition FrontCell;\rElementType FrontElem;\rif(IsEmpty(Q)){\rprintf(\u0026quot;队列空\u0026quot;);\rreturn ERROR;\r}\relse{\rFrontCell=Q-\u0026gt;Front;\rif(Q-\u0026gt;Front==Q-\u0026gt;Rear)\t//队列只有一个元素\rQ-\u0026gt;Front=Q-\u0026gt;Rear=NULL;\relse\t//队列有多个元素\rQ-\u0026gt;Front=Q-\u0026gt;Front-\u0026gt;Next;\rFrontElem=FrontCell-\u0026gt;Data;\rfree(FrontCell);\rreturn FrontElem;\r}\r}\r ","date":"2019-06-25","permalink":"https://example.com/post/queue/","tags":["数据结构"],"title":"队列"},{"content":"栈是一种基本的数据结构\n基本概念 栈(Stack)：具有一定操作约束的线性表。\n 只在一端(栈顶，Top)做插入、删除操作 插入数据：入栈(Push) 删除数据：出栈(Pop) 后入先出：Last In First Out(LIFO)\n 抽象数据类型描述 类型名称：栈 数据对象集：一个有0个或多个元素的有穷线性表 操作集：长度为MaxSize的堆栈属于Stack，堆栈元素X属于ElementType\n Stack CreateStack(int MaxSize)：生成空栈，其最大长度为MaxSize bool IsFull(Stack S)：判断栈S是否已满 void Push(Stack S, ElementType X)：将元素X压入栈 bool IsEmpty(Stack S)：判断栈S是否为空 ElementType Pop(Stack S)：删除并返回栈顶元素  顺序存储实现 栈的顺序存储结构通常由一个一维数组和一个记录栈顶元素位置的变量组成。\n结构体定义 typedef int Position;\rstruct SNode{\rElementType *Data;\t//存储元素的数组\rPosition Top;\t//栈顶位置\rint MaxSize;\t//最大容量\r};\rtypedef struct SNode *Stack;\r 初始化栈 Stack CreateStack(int MaxSize){\t//初始化最大容量为MaxSize的空栈\rStack S=(Stack)malloc(sizeof(struct SNode));\rS-\u0026gt;Data=(ElementType *)malloc(MaxSize*sizeof(ElementType));\t//分配内存\rS-\u0026gt;Top=-1;\t//空栈栈顶位置为-1\rS-\u0026gt;MaxSize=MaxSize;\rreturn S;\r}\r 是否满栈 判断栈是否满了，可以根据栈顶位置与最大容量的关系。\nbool IsFull(Stack S){\rreturn (S-\u0026gt;Top==S-\u0026gt;MaxSize-1);\r}\r 入栈 void Push(Stack S, ElementType X){\rif(IsFull(S))\t//先判断栈是否已满\rprintf(\u0026quot;栈已满\u0026quot;);\relse{\rS-\u0026gt;Data[++(S-\u0026gt;Top)]=X;\t//先把栈顶位置加1，再入栈\rreturn true;\r}\r}\r 是否空栈 判断栈是否是空栈，可以根据栈顶位置是否为-1来判断。\nbool IsEmpty(Stack S){\rreturn (S-\u0026gt;Top==-1);\r}\r 出栈 ElementType Pop(Stack S){\rif(IsEmpty(S)){\t//先判断栈是否已空\rprintf(\u0026quot;栈已空\u0026quot;);\rreturn ERROR;\t//define ERROR -1\r}\relse\rreturn S-\u0026gt;Data[(S-\u0026gt;Top)--];\t//先出栈，再栈顶位置减1\r}\r 链式存储实现 栈的链式存储结构实际上就是一个单链表，叫做链栈。插入和删除操作只能在链栈的栈顶进行，因为确定单链表的表尾比较耗费时间，我们一般把栈顶指针Top放在表头，也就是在链栈的头部进行插入和删除操作。因为是链式结构，也就不存在栈满这种情况。\n结构体定义 typedef struct SNode *PtrToSNode;\rstruct SNode{\rElementType Data;\rPtrToSNode Next;\r};\rtypedef PtrToSNode Stack;\r 初始化栈 在初始化的时候，一般先定义一个头结点Head，这个头结点不存放数据，只是作为链表的起始。\nStack CreateStack(){\rStack S;\rS=(Stack)malloc(sizeof(struct SNode));\t//内存分配\rS-\u0026gt;Next=NULL;\rreturn S;\r}\r 是否空栈 bool IsEmpty(Stack S){\rreturn (S-\u0026gt;Next==NULL);\r}\r 入栈 void Push(Stack S, ElementType X){\rPtrToSNode tmp;\rtmp=(PtrToSNode)malloc(sizeof(struct SNode));\rtmp-\u0026gt;Data=X;\rtmp-\u0026gt;Next=S-\u0026gt;Next;\rS-\u0026gt;Next=tmp;\r}\r 出栈 ElementType Pop(Stack S){\rPtrToSNode FirstCell;\rElementType TopElem;\rif(IsEmpty(S)){\rprintf(\u0026quot;栈已空\\n\u0026quot;);\rreturn ERROR;\t//define ERROR -1\r}\relse{\rFirstCell=S-\u0026gt;Next;\rTopElem=FirstCell-\u0026gt;Data;\rS-\u0026gt;Next=FirstCell-\u0026gt;Next;\rfree(FirstCell);\rreturn TopElem;\r}\r}\r ","date":"2019-06-20","permalink":"https://example.com/post/stack/","tags":["数据结构"],"title":"栈"},{"content":"线性表是最基本的数据结构。\n基本概念 线性表(Linear List)：由同类型数据元素构成有序序列的线性结构。\n 表中元素个数称为线性表的长度 线性表没有元素时称为空表 表起始位置为表头，表结束位置为表尾\n 抽象数据类型描述 类型名称：线性表 数据对象集：线性表是n个元素构成的有序序列(a1,a2,···,an) 操作集：线性表L属于List，整数i表示位置，元素X属于ElementType\n List MakeEmpty()：初始化一个空线性表L ElementType FindKth(List L, Position K)：根据位序K，返回相应元素 int Find(List L, ElementType X)：在线性表L中查找X的第一次出现位置 void Insert(List L, ElementType X, Position i)：在位序i前插入一个新元素X void Delete(List L, Position i)：删除指定位序i的元素 int Length(List L)：返回线性表L的长度n  顺序存储实现 线性表的顺序存储实现利用数组的连续存储空间顺序存放线性表的个元素，也叫做顺序表。\n结构体定义 typedef int Position;\rtypedef struct LNode *List;\rstruct LNode{\rElementType Data[MAXSIZE]; //用数组实现，MAXSIZE为最大存储容量\rPostion Last;\t//末尾元素位置\r};\r 访问下标为i的元素：L.Data[i]或PtrL-\u0026gt;Data[i] 线性表的长度：L.Last+1或PtrL-\u0026gt;L+1\n初始化 初始化也就是建立空的顺序表\nList MakeEmpty(){\rList L;\rL=(List)malloc(sizeof(struct LNode));\t//内存分配\rL-\u0026gt;Last=-1; //没有元素时为-1\treturn L;\r}\r 查找 Position Find(List L, ElementType X){\rPosition i=0;\rwhile(i\u0026lt;=L-\u0026gt;Last\u0026amp;\u0026amp;L-\u0026gt;Data[i]!=X)\ri++;\rif(i\u0026gt;L-\u0026gt;Last)\rreturn -1;\t//没找到，返回-1\relse\rreturn i;\t//找到，返回存储位置\r}\r 查找成功的平均比较次数为(n+1)/2，平均时间性能为O(n)。\n插入 要在第i个位置上插入一个值为X的元素，先从表尾开始到位序为i的元素依次往后移位，空出i，再将X插入。\nvoid Insert(List L, ElementType X, Position i){\rPosition j;\rif(L-\u0026gt;Last==MAXSIZE-1){\rprintf(\u0026quot;表满\u0026quot;);\rreturn;\r}\rif(i\u0026lt;0||i\u0026gt;L-\u0026gt;Last+1){\rprintf(\u0026quot;位置不合法\u0026quot;);\rreturn;\r}\rfor(j=L-\u0026gt;Last; j\u0026gt;=i; --j)\rL-\u0026gt;Data[j+1]=L-\u0026gt;Data[j];\t//后移,第i个位置，数组下标为i-1\rL-\u0026gt;Data[j]=X;\t//插入\rL-\u0026gt;Last++;\t//Last依旧是表尾\r}\r 插入的平均移动次数为n/2，平均时间性能为O(n)。\n删除 要删除表的位序为i的元素，直接从i+1到表尾依次往前移位，覆盖前一个位置的元素。\nvoid Delete(List L, Position i){\rPosition j;\rif(i\u0026lt;0||i\u0026gt;PtrL-\u0026gt;Last){\rprintf(\u0026quot;不存在%d号元素\u0026quot;,i);\rreturn;\r}\rfor(j=i; j\u0026lt;PtrL-\u0026gt;Last; ++j)\rPtrL-\u0026gt;Data[j]=PtrL-\u0026gt;Data[j+1];\t//前移，第i个位置，数组下标为i-1\rPtrL-\u0026gt;Last--;\r}\r 删除的平均移动次数为(n-1)/2，平均时间性能为O(n)。\n链式存储实现 线性表的链式存储实现不要求逻辑上相邻的两个元素物理上也相邻，通过链建立起数据元素之间的逻辑关系，也叫做链表。 在链表中，每个结点除了要存储数据元素之外，还要存储一个指向其后继结点的指针。当然，结点可以有多个指针指向不同位置，而在此只讨论结点只有一个指针，即单链表。同时，结点有两个指针，一个指向前驱，一个指向后继，叫做双链表。\n结构体定义 typedef struct LNode *PtrToLNode;\rstruct LNode{\rElementType Data;\t//数据元素\rPtrToLNode Next;\t//指向后继的指针\r};\rtypedef PtrToLNode Position;\rtypedef PtrToLNode List;\r 求表长度 int Length(List L){\rPosition p=L;\t//p指向链表头结点\rint j=0;\rwhile(p){\rp=p-\u0026gt;Next;\r++j;\t//当前p指向第j个结点\r}\rreturn j;\r}\r 时间性能为O(n)。\n查找 查找分为两种情况，一种是按序号查找，一种是按值查找。\nPosition FindKth(List L, int K){\t//按序号查找，找第K个元素\rPosition p=L;\rint i=1;\rwhile(p-\u0026gt;Next\u0026amp;\u0026amp;i\u0026lt;K){\rp=p-\u0026gt;Next;\r++i;\r}\rif(i==K)\rreturn p;\t//找到第K个，返回指针\relse\rreturn NULL;\t//未找到\r}\rPosition Find(List L, ElementType X){\t//按值查找，找元素X的位置\rPositon p=L;\rwhile(p\u0026amp;\u0026amp;p-\u0026gt;Data!=X)\rp=p-\u0026gt;Next;\rif(p)\rreturn p;\relse\rreturn NULL; }\r 查找的平均时间性能为O(n)。\n插入 要在结点P之前插入新结点，先构造一个新结点，再找到P之前的结点，然后修改指针，插入新结点。\nvoid Insert(List L, ElementType X, Position P){\rPosition tmp, pre;\rfor(pre=L; pre\u0026amp;\u0026amp;pre-\u0026gt;Next!=P; pre=pre-\u0026gt;Next)\t//找到P的前一个结点\r;\rif(pre==NULL)\rprintf(\u0026quot;插入位置参数错误\\n\u0026quot;);\relse{\rtmp=(Position)malloc(sizeof(struct LNode));\t//分配内存，构造结点\rtmp-\u0026gt;Data=X;\rtmp-\u0026gt;Next=P;\rpre-\u0026gt;Next=tmp;\r}\r}\r 平均查找次数为n/2，平均时间性能为O(n)。\n删除 要删除结点P，先找到P之前的结点，然后修改指针，最后释放内存空间。\nvoid Delete(List L, Position P){\rPosition tmp, pre;\rfor(pre=L; pre\u0026amp;\u0026amp;pre-\u0026gt;Next!=P; pre=pre-\u0026gt;Next)\t//找到P的前一个结点\r;\rif(pre==NULL||P==NULL)\rprintf(\u0026quot;删除位置参数错误\\n\u0026quot;);\relse{\rtmp=P\rpre-\u0026gt;Next=tmp-\u0026gt;Next;\t//删除P\rfree(tmp);\t//释放空间\r}\r}\r 平均查找次数为n/2，平均时间性能为O(n)。\n","date":"2019-06-19","permalink":"https://example.com/post/linear-list/","tags":["数据结构"],"title":"线性表"},{"content":"关于const关键字，有几个注意点。\nconst的引用 首先是把引用绑定到const对象上，与普通引用不同，对常量的引用不能被用来修改它所绑定的对象。\n\tconst int ci=1024;\rconst int \u0026amp;r1=ci; //正确：引用及其对应的对象都是常量\rr1=42;\t//错误：r1是对常量的引用，不可修改\rint \u0026amp;r2=ci;\t//错误：ci是常量，需要常量引用\r 对于非常量对象、字面值、一般表达式，也允许用常量引用绑定，但此时不可通过修改常量引用来修改原非常量对象。\n\tint i=42;\rconst int \u0026amp;r1=i;\t//正确：允许将const int\u0026amp;绑定到非const对象上\rconst int \u0026amp;r2=42;\t//正确：42是字面值，r2是常量引用\rconst int \u0026amp;r3=r1*2;\t//正确：r1*2是一般表达式，r3是常量引用\rint \u0026amp;r4=r1*2;\t//错误：r1*2是一般表达式，r4是非常量引用\rr1=1;\t//错误：r1是常量引用，不可修改r1\ri=1;\t//正确：i不是常量\r 也就是说，常量引用只是对引用可参与的操作做出了限定，而对于引用的对象本身是否是const未作限定。\n指针和const 关于指针和const，可以分为指向常量的指针和常量指针。 对于指向常量的指针，可以类比常量引用，不能通过该指针修改所指对象的值，对于所指对象是否是常量也未作限定。\n\tconst int i=42;\tint *p1=\u0026amp;i;\t//错误：i是常量，p1是普通指针\rconst int *pi=\u0026amp;i;\t//正确：i是常量，pi是指向常量的指针\r*pi=1;\t//错误：不能给*pi赋值\rint j=42;\tconst *pj=\u0026amp;j;\t//正确：j不是常量，pj是指向常量的指针\r*pj=1;\t//错误：不能通过给*pj赋值来修改j的值\rj=1;\t//正确：j不是常量\r 对于常量指针，在定义时必须初始化，以后不可修改常量指针的值，即不能将该指针指向其他对象。\n\tint i=0,j=0;\tint *const pi=\u0026amp;i;\t//正确：pi是常量指针\r*pi=1;\t//正确：可以给*pi赋值来修改i的值\rpi=\u0026amp;j;\t//错误：pi是常量指针，不能给pi赋值\rdouble pi=3.14,x=0.0;\rconst double *const pip=\u0026amp;pi;\t//正确：pip是指向常量的常量指针\r*pip=1.1;\t//错误：不能给*pip赋值来修改pi的值\rpip=\u0026amp;x;\t//错误：不能给pip赋值来将pip指向x\r 其实，指向常量的常量指针和常量引用才是最为相似的。对于常量引用来讲，我们不能通过给引用赋值来修改所绑定的对象，而引用本身在定义时就必须初始化，之后便不能修改引用（不能将引用绑定到其他对象上）。这两个性质与指向常量的常量指针极为相似，就如上文const double *const pip=\u0026amp;pi; 我们不能通过pip来修改pi的值（给*pip赋值），也不能将pip指向其他对象（给pip赋值）。深入学习的话，是因为c++的引用本身就是由指针来实现的，只不过对外隐藏了自身的值。\n顶层const、底层const 介绍完上面的内容，对于顶层const、底层const也就很好理解了。因为指针本身是否是常量和指针所指的对象是否是常量是两个相互独立的问题，所以c++用顶层const表示指针本身是常量，而用底层const表示指针所指的对象是常量。更一般的是，顶层const可以表示任意对象是常量。\n\tint i=1;\rint *const p1=\u0026amp;i;\t//p1是顶层const\rconst int ci=1;\t//ci是顶层const\rconst int *p2=\u0026amp;ci;\t//p2是底层const\r const和类成员 const除了修饰一般变量，还可以修饰类中的成员，可以分为常成员函数和常数据成员。\n使用const修饰的函数为常成员函数，声明的格式为： 类型说明符 函数名(参数表) const; 常成员函数有以下特点：\n  常成员函数不能更新目的对象的数据成员。 如果一个类的对象是常对象，那么通过该常对象只能调用它的常成员函数，不能调用其他成员函数。 const可以用于对重载函数的区分。 void print();\rvoid print() const;\r 非const的对象调用该函数，两个重载的函数都可以匹配，但编译器会选择不带const的函数。   当类的数据成员是常量时，构造函数对该数据成员进行初始化，就只能通过初始化列表。\n","date":"2019-04-27","permalink":"https://example.com/post/cpp-const/","tags":["c++"],"title":"c++ const关键字"},{"content":"看《c++ primer》这本书已经很久了，也不敢说自己掌握了多少。之前过了一遍，这本书几乎覆盖了c++的全部知识点，很丰富，但也很杂。\n最近在重看这本书，顺便把每节的习题给做了，并把部分习题代码上传到了github。\n附github链接：https://github.com/keichw/cppprimer-ans\n","date":"2019-04-19","permalink":"https://example.com/post/cppprimer-ans/","tags":["c++"],"title":"c++ primer学习"}]