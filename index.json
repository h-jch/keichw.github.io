[{"content":"基本概念 拓扑序：如果图中从V到W有一条有向路径，则V一定排在W之前。满足此条件的顶点序列称为一个拓扑序，那么拓扑排序就是获得一个拓扑序的过程。另外，如果有合理的拓扑序，则必定是有向无环图。\n拓扑排序算法 下面介绍一个比较好的拓扑排序算法\n伪代码如下：\nvoid TopSort(){\rfor(图中每个顶点V)\rif(Indegree[V]==0)\rEnqueue(Q,V);\rwhile(!IsEmpty(Q)){\rV=Dequeue(Q);\r输出V，或者记录V的输出序号；\rcnt++;\rfor(V的每个邻接点W)\rif(--Indegree[W]==0)\rEnqueue(Q,W);\r}\rif(cnt!=|V|)\rERROR(\u0026quot;图中有回路\u0026quot;);\r}\r C语言实现如下：\nbool TopSort(LGraph Graph, Vertex TopOrder[]){\t//对Graph进行拓扑排序，TopOrder[]顺序存储排序后的顶点下标\rint Indegree[MaxVertexNum],cnt;\rVertex V;\rPtrToAdjVNode W;\rQueue Q=CreateQueue(Graph-\u0026gt;Nv);\rfor(V=0;V\u0026lt;Graph-\u0026gt;Nv;V++)\t//初始化Indegree[]\rIndegree[V]=0;\rfor(V=0;V\u0026lt;Graph-\u0026gt;Nv;V++)\t//遍历图，得到Indegree[]\rfor(W=Graph-\u0026gt;G[V].FirstEdge;W;W=W-\u0026gt;Next)\rIndegree[W-\u0026gt;AdjV]++;\t//对有向边\u0026lt;V,W-\u0026gt;AdjV\u0026gt;累计终点的入度\rfor(V=0;V\u0026lt;Graph-\u0026gt;Nv;V++)\rif(Indegree[V]==0)\t//将所有入度为0的顶点入队\rAddQ(Q,V);\rcnt=0;\rwhile(!IsEmpty(Q)){\rV=DeleteQ(Q);\t//弹出一个入度为0的顶点\rTopOrder[cnt++]=V;\t//将V存为结果序列的下一个元素\rfor(W=Graph-\u0026gt;G[V].FirstEdge;W;W=W-\u0026gt;Next)\t//对于V的每一个邻接点W-\u0026gt;AdjV\rif(--Indegree[W-\u0026gt;AdjV]==0)\t//若删除V使得W-\u0026gt;AdjV的入度为0\rAddQ(Q,W-\u0026gt;AdjV);\t//则将W-\u0026gt;AdjV入队\r}\rif(cnt!=Graph-\u0026gt;Nv)\t//图中有回路\rreturn fasle;\relse\rreturn true;\r}\r 时间复杂度T=O(|V|+|E|)，此算法也可以用来检测有向图是否是无环图。\n","date":"2019-07-30","permalink":"https://example.com/post/topsort/","tags":["算法"],"title":"拓扑排序"},{"content":"基本概念 最小生成树\n 是一棵树  无回路，向生成树中任加一条边都一定构成回路 |V|个顶点一定有|V|-1条边   是生成树  包含全部顶点 |V|-1条边都在图里   边的权重最小  贪心算法 对于如何最小生成树的算法，我们使用贪心算法。\n 什么是“贪”：每一步都要好的 什么是“好”：权重最小的边 需要约束  只能用图里有的边 只能正好用掉|V|-1条边 不能有回路    Prim算法 类似Dijkstra算法\nVertex FindMinDist(MGraph Graph, WeightType dist[]){\t//返回未被收录顶点中dist最小者\rVertex MinV,V;\rWeightType MinDist=INFINITY;\rfor(V=0;V\u0026lt;Graph-\u0026gt;Nv;V++){\t//对于图中每个顶点V\rif(dist[V]!=0\u0026amp;\u0026amp;dist[V]\u0026lt;MinDist){\t//若V未被收录且dist[V]更小\rMinDist=dist[V];\t//更新最小距离\rMinV=V;\t//更新对应顶点\r}\r}\rif(MinDist\u0026lt;INFINITY)\rreturn MinV;\relse\rreturn false;\r}\rint Prim(MGraph Graph, LGraph MST){\t//将最小生成树保存为邻接表存储的图MST，返回最小权重和\rWeightType dist[MaxVertexNum],TotalWeight;\rVertex parent[MaxVertexNum],V,W;\rint VCount;\rEdge E;\rfor(V=0;V\u0026lt;Graph-\u0026gt;Nv;V++){\t//初始化，默认初始顶点下标为0\rdist[V]=Graph-\u0026gt;G[0][V];\rparent[V]=0;\r}\rTotalWeight=0;\rVCount=0;\rMST=CreateGraph(Graph-\u0026gt;Nv);\t//创建包含所有顶点但没有边的邻接表存储的图\rE=(Edge)malloc(sizeof(struct ENode));\t//建立空的边结点\rdist[0]=0;\rVCount++;\rparent[0]=-1;\rwhile(1){\rV=FindMinDist(Graph, dist);\t//找到未被收录顶点中dist最小者\rif(V==ERROR)\rbreak;\rE-\u0026gt;V1=parent[V];\t//将V及相应的边\u0026lt;parent[V],V\u0026gt;收录进MST\rE-\u0026gt;V2=V;\rE-\u0026gt;Weight=dist[V];\rInsertEdge(MST,E);\rTotalWeight+=dist[V];\rdist[V]=0;\rVCount++;\rfor(W=0;W\u0026lt;Graph-\u0026gt;Nv;W++)\rif(dist[W]!=0\u0026amp;\u0026amp;Graph-\u0026gt;G[V][W]\u0026lt;INFINITY){\t//若W未被收录且W是V的邻接点\rif(Graph-\u0026gt;G[V][W]\u0026lt;dist[W]){\t//收录进V使得dist[W]变小\rdist[W]=Graph-\u0026gt;G[V][W];\t//更新dist[W]\rparent[W]=V;\t//更新树\r}\r}\t}\rif(VCount\u0026lt;Graph-\u0026gt;Nv)\t//MST中的顶点不到|V|个\rTotalWeight=ERROR;\rreturn TotalWeight;\r}\r 对于稠密图，时间复杂度T=O(|V|^2)\nKruskal算法 Kruskal算法是将森林合并成树。 伪代码如下：\nvoid Kruskal(Graph G){\rMST={ };\rwhile(MST中不到|V|-1条边 \u0026amp;\u0026amp; E中还有边){\r从E中取一条权重最小的边E(V,W);\t//最小堆\r将E(V,W)从E中删除;\rif(E(V,W)不在MST中构成回路)\t//并查集\r将E(V,W)加入MST;\relse\r彻底无视E(V,W);\r}\rif(MST中不到|V|-1条边)\rERROR(\u0026quot;生成树不存在\u0026quot;);\r}\r C语言代码如下，摘自浙大陈越奶奶数据结构：\n/* 邻接表存储 - Kruskal最小生成树算法 */\r/*-------------------- 顶点并查集定义 --------------------*/\rtypedef Vertex ElementType; /* 默认元素可以用非负整数表示 */\rtypedef Vertex SetName; /* 默认用根结点的下标作为集合名称 */\rtypedef ElementType SetType[MaxVertexNum]; /* 假设集合元素下标从0开始 */\rvoid InitializeVSet( SetType S, int N )\r{ /* 初始化并查集 */\rElementType X;\rfor ( X=0; X\u0026lt;N; X++ ) S[X] = -1;\r}\rvoid Union( SetType S, SetName Root1, SetName Root2 )\r{ /* 这里默认Root1和Root2是不同集合的根结点 */\r/* 保证小集合并入大集合 */\rif ( S[Root2] \u0026lt; S[Root1] ) { /* 如果集合2比较大 */\rS[Root2] += S[Root1]; /* 集合1并入集合2 */\rS[Root1] = Root2;\r}\relse { /* 如果集合1比较大 */\rS[Root1] += S[Root2]; /* 集合2并入集合1 */\rS[Root2] = Root1;\r}\r}\rSetName Find( SetType S, ElementType X )\r{ /* 默认集合元素全部初始化为-1 */\rif ( S[X] \u0026lt; 0 ) /* 找到集合的根 */\rreturn X;\relse\rreturn S[X] = Find( S, S[X] ); /* 路径压缩 */\r}\rbool CheckCycle( SetType VSet, Vertex V1, Vertex V2 )\r{ /* 检查连接V1和V2的边是否在现有的最小生成树子集中构成回路 */\rVertex Root1, Root2;\rRoot1 = Find( VSet, V1 ); /* 得到V1所属的连通集名称 */\rRoot2 = Find( VSet, V2 ); /* 得到V2所属的连通集名称 */\rif( Root1==Root2 ) /* 若V1和V2已经连通，则该边不能要 */\rreturn false;\relse { /* 否则该边可以被收集，同时将V1和V2并入同一连通集 */\rUnion( VSet, Root1, Root2 );\rreturn true;\r}\r}\r/*-------------------- 并查集定义结束 --------------------*/\r/*-------------------- 边的最小堆定义 --------------------*/\rvoid PercDown( Edge ESet, int p, int N )\r{ /* 改编代码4.24的PercDown( MaxHeap H, int p ) */\r/* 将N个元素的边数组中以ESet[p]为根的子堆调整为关于Weight的最小堆 */\rint Parent, Child;\rstruct ENode X;\rX = ESet[p]; /* 取出根结点存放的值 */\rfor( Parent=p; (Parent*2+1)\u0026lt;N; Parent=Child ) {\rChild = Parent * 2 + 1;\rif( (Child!=N-1) \u0026amp;\u0026amp; (ESet[Child].Weight\u0026gt;ESet[Child+1].Weight) )\rChild++; /* Child指向左右子结点的较小者 */\rif( X.Weight \u0026lt;= ESet[Child].Weight ) break; /* 找到了合适位置 */\relse /* 下滤X */\rESet[Parent] = ESet[Child];\r}\rESet[Parent] = X;\r}\rvoid InitializeESet( LGraph Graph, Edge ESet )\r{ /* 将图的边存入数组ESet，并且初始化为最小堆 */\rVertex V;\rPtrToAdjVNode W;\rint ECount;\r/* 将图的边存入数组ESet */\rECount = 0;\rfor ( V=0; V\u0026lt;Graph-\u0026gt;Nv; V++ )\rfor ( W=Graph-\u0026gt;G[V].FirstEdge; W; W=W-\u0026gt;Next )\rif ( V \u0026lt; W-\u0026gt;AdjV ) { /* 避免重复录入无向图的边，只收V1\u0026lt;V2的边 */\rESet[ECount].V1 = V;\rESet[ECount].V2 = W-\u0026gt;AdjV;\rESet[ECount++].Weight = W-\u0026gt;Weight;\r}\r/* 初始化为最小堆 */\rfor ( ECount=Graph-\u0026gt;Ne/2; ECount\u0026gt;=0; ECount-- )\rPercDown( ESet, ECount, Graph-\u0026gt;Ne );\r}\rint GetEdge( Edge ESet, int CurrentSize )\r{ /* 给定当前堆的大小CurrentSize，将当前最小边位置弹出并调整堆 */\r/* 将最小边与当前堆的最后一个位置的边交换 */\rSwap( \u0026amp;ESet[0], \u0026amp;ESet[CurrentSize-1]);\r/* 将剩下的边继续调整成最小堆 */\rPercDown( ESet, 0, CurrentSize-1 );\rreturn CurrentSize-1; /* 返回最小边所在位置 */\r}\r/*-------------------- 最小堆定义结束 --------------------*/\rint Kruskal( LGraph Graph, LGraph MST )\r{ /* 将最小生成树保存为邻接表存储的图MST，返回最小权重和 */\rWeightType TotalWeight;\rint ECount, NextEdge;\rSetType VSet; /* 顶点数组 */\rEdge ESet; /* 边数组 */\rInitializeVSet( VSet, Graph-\u0026gt;Nv ); /* 初始化顶点并查集 */\rESet = (Edge)malloc( sizeof(struct ENode)*Graph-\u0026gt;Ne );\rInitializeESet( Graph, ESet ); /* 初始化边的最小堆 */\r/* 创建包含所有顶点但没有边的图。注意用邻接表版本 */\rMST = CreateGraph(Graph-\u0026gt;Nv);\rTotalWeight = 0; /* 初始化权重和 */\rECount = 0; /* 初始化收录的边数 */\rNextEdge = Graph-\u0026gt;Ne; /* 原始边集的规模 */\rwhile ( ECount \u0026lt; Graph-\u0026gt;Nv-1 ) { /* 当收集的边不足以构成树时 */\rNextEdge = GetEdge( ESet, NextEdge ); /* 从边集中得到最小边的位置 */\rif (NextEdge \u0026lt; 0) /* 边集已空 */\rbreak;\r/* 如果该边的加入不构成回路，即两端结点不属于同一连通集 */\rif ( CheckCycle( VSet, ESet[NextEdge].V1, ESet[NextEdge].V2 )==true ) {\r/* 将该边插入MST */\rInsertEdge( MST, ESet+NextEdge );\rTotalWeight += ESet[NextEdge].Weight; /* 累计权重 */\rECount++; /* 生成树中边数加1 */\r}\r}\rif ( ECount \u0026lt; Graph-\u0026gt;Nv-1 )\rTotalWeight = -1; /* 设置错误标记，表示生成树不存在 */\rreturn TotalWeight;\r}\r 时间复杂度T=O(|E|log|E|)\n","date":"2019-07-30","permalink":"https://example.com/post/minimum-spanning-tree/","tags":["数据结构"],"title":"最小生成树"},{"content":"最短路径问题的抽象 在网络中，求两个不同顶点之间的所有路径中，边的权值之和最小的那一条路径。\n 这条路径就是两点之间的最短路径 第一个顶点为源点 最后一个顶点为终点  问题分类 单源最短路径问题：从某固定源点出发，求其到所有其他顶点的最短路径。\n （有向）无权图 （有向）有权图 多源最短路径问题：求任意两顶点之间的最短路径  无权图的单源最短路径算法 按照递增(非递减)的顺序找出到各个顶点的最短路，类似BFS。\nvoid Unweighted(LGraph Graph, int dist[], int path[], Vertex S){\t//dist[]和path[]全部初始化为-1\rQueue Q;\rVertex V;\rPtrToAdjVNode W;\rQ=CreateQueue(Graph-\u0026gt;Nv);\t//创建空队列\rdist[S]=0;\t//S为源点\rAddQ(Q,S);\rwhile(!IsEmpty(Q)){\rV=DeleteQ(Q);\rfor(W=Graph-\u0026gt;G[V].FirstEdge;W;W=W-\u0026gt;Next)\t//对V的每个邻接点W-\u0026gt;AdjV\rif(dist[W-\u0026gt;AdjV]==-1){\t//若W-\u0026gt;AdjV未被访问过\rdist[W-\u0026gt;AdjV]=dist[V]+1;\t//S到W-\u0026gt;AdjV的距离更新\rpath[W-\u0026gt;AdjV]=V;\t//将V记录在S到W-\u0026gt;AdjV的路径上\rAddQ(Q,W-\u0026gt;AdjV);\r}\r}\r}\r 时间复杂度T=O(|V|+|E|)\n有权图的单源最短路径算法 按照递增的顺序找出到各个顶点的最短路径，我们使用Dijkstra算法。\n Dijkstra算法  令S={源点s+已经确定了最短路径的顶点vi} 对任一未收录的顶点v，定义dist[v]为s到v的最短路径长度，但该路径仅经过S中的顶点。即路径{s-\u0026gt;(vi)-\u0026gt;v}的最小长度 若路径是按照递增(非递减)的顺序生成的，则  真正的最短路径必须只经过S中的顶点 每次从未收录的顶点中选一个dist最小的收录(贪心) 增加一个v进入S，可能影响另外一个w的dist值  dist[w]=min{dist[w], dist[v]+\u0026lt;v,w\u0026gt;的权重}        Vertex FindMinDist(MGraph Graph, int dist[], int collected[]){\t//返回未被收录顶点中dist最小者\rVertex MinV,V;\rint MinDist=INFINITY;\rfor(V=0;V\u0026lt;Graph-\u0026gt;Nv;V++){\rif(collected[V]==false\u0026amp;\u0026amp;dist[V]\u0026lt;MinDist){\t//若V未被收录，且dist[V]更小\rMinDist=dist[V];\t//更新最小距离\rMinV=V;\t//更新对应顶点\r}\r}\rif(MinDist\u0026lt;INFINITY)\t//若找到最小dist\rreturn MinV;\t//返回对应顶点\relse\rreturn ERROR;\r}\rbool Dijkstra(MGraph Graph, int dist[], int path[], Vertex S){\rint collected[MaxVertexNum];\rVertex V,W;\rfor(V=0;V\u0026lt;Graph-\u0026gt;Nv;V++){\t//初始化，默认邻接矩阵中不存在的边用INFINITY表示\rdist[V]=Graph-\u0026gt;G[S][V];\rif(dist[V]\u0026lt;INFINITY)\rpath[V]=S;\relse\rpath[V]=-1;\rcollected[V]=false;\r}\rdist[S]=0;\t//源点S\rcollected[S]=true;\rwhile(1){\rV=FindMinDist(Graph, dist, collected);\t//找到未被收录顶点中dist最小者V\rif(V==ERROR)\rbreak;\rcollected[V]=true;\t//收录V\rfor(W=0;W\u0026lt;Graph-\u0026gt;Nv;W++)\t//对图中的每个顶点W\rif(collected[W]==false\u0026amp;\u0026amp;Graph-\u0026gt;G[V][W]\u0026lt;INFINITY){\t//若W未被收录且W是V的邻接点\rif(Graph-\u0026gt;G[V][W]\u0026lt;0)\t//若有副边，不能正确解决\rreturn false;\rif(dist[V]+Graph-\u0026gt;G[V][W]\u0026lt;dist[W]){\t//若收录V使得dist[W]变小\rdist[W]=dist[V]+Graph-\u0026gt;G[V][W];\t//更新dist[W]\rpath[W]=V;\t//更新S到W的路径\r}\r}\r}\rreturn true;\r}\r 多源最短路径算法 对于多源最短路径算法，有两种方法\n 方法1：直接将单源最短路径算法调用|V|遍  T=O(|V|^3+|E|*|V|) 对于稀疏图效果比较好   方法2：Floyd算法  T=O(|V|^3) 对于稠密图效果比较好    在这里我们介绍Floyd算法\n Floyd算法  Dk[i][j]=路径{i-\u0026gt;{l\u0026lt;=k}-\u0026gt;j}的最小长度 D0，D1，···，D|V|-1[i][j]即给出了i到j的真正最短距离 当Dk-1已经完成，递推到Dk时：  如果k不在最短路径{i-\u0026gt;{l\u0026lt;=k}-\u0026gt;j}里面，则Dk=Dk-1 如果k在最短路径{i-\u0026gt;{l\u0026lt;=k}-\u0026gt;j}里面，则该路径必定由两段最短路径组成：Dk[i][j]=Dk-1[i][k]+Dk-1[k][j]      bool Floyd(MGraph Graph, WeightType D[][MaxVertexNum], Vertex path[][MaxVertexNum]){\rVertex i,j,k;\rfor(i=0;i\u0026lt;Graph-\u0026gt;Nv;i++)\t//初始化\rfor(j=0;j\u0026lt;Graph-\u0026gt;Nv;j++){\rD[i][j]=Graph-\u0026gt;G[i][j];\rpath[i][j]=-1;\r}\rfor(k=0;k\u0026lt;Graph-\u0026gt;Nv;k++)\rfor(i=0;i\u0026lt;Graph-\u0026gt;Nv;i++)\rfor(j=0;j\u0026lt;Graph-\u0026gt;Nv;j++)\rif(D[i][k]+D[k][j]\u0026lt;D[i][j]){\rD[i][j]=D[i][k]+D[k][j];\rif(i==j\u0026amp;\u0026amp;D[i][j]\u0026lt;0)\t//若发现负值圈\rreturn false;\t//不能正确解决，返回错误\rpath[i][j]=k;\r}\rreturn true;\r}\r ","date":"2019-07-30","permalink":"https://example.com/post/shortest-path/","tags":["数据结构"],"title":"最短路径问题"},{"content":"基本概念 图表示多对多的关系。包含\n 一组顶点：通常用V(Vertex)表示顶点集合 一组边：通常用E(Edge)表示边的集合  边是顶点对：(v,w)是集合E的元素，其中v，w是集合V的元素 有向边\u0026lt;v,w\u0026gt;表示从v指向w的边(单行线) 不考虑重边和自回路    抽象数据类型定义 类型名称：图 数据对象集：G(V,E)由一个非空的有限顶点集合V和一个有限边集合E组成 操作集：对于任意图G，以及v，e\n Graph Create()：建立并返回空图 Graph InsertVertex(Graph G, Vertex v)：将v插入G Graph InsertEdge(Graph G, Edge e)：将e插入G void DFS(Graph G, Vertex v)：从顶点v出发深度优先遍历图G void BFS(Graph G, Vertex v)：从顶点v出发广度优先遍历图G void ShortestPath(Graph G, Vertex v, int Dist[])：计算图G中顶点v到任意其他顶点的最短距离 void MST(Graph G)：计算图G的最小生成树  图的表示 图有两种表示方法，邻接矩阵和邻接表\n我们可以创建一个二维数组G[N][N]，若\u0026lt;vi,vj\u0026gt;是G中的边，则G[i][j]=1，否则为0。对于有向图，邻接矩阵是对称的，而对于无向图则不是。对于网络，G[i][j]的值是边\u0026lt;vi,vj\u0026gt;的权重，如果没有边，则为-∞。\n邻接矩阵的优点\n 直观、简单、好理解 方便检查任意一对顶点间是否存在边 方便找任一顶点的所有“邻接点”（有边直接相连的顶点） 方便计算任一顶点的“度”（从该点出发的边数为“出度”，指向该点的边数为“入度”）  无向图：对应行（或列）非0元素的个数 有向图：对应行非0元素的个数是“出度”，对应列非0元素的个数是“入度”    邻接矩阵的缺点\n 浪费空间：存稀疏图（点很多而边很少）有大量无效元素  对稠密图（特别是完全图）还是很合算的   浪费时间：统计稀疏图中一共有多少条边  同时，我们可以创建一个指针数组G[N]，对应矩阵每行一个链表，只存非0元素。对于网络，链表结构中要增加权重的域。\n邻接表的优点\n 方便找任一顶点的所有“邻接点” 节约稀疏图的空间  需要N个头指针+2E个结点（每个结点至少2个域）   方便计算任一顶点的“度”  无向图：任一顶点的度就是链表的长度 有向图：只能计算“出度”，需要构造“逆邻接表”（存指向自己的边）来方便计算“出度”    邻接表的缺点\n 不方便检查任意一对顶点间是否存在边  邻接矩阵表示 结构体定义 #define MaxVertexNum 100\r#define INFINITY 65535\rtypedef int Vertex; //用顶点下标表示顶点，为整型\rtypedef int WeightType;\rtypedef char DataType;\rtypedef struct ENode *PtrToENode;\rstruct ENode{\t//边的定义\rVertex V1,V2;\t//有向边\u0026lt;v1,v2\u0026gt;\rWeightType Weight;\t//权重\r};\rtypedef PtrToENode Edge;\rtypedef struct GNode *PtrToGNode;\rstruct GNode{\t//图结点的定义\rint Nv;\t//顶点数\rint Ne;\t//边数\rWeightType G[MaxVertexNum][MaxVertexNum];\t//邻接矩阵\rDataType Data[MaxVertexNum];\t//存顶点的数据，如果顶点不存数据，可以省略\r};\rtypedef PtrToGNode MGraph;\r 图的初始化 MGraph CreateGraph(int VertexNum){ //初始化一个有VertexNum个顶点但没有边的图\rVertex V,W;\rMGraph Graph;\rGraph=(MGraph)malloc(sizeof(struct GNode)); //建立图\rGraph-\u0026gt;Nv=VertexNum;\rGraph-\u0026gt;Ne=0;\rfor(V=0;V\u0026lt;Graph-\u0026gt;Nv;V++) //初始化邻接矩阵，顶点编号为0-(Nv-1)\rfor(W=0;W\u0026lt;Graph-\u0026gt;Nv;W++)\rGraph-\u0026gt;G[V][W]=INFINITY;\rreturn Graph;\r}\r 边的插入 void InsertEdge(MGraph Graph, Edge E){\rGraph-\u0026gt;G[E-\u0026gt;V1][E-\u0026gt;V2]=E-\u0026gt;Weight; //插入边\u0026lt;V1,V2\u0026gt;\rGraph-\u0026gt;G[E-\u0026gt;V2][E-\u0026gt;V1]=E-\u0026gt;Weight; //若是无向图，还要插入边\u0026lt;V2,V1\u0026gt;\r}\r 图的建立 MGraph BuildGraph(){\rMGraph Graph;\rEdge E;\rVertex V;\rint Nv,i;\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;Nv); //读入顶点个数\rGraph=CreateGraph(Nv); //初始化有Nv个顶点但没有边的图\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;(Graph-\u0026gt;Ne)); //读入边数\rif(Graph-\u0026gt;Ne!=0){\rE=(Edge)malloc(sizeof(struct ENode)); //建立边结点\rfor(i=0;i\u0026lt;Graph-\u0026gt;Ne;i++){\rscanf(\u0026quot;%d %d %d\u0026quot;,\u0026amp;(E-\u0026gt;V1),\u0026amp;(E-\u0026gt;V2),\u0026amp;(E-\u0026gt;Weight)); //读入边\rInsertEdge(Graph,E); //插入边\r}\r}\rfor(V=0;V\u0026lt;Graph-\u0026gt;Nv;V++)\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;(Graph-\u0026gt;Data[V])); //如果顶点有数据，则读入数据\rreturn Graph;\r}\r 邻接表表示 结构体定义 #define MaxVertexNum 100\rtypedef int Vertex; //顶点下标表示顶点，为整型\rtypedef int WeightType;\rtypedef char DataType;\rtypedef struct ENode *PtrToENode;\rstruct ENode{ //边的定义\rVertex V1,V2; //有向边\u0026lt;V1,V2\u0026gt;\rWeightType Weight;\r};\rtypedef PtrToENode Edge;\rtypedef struct AdjVNode *PtrToAdjVNode;\rstruct AdjVNode{ //邻接点的定义\rVertex AdjV; //邻接点下标\rWeightType Weight; //边权重\rPtrToAdjVNode Next; //指向下一个邻接点的指针\r};\rtypedef struct Vnode{ //顶点表头结点的定义\rPtrToAdjVNode FirstEdge; //边表头指针\rDataType Data; //存顶点的数据\r}AdjList[MaxVertexNum]; //AdjList是邻接表类型的数组\rtypedef struct GNode *PtrToGNode;\rstruct GNode{ //图结点的定义\rint Nv; //顶点数\rint Ne; //边数\rAdjList G; //邻接表\r};\rtypedef PtrToGNode LGraph;\r 图的初始化 LGraph CreateGraph(int VertexNum){ //初始化一个有VertexNum个顶点但没有边的图\rVertex V;\rLGraph Graph;\rGraph=(LGraph)malloc(sizeof(struct GNode)); //建立图\rGraph-\u0026gt;Nv=VertexNum;\rGraph-\u0026gt;Ve=0;\rfor(V=0;V\u0026lt;Graph-\u0026gt;Nv;V++) //初始化邻接表头指针，定点编号0-(Graph-\u0026gt;Nv-1)\rGraph-\u0026gt;G[V].FirstEdge=NULL;\rreturn Graph;\r}\r 边的插入 void InsertEdge(LGraph Graph, Edge E){\rPtrToAdjVNode NewNode;\r//插入边\u0026lt;V1,V2\u0026gt;\rNewNode=(PtrToAdjVNode)malloc(sizeof(struct AdjVNode)); //为V2建立新的邻接点\rNewNode-\u0026gt;AdjV=E-\u0026gt;V2;\rNewNode-\u0026gt;Weight=E-\u0026gt;Weight;\r//将V2插入V1的表头\rNewNode-\u0026gt;Next=Graph-\u0026gt;G[E-\u0026gt;V1].FirstEdge;\rGraph-\u0026gt;G[E-\u0026gt;V1].FirstEdge=NewNode;\r//若是无向图，还要插入边\u0026lt;V2,V1\u0026gt;\rNewNode=(PtrToAdjVNode)malloc(sizeof(struct AdjVNode)); //为V1建立新的邻接点\rNewNode-\u0026gt;AdjV=E-\u0026gt;V1;\rNewNode-\u0026gt;Weight=E-\u0026gt;Weight;\r//将V1插入V2的表头\rNewNode-\u0026gt;Next=Graph-\u0026gt;G[E-\u0026gt;V2].FirstEdge;\rGraph-\u0026gt;G[E-\u0026gt;V1].FirstEdge=NewNode;\r}\r 图的建立 LGraph BuildGraph(){\rLGraph Graph;\rEdge E;\rVertex V;\rint Nv,i;\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;Nv); //读入顶点个数\rGraph=CreateGraph(Nv); //初始化有Nv个顶点但没有边的图\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;(Graph-\u0026gt;Ne)); //读入边数\rif(Graph-\u0026gt;Ne!=0){\rE=(Edge)malloc(sizeof(struct ENode)); //建立边结点\rfor(i=0;i\u0026lt;Graph-\u0026gt;Ne;i++){\rscanf(\u0026quot;%d %d %d\u0026quot;,\u0026amp;(E-\u0026gt;V1),\u0026amp;(E-\u0026gt;V2),\u0026amp;(E-\u0026gt;Weight)); //读入边的起点、终点、权重\rInsertEdge(Graph,E); //插入边\r}\r}\rfor(V=0;V\u0026lt;Graph-\u0026gt;Nv;V++) //如果顶点有数据，读入数据\rscanf(\u0026quot;%d\u0026quot;,\u0026amp;(Graph-\u0026gt;G[V].Data));\rreturn Graph;\r}\r 图的遍历 图的遍历有两种方法，深度优先搜索(DFS)和广度优先搜索(BFS)。\n深度优先搜索 图的深度优先搜索类似于树的先序遍历。若有N个顶点、E条边，时间复杂度为\n 用邻接表存储图，有O(N+E) 用邻接矩阵存储图，有O(N^2)  伪代码如下：\nvoid DFS(Vertex V){\rvisited[V]=true;\rfor(V的每个邻接点W)\rif(!visited[W])\rDFS(W);\r}\r C语言代码如下：\nvoid Visit(Vertex V){\rprintf(\u0026quot;正在访问顶点%d\u0026quot;,V);\r}\rvoid DFS(LGraph Graph, Vertex V, void (*Visit)(Vertex)){ //以V为出发点对邻接表存储的图Graph进行DFS\rPtrToAdjVNode W;\rVisit(V); //访问第V个顶点\rVisited[V]=true; //Visited[]为全局变量，初始化为false，已访问则标记为true\rfor(W=Graph-\u0026gt;G[V].FirstEdge;W;W=W-\u0026gt;Next) //对V的每个邻接点W-\u0026gt;AdjV\rif(!Visited[W-\u0026gt;AdjV]) //若W-\u0026gt;AdjV未被访问\rDFS(Graph,W-\u0026gt;AdjV,Visit); //则递归访问\r}\r 广度优先搜索 图的广度优先搜索类似于树的层序遍历，需要使用队列。若有N个顶点、E条边，时间复杂度为\n 用邻接表存储图，有O(N+E) 用邻接矩阵存储图，有O(N^2)  伪代码如下：\nvoid BFS(Vertex V){\rvisited[V]=true;\rEnqueue(V,Q);\rwhile(!IsEmpty(Q)){\rV=Dequeue(Q);\rfor(V的每个邻接点W)\rif(!visited[W]){\rvisited[W]=true;\rEnqueue(W,Q);\r}\r}\r}\r C语言代码如下：\nbool IsEdge(MGraph Graph, Vertex V, Vertex W){ //判断\u0026lt;V,W\u0026gt;是否是图Graph中的一条边，即W是否是V的邻接点\rreturn Graph-\u0026gt;G[V][W]\u0026lt;INFINITY?true:false;\r}\rvoid BFS(MGraph Graph, Vertex S, void (*Visit)(Vertex)){ //以S为出发点对邻接矩阵存储的图Graphj进行BFS\rQueue Q;\rVertex V,W;\rQ=CreateQueue(MaxSize); //创建空队列\rVisit(S);\rVisited[S]=true;\rAddQ(Q,S); //S入队\rwhile(!IsEmpty(Q)){\rV=DeleteQ(Q); //出队\rfor(W=0;W,Graph-\u0026gt;Nv;W++) //对于图中的每个顶点W\rif(!Visited[W]\u0026amp;\u0026amp;IsEdge(Graph,V,W)){ //如果W是V的临界点且未被访问过\rVisit(W);\rVisited[W]=true;\rAddQ(Q,W);\r}\r}\r}\r ","date":"2019-07-27","permalink":"https://example.com/post/graph/","tags":["数据结构"],"title":"图"},{"content":"基本概念 void X_Sort(ElementType A[], int N)\r  N是正整数 只讨论基于比较的排序(\u0026lt;、=、\u0026gt;有定义) 只讨论内部排序 稳定性：任意两个相等的数据，排序前后的相对位置不发生变化 没有一种排序是任何情况下都表现最好的  简单排序 冒泡排序 每一趟冒泡可以确定至少一个元素的位置，确定一个最大值，也就是说，排序过程中序列尾部是排好序的。冒泡排序是稳定的算法。\nvoid Bubble_Sort(ElementType A[], int N){\rint P,i;\rfor(P=N-1;P\u0026gt;=0;P--){\rint flag=0;\rfor(i=0;i\u0026lt;P;i++){\t//一趟冒泡\rif(A[i]\u0026gt;A[i+1]){\rSwap(A[i],A[i+1]);\rflag=1;\t//标识发生了交换\r}\r}\rif(flag==0)\t//全程无交换\rbreak;\r}\r}\r 最好情况：顺序 T=O(N)，最坏情况：逆序 T=O(N^2)\n插入排序 从1号元素开始，依次取出元素与其前面的元素比较，将其插入到合适的位置，排序过程中序列前部是排好序的。插入排序是稳定的算法。\nvoid Insertion_Sort(ElementType A[], int N){\rint P,i;\rElementType Tmp;\rfor(P=1;P\u0026lt;N;P++){\rTmp=A[P];\t//取出未排序序列中的第一个元素\rfor(i=P;i\u0026gt;0\u0026amp;\u0026amp;A[i-1]\u0026gt;Tmp;i--)\rA[i]=A[i-1];\t//依次与已排序序列中的元素比较并右移\rA[i]=Tmp;\t//放入适合的位置\r}\r}\r 最好情况：顺序 T=O(N)，最坏情况：逆序 T=O(N^2)\n 简单排序的平均时间复杂度为O(N^2)。\n希尔排序 希尔排序是由Donald Shell提出的，所以叫希尔排序。 要进行希尔排序，首先要定义增量序列Dm \u0026gt; Dm-1 \u0026gt; ··· \u0026gt; D1 = 1，然后就在待排序列上对每个增量序列Dk进行“Dk-间隔”排序(k=m,m-1,···,1)。其中要注意的是，“Dk-间隔”有序的序列，在执行“Dk-1-间隔”排序后，仍然是“Dk-间隔”有序的。 那么，希尔排序的关键就是确定增量序列，之后的每个“Dk-间隔”排序就可以采用简单排序来做。\n 原始希尔排序 Dm=[N/2], Dk=[Dk+1/2] 向下取整  void Shell_Sort(ElementType A[], int N){\rfor(D=N/2;D\u0026gt;0;D/=2){\t//希尔增量序列\rfor(P=D;P\u0026lt;N;P++){\t//插入排序\rTmp=A[P];\rfor(i=P;i\u0026gt;=D\u0026amp;\u0026amp;A[i-D]\u0026gt;Tmp;i-=D)\rA[i]=A[i-D];\rA[i]=Tmp;\r}\r}\r}\r 最坏情况：T=O(N^2)\n但是这样选取增量序列有个问题，增量元素不互质，那么小增量可能根本不起作用。\n这样也就产生了跟多增量序列\n  Hibbard增量序列\n Dk=2^k-1 —— 相邻元素互质 最坏情况：T=O(N^3/2) 猜想：Tavg=O(N^5/4)    Sedgewick增量序列\n {1,5,19,41,109,···} —— 9×4^i-9×2^i+1或4^i-3×2^i+1 猜想：Tavg=O(N^7/6), Tworst=O(N^4/3)    void Shell_Sort(ElementType A[], int N){\r//希尔排序 - 用Sedgewick增量序列\rint Si,D,P,i;\rElementTypde Tmp;\r//只列出一小部分增量\rint Sedgewick[]={929,505,209,109,41,19,5,1,0};\rfor(Si=0;Sedgewick[Si]\u0026gt;=N;Si++)\r;\t//初始的增量Sedgewick[Si]不能超过待排序列的长度，把超过的部分滤除\rfor(D=Sedgewick[Si];D\u0026gt;0;D=Sedgewick[++Si]){\rfor(P=D;P\u0026lt;N;P++){\t//插入排序\rTmp=A[P];\rfor(i=P;i\u0026gt;=D\u0026amp;\u0026amp;A[i-D]\u0026gt;Tmp;i-=D)\rA[i]=A[i-D];\rA[i]=Tmp;\r}\r}\r}\r 堆排序 堆排序是利用最小堆的特性来对待排序列进行排序。\n 算法1 用待排序列中的元素建最小堆，再从堆中返回最小元素到新的数组中，最后把新的排好序的数组复制到原序列中。  void Heap_Sort(ElementType A[], int N){\rBuildHeap(A);\t//O(N)\rfor(i=0;i\u0026lt;N;i++)\rTmpA[i]=DeleteMin(A);\t//O(logN)\rfor(i=0;i\u0026lt;N;i++)\t//O(N)\rA[i]=TmpA[i];\r}\r T=O(NlogN)，需要额外O(N)的空间，并且复制元素需要时间。\n 算法2 用待排序列中的元素建最大堆，再对堆直接操作，把根结点最大值和堆的最后一个元素交换，则确定了最大值的位置，然后对其余元素进行调整(下滤)，依次进行上述操作。相比算法1不需要额外的空间。  void Swap(ElementType *a, ElementType *b){\rElementType t=*a;\r*a=*b;\r*b=t;\r}\rvoid PercDown(ElementType A[], int p, int N){\r//改编自堆的下滤操作PrecDown(MaxHeap H, int p)，参考堆的那篇博客\r//将N个元素的数组中以A[p]为根的子堆调整为最大堆\rint Parent,Child;\rElementType X;\rX=A[p];\t//取出根结点的值\rfor(Parent=p;Parent*2+1\u0026lt;N;Parent=Child){\rChild=Parent*2+1;\rif((Child!=N-1)\u0026amp;\u0026amp;(A[Child]\u0026lt;A[Child+1]))\rChild++;\t//Child指向左右子结点的最大者\rif(X\u0026gt;=A[Child])\tbreak;\t//找到了合适位置\relse\rA[Parent]=A[Child];\t//下滤\r}\rA[Parent]=X;\r}\rvoid Heap_Sort(ElementType A[], int N){\rint i;\rfor(i=N/2-1;i\u0026gt;=0;i--)\rPercDown(A,i,N);\t//建最大堆，从最后一个父结点开始往前，依次下滤\rfor(i=N-1;i\u0026gt;0;i--){\rSwap(\u0026amp;A[0],\u0026amp;A[i]);\t//交换最大值和末尾的值，相当于删除最大堆顶\rPercDown(A,0,i);\t//对剩余子堆进行调整(下滤)\r}\r}\r 堆排序处理N个不同元素的随机排列的平均比较次数是2NlogN-O(NloglogN)。虽然堆排序给出最佳平均复杂度，但实际效果不如用Sedgewick增量序列的希尔排序。\n归并排序 归并排序先将待排序列分成多个序列，每个序列各自排序，最后多个有序序列合并成一个有序序列。归并算法的核心便是有序子列的归并。\nvoid Merge(ElementType A[], ElementType TmpA[], int L, int R, int RightEnd){\r//L=左边起始位置，R=右边起始位置，RightEnd=右边终点位置\r//将有序的A[L]-A[R-1]和A[R]-A[RightEnd]归并成一个有序序列\rint LeftEnd,NumElements,Tmp;\rint i;\rLeftEnd=R-1;\t//左边重点位置\rTmp=L;\t//有序序列的起始位置\rNumElements=RightEnd-L+1;\rwhile(L\u0026lt;=LeftEnd\u0026amp;\u0026amp;R\u0026lt;=RightEnd){\rif(A[L]\u0026lt;=A[R])\rTmpA[Tmp++]=A[L++];\t//将左边元素复制到TmpA\relse\rTmpA[Tmp++]=A[R++];\t//将右边元素复制到TmpA\r}\rwhile(L\u0026lt;=LeftEnd)\rTmpA[Tmp++]=A[L++];\t//直接复制左边剩下的\rwhile(R\u0026lt;=RightEnd)\rTmpA[Tmp++]=A[R++];\t//直接复制右边剩下的\rfor(i=0;i\u0026lt;NumElements;i++,RightEnd--)\rA[RightEnd]=TmpA[Rightend];\t//将有序的TmpA复制回A\r}\r 归并排序有两种实现方式，递归算法和非递归算法。\n递归算法 归并排序的递归算法采用的是分而治之的思想。\nvoid MSort(ElementType A[], ElementType TmpA[], int L, int RightEnd){\r//核心递归排序函数\rint Center;\rif(L\u0026lt;RightEnd){\rCenter=(L+RightEnd)/2;\rMSort(A, TmpA, L, Center);\t//递归解决左边\rMSort(A, TmpA, Center+1, RightEnd);\t//递归解决右边\rMerge(A, TmpA, L, Center+1, RightEnd);\t//合并两段有序序列\r}\r}\r T=O(NlogN)，是稳定的算法。\n统一函数接口\nvoid Merge_Sort(ElementType A[], int N){\rElementType *TmpA;\rTmpA=(ElementType *)malloc(N*sizeof(ElementType));\rif(TmpA!=NULL){\rMSort(A, TmpA, 0, N-1);\rfree(TmpA);\r}\relse\rprintf(\u0026quot;空间不足\u0026quot;);\r}\r 非递归算法 归并排序的非递归算法由循环实现。\nvoid Merge_pass(ElementType A[], ElementType TmpA[], int N, int length){\t//length是当前有序子序列的长度\r//两两归并相邻有序子序列\rint i,j;\rfor(i=0;i\u0026lt;=N-2*length;i+=2*length)\rMerge(A, TmpA, i, i+length, i+2*length-1);\rif(i+length\u0026lt;N)\t//归并最后2个子列\rMerge(A, TmpA, i, i+length, N-1);\relse //最后只剩1个子列\rfor(j=i;j\u0026lt;N;j++)\rTmpA[j]=A[j];\r}\rvoid Merge_Sort(ElementType A[], int N){\rint length;\rElementType *TmpA;\rlength=1;\t//初始化子序列长度\rTmpA=(ElementType *)malloc(N*sizeof(ElementType));\rif(TmpA!=NULL){\rwhile(length\u0026lt;N){\rMerge_pass(A, TmpA, N, length);\rlength*=2;\rMerge_pass(TmpA, A, N, length);\rlength*=2;\r}\rfree(TmpA);\r}\relse\rprintf(\u0026quot;空间不足\u0026quot;);\r}\r 快速排序 快速排序采用分而治之的思想，先选取一个主元pivot，比主元小的元素放在前面，而比主元大的元素放在后面。问题就是如何选取主元，这里有个方法是取头、中、尾的中位数，比如8、12、3的中位数是8。另外，如果数据规模较小，快速排序的效率可能还不如插入排序快，所以，当递归的数据规模充分小，则停止递归，直接调用简单排序。\nElementType Median3(ElementType A[], int Left, int Right){\rint Center=(Left+Right)/2;\rif(A[Left]\u0026gt;A[Center])\rSwap(\u0026amp;A[Left],\u0026amp;A[Center]);\rif(A[Left]\u0026gt;A[Right])\rSwap(\u0026amp;A[Left],\u0026amp;A[Right]);\rif(A[Center]\u0026gt;A[Right])\rSwap(\u0026amp;A[Center],\u0026amp;A[Right]);\r//此时，A[Left]\u0026lt;=A[Center]\u0026lt;=A[Right]\rSwap(\u0026amp;A[Center],\u0026amp;A[Right-1]);\t//将基准Pivot藏到右边\r//只需要考虑A[Left+1],···,A[Right-2]\rreturn A[Right-1];\r}\rvoid Qsort(ElementType A[], int Left, int Right){\rint Pivot,Cutoff,Low,High;\rif(Cutoff\u0026lt;=Right-Left){\t//如果序列元素充分多，则进入快速排序\rPivot=Median3(A,Left,Right);\t//选取主元pivot\rLow=Left;\rHigh=Right-1;\rwhile(1){\t//将序列中比基准小的移到基准左边，大的移到基准右边\rwhile(A[++Low]\u0026lt;Pivot);\rwhile(A[--High]\u0026gt;Pivot);\rif(Low\u0026lt;High)\rSwap(\u0026amp;A[Low],\u0026amp;A[High]);\relse\rbreak;\r}\rSwap(\u0026amp;A[Low],\u0026amp;A[Right-1]);\t//将基准放到正确的位置\rQsort(A,Left,Low-1);\t//递归解决左边\rQsort(A,Low+1,Right);\t//递归解决右边\r}\relse\rInsertion_Sort(A+Left,Right-Left+1);\t//元素太少，用插入排序\r}\rvoid Quick_Sort(ElementType A[], int N){\t//统一接口\rQsort(A,0,N-1);\r}\r 如果pivot选取的好，那么快速排序的时间复杂度为T=O(NlogN)。\n基数排序 /* 假设元素最多有MaxDigit个关键字，基数全是同样的Radix */\r#define MaxDigit 4\r#define Radix 10\rtypedef struct Node *PtrToNode;\rstruct Node{\t//桶元素结点\rint key;\rPtrToNode next;\r};\rstruct HeadNode{\t//桶头结点\rPtrToNode head, tail;\r};\rtypedef struct HeadNode Bucket[Radix];\rint GetDigit(int X, int D){\r/* 默认次位D=1, 主位D\u0026lt;=MaxDigit */\rint d, i;\rfor(i=1; i\u0026lt;=D; i++){\rd = X % Radix;\rX /= Radix;\r}\rreturn d;\r}\rvoid LSDRadixSort(ElementType A[], int N){ //基数排序-次位优先\rint D, Di, i;\rBucket B;\rPtrToNode tmp, p, List = NULL; for(i=0; i\u0026lt;Radix; i++) /* 初始化每个桶为空链表 */\rB[i].head = B[i].tail = NULL;\rfor(i=0; i\u0026lt;N; i++){ /* 将原始序列逆序存入初始链表List */\rtmp = (PtrToNode)malloc(sizeof(struct Node));\rtmp-\u0026gt;key = A[i];\rtmp-\u0026gt;next = List;\rList = tmp;\r}\r/* 下面开始排序 */ for(D=1; D\u0026lt;=MaxDigit; D++){ /* 对数据的每一位循环处理 */\r/* 下面是分配的过程 */\rp = List;\rwhile(p){\rDi = GetDigit(p-\u0026gt;key, D); /* 获得当前元素的当前位数字 */\r/* 从List中摘除 */\rtmp = p; p = p-\u0026gt;next;\r/* 插入B[Di]号桶尾 */\rtmp-\u0026gt;next = NULL;\rif(B[Di].head == NULL)\rB[Di].head = B[Di].tail = tmp;\relse{\rB[Di].tail-\u0026gt;next = tmp;\rB[Di].tail = tmp;\r}\r}\r/* 下面是收集的过程 */\rList = NULL; for(Di=Radix-1; Di\u0026gt;=0; Di--){ /* 将每个桶的元素顺序收集入List */\rif(B[Di].head){ /* 如果桶不为空 */\r/* 整桶插入List表头 */\rB[Di].tail-\u0026gt;next = List;\rList = B[Di].head;\rB[Di].head = B[Di].tail = NULL; /* 清空桶 */\r}\r}\r}\r/* 将List倒入A[]并释放空间 */\rfor(i=0; i\u0026lt;N; i++){\rtmp = List;\rList = List-\u0026gt;next;\rA[i] = tmp-\u0026gt;key;\rfree(tmp);\r} }\r//基数排序-主位优先\rvoid MSD(ElementType A[], int L, int R, int D){ /* 核心递归函数: 对A[L]...A[R]的第D位数进行排序 */\rint Di, i, j;\rBucket B;\rPtrToNode tmp, p, List = NULL; if (D==0) return; /* 递归终止条件 */\rfor(i=0; i\u0026lt;Radix; i++) /* 初始化每个桶为空链表 */\rB[i].head = B[i].tail = NULL;\rfor(i=L; i\u0026lt;=R; i++){ /* 将原始序列逆序存入初始链表List */\rtmp = (PtrToNode)malloc(sizeof(struct Node));\rtmp-\u0026gt;key = A[i];\rtmp-\u0026gt;next = List;\rList = tmp;\r}\r/* 下面是分配的过程 */\rp = List;\rwhile (p){\rDi = GetDigit(p-\u0026gt;key, D); /* 获得当前元素的当前位数字 */\r/* 从List中摘除 */\rtmp = p; p = p-\u0026gt;next;\r/* 插入B[Di]号桶 */\rif(B[Di].head == NULL) B[Di].tail = tmp;\rtmp-\u0026gt;next = B[Di].head;\rB[Di].head = tmp;\r}\r/* 下面是收集的过程 */\ri = j = L; /* i, j记录当前要处理的A[]的左右端下标 */\rfor(Di=0; Di\u0026lt;Radix; Di++){ /* 对于每个桶 */\rif(B[Di].head){ /* 将非空的桶整桶倒入A[], 递归排序 */\rp = B[Di].head;\rwhile(p){\rtmp = p;\rp = p-\u0026gt;next;\rA[j++] = tmp-\u0026gt;key;\rfree(tmp);\r}\r/* 递归对该桶数据排序, 位数减1 */\rMSD(A, i, j-1, D-1);\ri = j; /* 为下一个桶对应的A[]左端 */\r} } }\rvoid MSDRadixSort(ElementType A[], int N){\t//统一接口\rMSD(A, 0, N-1, MaxDigit); }\r 排序算法的比较    排序算法 平均时间复杂度 最坏情况下时间复杂度 额外空间复杂度 稳定性     简单选择排序 O(N^2) O(N^2) O(1) 不稳定   冒泡排序 O(N^2) O(N^2) O(1) 稳定   直接插入排序 O(N^2) O(N^2) O(1) 稳定   希尔排序 O(N^d) O(N^2) O(1) 不稳定   堆排序 O(NlogN) O(NlogN) O(1) 不稳定   快速排序 O(NlogN) O(N^2) O(logN) 不稳定   归并排序 O(NlogN) O(NlogN) O(N) 稳定   基数排序 O(P(N+B)) O(P(N+B)) O(N+B) 稳定    ","date":"2019-07-21","permalink":"https://example.com/post/sort/","tags":["算法"],"title":"排序算法"},{"content":"基本概念 堆是一种用数组来实现的完全二叉树。堆分为两种：最大堆(大顶堆)和最小堆(小顶堆)，差别在于结点的排序方式。在最大堆中，任一结点的关键字是其子树所有结点的最大值，而在最小堆中，任一结点的关键字是其子树所有节点的最小值。\n在此我们暂时只讨论最大堆，也叫做优先队列。\n抽象数据类型描述 类型名称：最大堆(MaxHeap) 数据对象集：完全二叉树，每个结点的元素值不小于其子结点的元素值 操作集：最大堆H是MaxHeap类型，元素item是ElementType类型\n MaxHeap Create(int MaxSize)：创建一个空的最大堆 bool IsFull(MaxHeap H)：判断最大堆H是否已满 void Insert(MaxHeap H, ElementType item)：将元素item插入最大堆H bool IsEmpty(MaxHeap H)：判断最大堆H是否为空 ElementType DeleteMax(MaxHeap H)：返回H中最大元素(高优先级)  结构体定义 typedef struct HNode *Heap;\rstruct HNode{\rElementType *Data;\t//存储元素的数组\rint Size;\t//堆中当前元素个数\rint Capacity;\t//堆的最大容量\r};\rtypedef Heap MaxHeap;\t//最大堆\rtypedef Heap MinHeap;\t//最小堆\r 最大堆的创建 MaxHeap Create(int MaxSize){\rMaxHeap H=(MaxHeap)malloc(sizeof(struct HNode));\rH-\u0026gt;Data=(ElementType *)malloc((MaxSize+1)*sizeof(ElementType));\rH-\u0026gt;Size=0;\rH-\u0026gt;Capacity=MaxSize;\rH-\u0026gt;Data[0]=MAXDATA;\t//定义哨兵为大于堆中所有可能元素的值 #define MAXDATA 1000\rreturn H;\r}\r 判断是否为满 bool IsFull(MaxHeap H){\rreturn (H-\u0026gt;Size==H-\u0026gt;Capacity);\r}\r 最大堆的插入 把新元素插入最大堆时，先把新元素放在最大堆的末尾，再与父结点比较大小，如果比父结点大，则交换位置，直到小于父结点，便确定好了插入位置。这一过程叫做上滤。\nvoid Insert(MaxHeap H, ElementType X){\rint i;\rif(IsFull(H)){\rprintf(\u0026quot;最大堆已满\u0026quot;);\rreturn;\r}\ri=++H-\u0026gt;Size;\t//先把新元素放在最大堆的末尾\rfor(;H-\u0026gt;Data[i/2]\u0026lt;X;i/=2)\t//依次与父结点比较\rH-\u0026gt;Data[i]=H-\u0026gt;Data[i/2];\t//上滤X\rH-\u0026gt;Data[i]=X;\r}\r 判断是否为空 bool IsEmpty(MaxHeap H){\rreturn (H-\u0026gt;Size==0);\r}\r 最大元素的返回 因为最大堆的最大元素是根结点，如果直接返回根结点的话，整个堆就被删除了，所以我们把最大元素和最大堆的末尾元素交换，返回并删除末尾元素，再对最大堆进行调整。调整的过程叫做下滤(PercDown)，具体来说就是从根结点开始，与两个子结点的最大值进行比较，小于便与之交换，知道大于子结点的最大值。\nElementType DeleteMax(Heap H){\rint Parent,Child;\rElementType MaxItem,X;\rif(IsEmpty(H)){\rprintf(\u0026quot;最大堆已空\u0026quot;);\rreturn ERROR;\t//#define ERROR -1\r}\rMaxItem=H-\u0026gt;Data[1];\t//取出根结点存放的最大元素\rX=H-\u0026gt;Data[H-\u0026gt;Size--];\t//最大堆的规模-1\rfor(Parent=1;Parent*2\u0026lt;=H-\u0026gt;Size;Parent=Child){\rChild=Parent*2;\rif((Child!=H-\u0026gt;Size)\u0026amp;\u0026amp;(H-\u0026gt;Data[Child]\u0026lt;H-\u0026gt;Data[Child+1]))\rChild++;\t//Child指向左右子结点中的最大值\rif(X\u0026gt;=H-\u0026gt;Data[Child])\rbreak;\t//大于子结点，则找到了位置\relse\rH-\u0026gt;Data[Parent]=H-\u0026gt;Data[Child];\t//下滤X\r}\rH-\u0026gt;Data[Parent]=X;\rreturn MaxItem;\r}\r 最大堆的建立 建立最大堆：将已经存在的N个元素按最大堆的要求存放在一个一维数组中。有两种方法\n 通过插入操作，将N个元素一个个相继插入到一个初始为空的最大堆中，其时间复杂度为O(NlogN)。 在线性复杂度下建立最大堆，将N个元素按输入顺序存入，先满足完全二叉树的结构特性，再调整各结点位置，以满足最大堆的有序特性。具体过程则是从最后一个父结点开始，到根结点，依次进行下滤操作。  我们讨论第2种方法。\nvoid PercDown(MaxHeap H, int p);\rvoid BuildHeap(MaxHeap H){\rint i;\rfor(i=H-\u0026gt;Size/2;i\u0026gt;0;i--)\t//从最后一个父结点k开始，到根结点1\rPercDown(H, i);\r}\rvoid PercDown(MaxHeap H, int p){\rint Parent,Child;\rElementType X;\rX=H-\u0026gt;Data[p];\t//取出父结点存放的值\rfor(Parent=p;Parent*2\u0026lt;=H-\u0026gt;Size;Parent=Child){\rChild=Parent*2;\rif((Child!=H-\u0026gt;Size)\u0026amp;\u0026amp;(H-\u0026gt;Data[Child]\u0026lt;H-\u0026gt;Data[Child+1]))\rChild++;\t//Child指向左右子结点的最大值\rif(X\u0026gt;=H-\u0026gt;Data[Child])\rbreak;\t//大于子结点，则找到了位置\relse\rH-\u0026gt;Data[Parent]=H-\u0026gt;Data[Child];\t//下滤X\r}\rH-\u0026gt;Data[Parent]=X;\t//X放入合适位置\r}\r ","date":"2019-07-18","permalink":"https://example.com/post/heap/","tags":["数据结构"],"title":"堆"},{"content":"对于一般的二叉搜索树，搜索树结点不同插入次序，将导致不同的深度和平均查找长度ASL。甚至在极端的情况下，二叉搜索树会退化称线性的链表，导致插入和查找的复杂度下降到O(n)，所以便提出了平衡二叉树的概念。\n基本概念 平衡因子(Balance Factor, BF)：BF(T)=hL-hR，其中hL、hR分别是T的左、右子树的高度 平衡二叉树(Balanced Binary Tree, AVL树)：一棵二叉树，可以为空；或者任一结点左、右子树高度差的绝对值不超过1，即|BF(T)|\u0026lt;=1\n 给定结点数为n的AVL树的最大高度为O(logn)\n 抽象数据类型描述 类型名称：平衡二叉树 数据对象集：一棵二叉树，任一结点左、右子树高度差的绝对值不超过1 操作集：\n Position Rotation(Position A)：二叉树位置A的平衡调整 AVLTree Insert(AVLTree T, ElementType X)：在平衡二叉树T中插入元素X  结构体定义 typedef struct AVLNode *Position;\rtypedef Position AVLTree;\rstruct AVLNode{\rElementType Data;\t//结点数据\rAVLTree Left;\t//指向左子树\rAVLTree Right;\t//指向右子树\rint Height;\t//树的高度\r};\r 平衡二叉树的调整 在插入一个新的结点后，那些从插入点到根结点的路径上的结点的平衡可能会被改变，导致平衡二叉树的不平衡。 我们把平衡因子大于1且高度最低(深度最深)的结点叫做不平衡的“发现者”，把插入后导致不平衡的新结点叫做“麻烦结点”。那么，不平衡一共有4种不同的情况：\n  对发现者的左孩子的左子树进行一次插入 对发现者的左孩子的右子树进行一次插入 对发现者的右孩子的左子树进行一次插入 对发现者的右孩子的右子树进行一次插入   其中，情况1和4是关于不平衡发现者的镜像对称，而2和3是关于发现者的镜像对称。前一种情况是插入发生在“外边”的情况(即左-左或右-右)，该情况通过对树的一次单旋转完成调整。后一种情况是插入发生在“内部”的情况(即左-右或右-左)，该情况通过稍微复杂些的双旋转来处理。\nLL旋转 对于情况1，麻烦结点是发现者的左子树的左孩子，需要LL旋转来调整(实际上旋转方向是右旋转)。\nint Max(int a, int b){\rreturn a\u0026gt;b?a:b;\r}\rint GetHeight(Position P){\rif(P==NULL)\rreturn -1;\relse\rreturn P-\u0026gt;Height;\r}\rPosition SingleLeftRotation(Position A){\t//A必须要有左子结点B\r//将A与B做左单旋，更新A与B的高度，返回新的根结点B\rPosition B=A-\u0026gt;Left;\rA-\u0026gt;Left=B-\u0026gt;Right;\t//开始旋转\rB-\u0026gt;Right=A;\rA-\u0026gt;Height=Max(GetHeight(A-\u0026gt;Left),GetHeight(A-\u0026gt;Right))+1;\t//更新高度\rB-\u0026gt;Height=Max(GetHeight(B-\u0026gt;Left),A-\u0026gt;Height)+1;\rreturn B;\r}\r RR旋转 对于情况4，麻烦结点是发现者的右子树的右孩子，需要RR旋转来调整(实际上旋转方向是左旋转)。\nPosition SingleRightRotation(Position A){\t//A必须要有右子结点B\r//将A与B做右单旋，更新A与B的高度，返回新的根结点B\rPosition B=A-\u0026gt;Right;\rA-Right=B-\u0026gt;Left;\t//开始旋转\rB-\u0026gt;Left=A;\rA-\u0026gt;Height=Max(GetHeight(A-\u0026gt;Left),GetHeight(A-\u0026gt;Right))+1;\t//更新高度\rB-\u0026gt;Height=Max(A-\u0026gt;Height,GetHeight(B-\u0026gt;Right))+1;\rreturn B;\r}\r LR旋转 对于情况2，麻烦结点是发现者的左子树的右孩子，需要LR旋转来调整(先RR旋转，再LL旋转)\nPosition DoubleLeftRightRotation(Position A){\t//A必须要有左子结点B，B必须要有右子结点C\r//将A、B与C做两次单旋，返回新的根结点C\rA-\u0026gt;Left=SingleRightRotation(A-\u0026gt;Left);\t//将B与C做RR旋转(右单旋)，C被返回\rreturn SingleLeftRotation(A);\t//将A与C做LL旋转(左单旋)，C被返回\r}\r RL旋转 对于情况3，麻烦结点是发现者的右子树的左孩子，需要RL旋转来调整(先LL旋转，再RR旋转)\nPosition DoubleRightLeftRotation(Position A){\t//A必须要有右子结点B，B必须要有左子结点C\r//将A、B与C做两次单旋，返回新的根节点C\rA-\u0026gt;Right=SingleLeftRotation(A-\u0026gt;Right);\t//将B与C做LL旋转(左单旋)，C被返回\rreturn SingleRightRotation(A);\t//将A与C做RR旋转(右单旋)，C被返回\r}\r 插入 在平衡二叉树中插入新结点，通过比较新元素与原有结点元素的大小，确定插入位置(通过递归)，创建新结点，在调整平衡二叉树(上文4种情况)。\nAVLTree Insert(AVLTree T, ElementType X){\t//将X插入AVL树T中，并返回调整后的AVL树\rif(T==NULL){\rT=(AVLTree)malloc(sizeof(struct AVLTree));\t//空子树，则创建一个结点的树\rT-\u0026gt;Data=X;\rT-\u0026gt;Left=T-\u0026gt;Right=NULL;\rT-\u0026gt;Height=0;\r}\relse if(X\u0026lt;T-\u0026gt;Data){\t//如果插入到左子树\rT-\u0026gt;Left=Insert(T-\u0026gt;Left, X);\t//向下递归\rif(GetHeight(T-\u0026gt;Left)-GetHeight(T-\u0026gt;Right)==2)\t//如果不平衡\rif(X\u0026lt;T-\u0026gt;Left-\u0026gt;Data)\t//插入结点是T的左孩子的左结点\rT=SingleLeftRotation(T);\t//左单旋\relse\t//插入结点是T的左孩子的右结点\rT=DoubleLeftRightRotation(T);\t//左-右双旋\r}\relse if(X\u0026gt;T-\u0026gt;Data){\t//如果插入到右子树\rT-\u0026gt;Right=Insert(T-\u0026gt;Right, X);\t//向下递归\rif(GetHeight(T-\u0026gt;Left)-GetHeight(T-\u0026gt;Right)==-2)\t//如果不平衡\rif(X\u0026gt;T-\u0026gt;Right-\u0026gt;Data)\t//插入结点是T的右孩子的右结点\rT=SingleRightRotation(T);\t//右-左双旋\relse\t//插入结点是T的右孩子的左结点\rT=DoubleRightLeftRotation(T);\t//右单旋\r}\r//else X==T-\u0026gt;Data，什么也不做\rT-\u0026gt;Height=Max(GetHeight(T-\u0026gt;Left),GetHeight(T-\u0026gt;Right))+1;\t//更新树高\rreturn T;\r}\r ","date":"2019-06-30","permalink":"https://example.com/post/balanced-binary-tree/","tags":["数据结构"],"title":"平衡二叉树"},{"content":"二叉搜索树是为了解决动态查找问题而提出来的，也叫做二叉排序树或二叉查找树。\n基本概念 二叉搜索树(BST, Binary Search Tree)：一棵二叉树，可以为空；如果不为空，则要满足以下性质：\n 非空左子树的所有键值小于其根结点的键值 非空右子树的所有键值大于其根结点的键值 左、右子树都是二叉搜索树 对二叉搜索树进行中序遍历，即可得到有序的数列\n 抽象数据类型描述 类型名称：二叉搜索树 数据对象集：一棵二叉树，对于树中每个结点X，它的左子树中所有关键字值小于X的关键字值，而它的右子树中所有关键字值大于X的关键字值 操作集：BST是SearchTree类型，X是ElementType类型\n Position Find(SearchTree BST, ElementType X)：从二叉搜索树BST中查找元素X，返回其所在结点的位置 Position FindMin(SearchTree BST)：从二叉搜索树BST中查找并返回最小元素所在结点的位置 Position FindMax(SearchTree BST)：从二叉搜索树BST中查找并返回最大元素所在结点的位置 SearchTree Insert(SearchTree BST, ElementType X)：把元素X插入到二叉搜索树BST中 SearchTree Delete(SearchTree BST, ElementType X)：把元素X从二叉搜索树BST中删除  查找操作 递归形式\nPosition Find(SearchTree BST, ElementType X){\rif(BST=NULL)\rreturn NULL;\rif(X\u0026lt;BST-\u0026gt;Data)\rreturn Find(BST-\u0026gt;Left,X);\t//尾递归\relse if(X\u0026gt;BST-\u0026gt;Data)\rreturn Find(BST-\u0026gt;Right,X);\relse\rreturn BST;\r}\r 迭代形式，执行效率较高\nPosition Find(SearchTree BST, ElementType X){\rwhile(BST){\rif(X\u0026gt;BST-\u0026gt;Data)\rBST=BST-\u0026gt;Right;\relse if(X\u0026lt;BST-\u0026gt;Data)\rBST=BST-\u0026gt;Left;\relse\rreturn BST;\r}\rreturn NULL;\r}\r 查找最大最小元素 最大元素一定在树的最右分支的端结点上，而最小元素一定在树的最左分支的端结点上。 递归实现\nPosition FindMin(SearchTree BST){\rif(!BST)\rreturn NULL;\relse if(BST-\u0026gt;Left==NULL)\rreturn BST;\relse\rreturn FindMin(BST-\u0026gt;Left);\r}\rPosition FindMax(SearchTree BST){\rif(!BST)\rreturn NULL;\relse if(BST-\u0026gt;Right==NULL)\rreturn BST;\relse\rreturn FindMax(BST-\u0026gt;Right);\r}\r 迭代实现\nPosition FindMin(SearchTree BST){\rif(BST)\rwhile(BST-\u0026gt;Left!=NULL)\rBST=BST-\u0026gt;Left;\rreturn BST;\r}\rPosition FindMax(SearchTree BST){\rif(BST)\rwhile(BST-\u0026gt;Right!=NULL)\rBST=BST-\u0026gt;Right;\rreturn BST;\r}\r 插入 二叉搜索树的插入操作，可以采用与Find类似的方法，确定插入位置\nSearchTree Insert(SearchTree BST, ElementType X){\rif(BST==NULL){\t//原树为空，则先创建一棵树，生成一个结点\rBST=(SearchTree)malloc(sizeof(struct TNode));\rBST-\u0026gt;Data=X;\rBST-Left=BST-\u0026gt;Right=NULL;\r}\relse{\rif(X\u0026lt;BST-\u0026gt;Data)\rBST-\u0026gt;Left=Insert(BST-\u0026gt;Left,X); //递归插入左子树\relse if(X\u0026gt;BST-\u0026gt;Data)\rBST-\u0026gt;Right=Insert(BST-\u0026gt;Right,X);\t//递归插入右子树\r//else X在树中已存在，则什么都不做\r}\rreturn BST;\r}\r 删除 删除一个元素，要考虑三种情况：\n 要删除的是叶结点：直接删除，再修改其父结点指针，置为NULL 要删除的结点只有一个孩子结点：将其父结点的指针指向要删除的孩子结点 要删除的结点有左、右两颗子树：用右子树的最小元素或者左子树的最大元素替代被删除结点  SearchTree Delete(SearchTree BST, ElementType X){\rPosition tmp;\rif(BST==NULL)\rprintf(\u0026quot;要删除的元素未找到\\n\u0026quot;);\relse{\rif(X\u0026lt;BST-\u0026gt;Data)\rBST-\u0026gt;Left=Delete(BST-\u0026gt;Left,X);\t//从左子树递归删除\relse if(X\u0026gt;BST-\u0026gt;Data)\rBST-\u0026gt;Right=Delete(BST-\u0026gt;Right,X);\t//从右子树递归删除\relse{\t//找到了要被删除元素的位置\rif(BST-\u0026gt;Left\u0026amp;\u0026amp;BST-\u0026gt;Right){\t//被删除结点有两个子节点\rtmp=FindMin(BST-\u0026gt;Right);\t//找到右子树的最小元素\rBST-\u0026gt;Data=tmp-\u0026gt;Data;\t//替代被删除结点\rBST-\u0026gt;Right=Delete(BST-\u0026gt;Right,BST-\u0026gt;Data);\t//删除右子树的最小元素\r}\relse{\t//被删除结点有一个或零个子结点\rtmp=BST;\rif(BST-\u0026gt;Left==NULL)\t//只有右孩子或无子结点\rBST=BST-\u0026gt;Right;\relse\t//只有左孩子\rBST=BST-\u0026gt;Left;\rfree(tmp);\r}\r}\r}\rreturn BST;\r}\r ","date":"2019-06-30","permalink":"https://example.com/post/binary-search-tree/","tags":["数据结构"],"title":"二叉搜索树"},{"content":"基本概念 二叉树：一个有穷的结点的集合，这个集合可以为空，若不为空，则它是由根节点和称为其左子树和右子树的两个不相交的二叉树组成。\n有几种特殊的二叉树，分别是斜二叉树、完全二叉树和满二叉树。 二叉树的几个重要性质：\n 一个二叉树第i层的最大结点数为：2^(i-1)，i\u0026gt;=1 深度为k的二叉树有最大结点总数为：2^k-1，k\u0026gt;=1 对任何非空二叉树T，若n0表示叶结点的个数，n2是度为2的非叶结点的个数，那么二者满足关系n0=n2+1\n 抽象数据类型描述 类型名称：二叉树 数据对象集：一个有穷的结点集合，若不为空，则由根结点和其左、右二叉子树组成 操作集：BT是BinTree类型，Item是ElementType类型\n BinTree CreateBinTree()：创建一个二叉树 bool IsEmpty(BinTree BT)：判断BT是否为空 void Traversal(BinTree BT)：遍历，按某顺序访问每个结点 常用的遍历方法有： void PreOrderTraversal(BinTree BT)：先序遍历——根、左子树、右子树 void InOrderTraversal(BinTree BT)：中序遍历——左子树、根、右子树 void PostOrderTraversal(BinTree BT)：后序遍历——左子树、右子树、根 void LevelOrderTraversal(BinTree BT)：层次遍历——从上到下、从左到右  顺序存储结构 对于完全二叉树，我们可以按从上至下、从左到右的顺序进行存储 若二叉树根节点的序号为1，则n个结点的完全二叉树的结点父子关系为：\n 非根结点(序号i\u0026gt;1)的父结点的序号是i/2(向下取整) 结点(序号i)的左孩子结点的序号是2i(2i\u0026lt;=n，否则没有左孩子) 结点(序号i)的右孩子结点的序号是2i+1(2i+1\u0026lt;=n，否则没有右孩子)\n 对于一般二叉树，我们也可以采取这种结构，但是会造成空间浪费，所以二叉树普遍采用链式存储。\n链式存储结构 结构体定义 typedef struct TNode *Position;\rtypedef Position BinTree;\t//二叉树类型\rstruct TNode{\rElementType Data;\t//结点数据\rBinTree Left;\t//指向左子树\rBinTree Right;\t//指向右子树\r};\r 先序遍历 递归形式\nvoid PreOrderTraversal(BinTree BT){\rif(BT){\rprintf(\u0026quot;%d \u0026quot;,BT-\u0026gt;Data);\rPreOrderTraversal(BT-\u0026gt;Left);\rPreOrderTraversal(BT-\u0026gt;Right);\r}\r}\r 非递归形式 一般而言，递归算法转化为非递归形式的基本思路是使用堆栈。\nvoid PreOrderTraversal(BinTree BT){\rBinTree T=BT;\rStack S=CreateStack(MaxSize);\rwhile(T||!IsEmpty(S)){\rwhile(T){\rprintf(\u0026quot;%d \u0026quot;,T-\u0026gt;Data);\t//先打印根结点\rPush(S,T);\t//一直向左并沿途结点压入堆栈直到没有左孩子结点\rT=T-\u0026gt;Left;\r}\rif(!IsEmpty(S)){\rT=Pop(S);\t//弹出结点\rT=T-\u0026gt;Right;\t//转向右子树\r}\r}\r}\r 中序遍历 递归形式\nvoid InOrderTraversal(BinTree BT){\rif(BT){\rInOrderTraversal(BT-\u0026gt;Left);\rprintf(\u0026quot;%d \u0026quot;,BT-\u0026gt;Data);\rInOrderTraversal(BT-\u0026gt;Right);\r}\r}\r 非递归形式\nvoid InOrderTraversal(BinTree BT){\rBinTree T=BT;\rStack S=CreateStack(MaxSize);\rwhile(T||!IsEmpty(S)){\rwhile(T){\rPush(S,T);\t//一直向左并将沿途结点压入堆栈\rT=T-\u0026gt;Left;\r}\rif(!IsEmpty(S)){\rT=Pop(S);\rprintf(\u0026quot;%d \u0026quot;,T-\u0026gt;Data);\rT=T-\u0026gt;Right;\r}\r}\r}\r 后序遍历 递归形式\nvoid PostOrderTraversal(BinTree BT){\rif(BT){\rPostOrderTraversal(BT-\u0026gt;Left);\rPostOrderTraversal(BT-\u0026gt;Right);\rprintf(\u0026quot;%d \u0026quot;,BT-\u0026gt;Data);\r}\r}\r 非递归形式(较为复杂)\n\r 层序遍历 二叉树的层序遍历实现需要借助队列\nvoid LevelOrderTraversal(BinTree BT){\rQueue Q;\rBinTree T;\rif(!BT)\t//空树直接返回\rreturn;\rQ=CreateQueue();\rAddQ(Q,BT);\t//根结点入队\rwhile(!IsEmpty(Q)){\rT=DeleteQ(Q);\rprintf(\u0026quot;%d \u0026quot;,T-\u0026gt;Data);\rif(T-\u0026gt;Left)\rAddQ(Q,T-\u0026gt;Left);\t//左结点入队\rif(T-\u0026gt;Right)\rAddQ(Q,T-\u0026gt;Right);\t//右结点入队\r}\r}\r ","date":"2019-06-29","permalink":"https://example.com/post/binary-tree/","tags":["数据结构"],"title":"二叉树"},{"content":"队列是一种基本的数据结构\n基本概念 队列(Queue)：具有一定操作约束的线性表\n 只能在一端插入，而在另一端删除 数据插入：入队列(AddQ) 数据删除：出队列(DeleteQ) 先进先出：First In First Out(FIFO)\n 抽象数据类型描述 类型名称：队列 数据对象集：一个有0个或多个元素的有穷线性表 操作集：长度为MaxSize的队列Q是Queue，队列元素item是ElementType类型\n Queue CreateQueue(int MaxSize)：生成长度为MaxSize的空队列 int IsFullQ(Queue Q)：判断队列Q是否已满 void AddQ(Queue Q, ElementType item)：将数据元素item插入队列Q中 int IsEmptyQ(Queue Q)：判断队列Q是否已空 ElementType DeleteQ(Queue Q)：删除队头数据元素并返回  顺序存储实现 队列的顺序存储结构通常由一个一维数组和一个记录队列头元素位置的变量front以及一个记录队列尾元素位置的变量rear组成。我们通常使用循环队列，即队列头尾相连，这样就不会造成空间浪费。\n结构体定义 typedef int Position\rstruct QNode{\rElementType *Data;\rPosition Front,Rear;\rint MaxSize;\r};\rtypedef struct QNode *Queue;\r 初始化队列 Queue CreateQueue(int MaxSize){\rQueue Q=(Queue)malloc(sizeof(struct QNode));\rQ-\u0026gt;Data=(ElementType *)malloc(MaxSize*sizeof(ElementType));\rQ-\u0026gt;Front=Q-\u0026gt;Rear=0;\rQ-\u0026gt;MaxSize=MaxSize;\rreturn Q;\r}\r 是否满队列 Rear是队列尾的位置，Front是队列头的位置，但也有一种情况是Rear是队列尾再后一个的位置，Front是队列头的位置，这样的话程序略有不同。\nbool IsFull(Queue Q){\rreturn ((Q-\u0026gt;Rear+1)%Q-\u0026gt;MaxSize==Q-\u0026gt;Front);\r}\r 入队 void AddQ(Queue Q, ElementType X){\rif(IsFull(Q))\rprintf(\u0026quot;队列满\u0026quot;);\relse{\rQ-\u0026gt;Rear=(Q-\u0026gt;Rear+1)%Q-\u0026gt;MaxSize;\rQ-\u0026gt;Data[Q-\u0026gt;Rear]=X;\r}\r}\r 是否空队列 bool IsEmpty(Queue Q){\rreturn (Q-\u0026gt;Front==Q-\u0026gt;Rear);\r}\r 具体实现的时候还要加一个flag变量，来确认是出队还是入队以判断是队列空还是满。\n出队 ElementType DeleteQ(Queue Q){\rif(IsEmpty(Q)){\rprintf(\u0026quot;队列空\u0026quot;);\rreturn ERROR;\r}\relse{\rElementType X=Q-\u0026gt;Data[Q-\u0026gt;Front];\rQ-\u0026gt;Front=(Q-\u0026gt;Front+1)%MaxSize;\rreturn X;\r}\r}\r 链式存储实现 队列的链式存储结构可以用一个单链表实现，插入和删除操作分别在链表的两端进行，front指向链表头，rear指向链表尾。\n结构体定义 typedef struct Node *PtrToNode;\rstruct Node{\t//队列中的结点\rElementType Data;\rPtrToNode Next;\r};\rtypedef PtrToNode Position;\rstruct QNode{\rPosition Front,Rear;\t//队列头尾指针\rint MaxSize;\r};\rtypedef struct QNode *Queue;\r 初始化队列 Queue CreateQueue(int MaxSize){\rQueue Q=(Queue)malloc(sizeof(struct QNode));\rQ-\u0026gt;Front=Q-\u0026gt;Rear=NULL;\rQ-\u0026gt;MaxSize=MaxSize;\rreturn Q:\r}\r 是否空队列 bool IsEmpty(Queue Q){\rreturn (Q-\u0026gt;Front==NULL);\r}\r 入队 void AddQ(Queue Q, ElementType X){\rPosition tmp=(PtrToNode)malloc(sizeof(struct Node));\rtmp-\u0026gt;Data=X;\rtmp-\u0026gt;Next=NULL;\rQ-\u0026gt;Rear=tmp;\r}\r 出队 ElementType DeleteQ(Queue Q){\rPosition FrontCell;\rElementType FrontElem;\rif(IsEmpty(Q)){\rprintf(\u0026quot;队列空\u0026quot;);\rreturn ERROR;\r}\relse{\rFrontCell=Q-\u0026gt;Front;\rif(Q-\u0026gt;Front==Q-\u0026gt;Rear)\t//队列只有一个元素\rQ-\u0026gt;Front=Q-\u0026gt;Rear=NULL;\relse\t//队列有多个元素\rQ-\u0026gt;Front=Q-\u0026gt;Front-\u0026gt;Next;\rFrontElem=FrontCell-\u0026gt;Data;\rfree(FrontCell);\rreturn FrontElem;\r}\r}\r ","date":"2019-06-25","permalink":"https://example.com/post/queue/","tags":["数据结构"],"title":"队列"},{"content":"栈是一种基本的数据结构\n基本概念 栈(Stack)：具有一定操作约束的线性表。\n 只在一端(栈顶，Top)做插入、删除操作 插入数据：入栈(Push) 删除数据：出栈(Pop) 后入先出：Last In First Out(LIFO)\n 抽象数据类型描述 类型名称：栈 数据对象集：一个有0个或多个元素的有穷线性表 操作集：长度为MaxSize的堆栈属于Stack，堆栈元素X属于ElementType\n Stack CreateStack(int MaxSize)：生成空栈，其最大长度为MaxSize bool IsFull(Stack S)：判断栈S是否已满 void Push(Stack S, ElementType X)：将元素X压入栈 bool IsEmpty(Stack S)：判断栈S是否为空 ElementType Pop(Stack S)：删除并返回栈顶元素  顺序存储实现 栈的顺序存储结构通常由一个一维数组和一个记录栈顶元素位置的变量组成。\n结构体定义 typedef int Position;\rstruct SNode{\rElementType *Data;\t//存储元素的数组\rPosition Top;\t//栈顶位置\rint MaxSize;\t//最大容量\r};\rtypedef struct SNode *Stack;\r 初始化栈 Stack CreateStack(int MaxSize){\t//初始化最大容量为MaxSize的空栈\rStack S=(Stack)malloc(sizeof(struct SNode));\rS-\u0026gt;Data=(ElementType *)malloc(MaxSize*sizeof(ElementType));\t//分配内存\rS-\u0026gt;Top=-1;\t//空栈栈顶位置为-1\rS-\u0026gt;MaxSize=MaxSize;\rreturn S;\r}\r 是否满栈 判断栈是否满了，可以根据栈顶位置与最大容量的关系。\nbool IsFull(Stack S){\rreturn (S-\u0026gt;Top==S-\u0026gt;MaxSize-1);\r}\r 入栈 void Push(Stack S, ElementType X){\rif(IsFull(S))\t//先判断栈是否已满\rprintf(\u0026quot;栈已满\u0026quot;);\relse{\rS-\u0026gt;Data[++(S-\u0026gt;Top)]=X;\t//先把栈顶位置加1，再入栈\rreturn true;\r}\r}\r 是否空栈 判断栈是否是空栈，可以根据栈顶位置是否为-1来判断。\nbool IsEmpty(Stack S){\rreturn (S-\u0026gt;Top==-1);\r}\r 出栈 ElementType Pop(Stack S){\rif(IsEmpty(S)){\t//先判断栈是否已空\rprintf(\u0026quot;栈已空\u0026quot;);\rreturn ERROR;\t//define ERROR -1\r}\relse\rreturn S-\u0026gt;Data[(S-\u0026gt;Top)--];\t//先出栈，再栈顶位置减1\r}\r 链式存储实现 栈的链式存储结构实际上就是一个单链表，叫做链栈。插入和删除操作只能在链栈的栈顶进行，因为确定单链表的表尾比较耗费时间，我们一般把栈顶指针Top放在表头，也就是在链栈的头部进行插入和删除操作。因为是链式结构，也就不存在栈满这种情况。\n结构体定义 typedef struct SNode *PtrToSNode;\rstruct SNode{\rElementType Data;\rPtrToSNode Next;\r};\rtypedef PtrToSNode Stack;\r 初始化栈 在初始化的时候，一般先定义一个头结点Head，这个头结点不存放数据，只是作为链表的起始。\nStack CreateStack(){\rStack S;\rS=(Stack)malloc(sizeof(struct SNode));\t//内存分配\rS-\u0026gt;Next=NULL;\rreturn S;\r}\r 是否空栈 bool IsEmpty(Stack S){\rreturn (S-\u0026gt;Next==NULL);\r}\r 入栈 void Push(Stack S, ElementType X){\rPtrToSNode tmp;\rtmp=(PtrToSNode)malloc(sizeof(struct SNode));\rtmp-\u0026gt;Data=X;\rtmp-\u0026gt;Next=S-\u0026gt;Next;\rS-\u0026gt;Next=tmp;\r}\r 出栈 ElementType Pop(Stack S){\rPtrToSNode FirstCell;\rElementType TopElem;\rif(IsEmpty(S)){\rprintf(\u0026quot;栈已空\\n\u0026quot;);\rreturn ERROR;\t//define ERROR -1\r}\relse{\rFirstCell=S-\u0026gt;Next;\rTopElem=FirstCell-\u0026gt;Data;\rS-\u0026gt;Next=FirstCell-\u0026gt;Next;\rfree(FirstCell);\rreturn TopElem;\r}\r}\r ","date":"2019-06-20","permalink":"https://example.com/post/stack/","tags":["数据结构"],"title":"栈"},{"content":"线性表是最基本的数据结构。\n基本概念 线性表(Linear List)：由同类型数据元素构成有序序列的线性结构。\n 表中元素个数称为线性表的长度 线性表没有元素时称为空表 表起始位置为表头，表结束位置为表尾\n 抽象数据类型描述 类型名称：线性表 数据对象集：线性表是n个元素构成的有序序列(a1,a2,···,an) 操作集：线性表L属于List，整数i表示位置，元素X属于ElementType\n List MakeEmpty()：初始化一个空线性表L ElementType FindKth(List L, Position K)：根据位序K，返回相应元素 int Find(List L, ElementType X)：在线性表L中查找X的第一次出现位置 void Insert(List L, ElementType X, Position i)：在位序i前插入一个新元素X void Delete(List L, Position i)：删除指定位序i的元素 int Length(List L)：返回线性表L的长度n  顺序存储实现 线性表的顺序存储实现利用数组的连续存储空间顺序存放线性表的个元素，也叫做顺序表。\n结构体定义 typedef int Position;\rtypedef struct LNode *List;\rstruct LNode{\rElementType Data[MAXSIZE]; //用数组实现，MAXSIZE为最大存储容量\rPostion Last;\t//末尾元素位置\r};\r 访问下标为i的元素：L.Data[i]或PtrL-\u0026gt;Data[i] 线性表的长度：L.Last+1或PtrL-\u0026gt;L+1\n初始化 初始化也就是建立空的顺序表\nList MakeEmpty(){\rList L;\rL=(List)malloc(sizeof(struct LNode));\t//内存分配\rL-\u0026gt;Last=-1; //没有元素时为-1\treturn L;\r}\r 查找 Position Find(List L, ElementType X){\rPosition i=0;\rwhile(i\u0026lt;=L-\u0026gt;Last\u0026amp;\u0026amp;L-\u0026gt;Data[i]!=X)\ri++;\rif(i\u0026gt;L-\u0026gt;Last)\rreturn -1;\t//没找到，返回-1\relse\rreturn i;\t//找到，返回存储位置\r}\r 查找成功的平均比较次数为(n+1)/2，平均时间性能为O(n)。\n插入 要在第i个位置上插入一个值为X的元素，先从表尾开始到位序为i的元素依次往后移位，空出i，再将X插入。\nvoid Insert(List L, ElementType X, Position i){\rPosition j;\rif(L-\u0026gt;Last==MAXSIZE-1){\rprintf(\u0026quot;表满\u0026quot;);\rreturn;\r}\rif(i\u0026lt;0||i\u0026gt;L-\u0026gt;Last+1){\rprintf(\u0026quot;位置不合法\u0026quot;);\rreturn;\r}\rfor(j=L-\u0026gt;Last; j\u0026gt;=i; --j)\rL-\u0026gt;Data[j+1]=L-\u0026gt;Data[j];\t//后移,第i个位置，数组下标为i-1\rL-\u0026gt;Data[j]=X;\t//插入\rL-\u0026gt;Last++;\t//Last依旧是表尾\r}\r 插入的平均移动次数为n/2，平均时间性能为O(n)。\n删除 要删除表的位序为i的元素，直接从i+1到表尾依次往前移位，覆盖前一个位置的元素。\nvoid Delete(List L, Position i){\rPosition j;\rif(i\u0026lt;0||i\u0026gt;PtrL-\u0026gt;Last){\rprintf(\u0026quot;不存在%d号元素\u0026quot;,i);\rreturn;\r}\rfor(j=i; j\u0026lt;PtrL-\u0026gt;Last; ++j)\rPtrL-\u0026gt;Data[j]=PtrL-\u0026gt;Data[j+1];\t//前移，第i个位置，数组下标为i-1\rPtrL-\u0026gt;Last--;\r}\r 删除的平均移动次数为(n-1)/2，平均时间性能为O(n)。\n链式存储实现 线性表的链式存储实现不要求逻辑上相邻的两个元素物理上也相邻，通过链建立起数据元素之间的逻辑关系，也叫做链表。 在链表中，每个结点除了要存储数据元素之外，还要存储一个指向其后继结点的指针。当然，结点可以有多个指针指向不同位置，而在此只讨论结点只有一个指针，即单链表。同时，结点有两个指针，一个指向前驱，一个指向后继，叫做双链表。\n结构体定义 typedef struct LNode *PtrToLNode;\rstruct LNode{\rElementType Data;\t//数据元素\rPtrToLNode Next;\t//指向后继的指针\r};\rtypedef PtrToLNode Position;\rtypedef PtrToLNode List;\r 求表长度 int Length(List L){\rPosition p=L;\t//p指向链表头结点\rint j=0;\rwhile(p){\rp=p-\u0026gt;Next;\r++j;\t//当前p指向第j个结点\r}\rreturn j;\r}\r 时间性能为O(n)。\n查找 查找分为两种情况，一种是按序号查找，一种是按值查找。\nPosition FindKth(List L, int K){\t//按序号查找，找第K个元素\rPosition p=L;\rint i=1;\rwhile(p-\u0026gt;Next\u0026amp;\u0026amp;i\u0026lt;K){\rp=p-\u0026gt;Next;\r++i;\r}\rif(i==K)\rreturn p;\t//找到第K个，返回指针\relse\rreturn NULL;\t//未找到\r}\rPosition Find(List L, ElementType X){\t//按值查找，找元素X的位置\rPositon p=L;\rwhile(p\u0026amp;\u0026amp;p-\u0026gt;Data!=X)\rp=p-\u0026gt;Next;\rif(p)\rreturn p;\relse\rreturn NULL; }\r 查找的平均时间性能为O(n)。\n插入 要在结点P之前插入新结点，先构造一个新结点，再找到P之前的结点，然后修改指针，插入新结点。\nvoid Insert(List L, ElementType X, Position P){\rPosition tmp, pre;\rfor(pre=L; pre\u0026amp;\u0026amp;pre-\u0026gt;Next!=P; pre=pre-\u0026gt;Next)\t//找到P的前一个结点\r;\rif(pre==NULL)\rprintf(\u0026quot;插入位置参数错误\\n\u0026quot;);\relse{\rtmp=(Position)malloc(sizeof(struct LNode));\t//分配内存，构造结点\rtmp-\u0026gt;Data=X;\rtmp-\u0026gt;Next=P;\rpre-\u0026gt;Next=tmp;\r}\r}\r 平均查找次数为n/2，平均时间性能为O(n)。\n删除 要删除结点P，先找到P之前的结点，然后修改指针，最后释放内存空间。\nvoid Delete(List L, Position P){\rPosition tmp, pre;\rfor(pre=L; pre\u0026amp;\u0026amp;pre-\u0026gt;Next!=P; pre=pre-\u0026gt;Next)\t//找到P的前一个结点\r;\rif(pre==NULL||P==NULL)\rprintf(\u0026quot;删除位置参数错误\\n\u0026quot;);\relse{\rtmp=P\rpre-\u0026gt;Next=tmp-\u0026gt;Next;\t//删除P\rfree(tmp);\t//释放空间\r}\r}\r 平均查找次数为n/2，平均时间性能为O(n)。\n","date":"2019-06-19","permalink":"https://example.com/post/linear-list/","tags":["数据结构"],"title":"线性表"},{"content":"关于const关键字，有几个注意点。\nconst的引用 首先是把引用绑定到const对象上，与普通引用不同，对常量的引用不能被用来修改它所绑定的对象。\n\tconst int ci=1024;\rconst int \u0026amp;r1=ci; //正确：引用及其对应的对象都是常量\rr1=42;\t//错误：r1是对常量的引用，不可修改\rint \u0026amp;r2=ci;\t//错误：ci是常量，需要常量引用\r 对于非常量对象、字面值、一般表达式，也允许用常量引用绑定，但此时不可通过修改常量引用来修改原非常量对象。\n\tint i=42;\rconst int \u0026amp;r1=i;\t//正确：允许将const int\u0026amp;绑定到非const对象上\rconst int \u0026amp;r2=42;\t//正确：42是字面值，r2是常量引用\rconst int \u0026amp;r3=r1*2;\t//正确：r1*2是一般表达式，r3是常量引用\rint \u0026amp;r4=r1*2;\t//错误：r1*2是一般表达式，r4是非常量引用\rr1=1;\t//错误：r1是常量引用，不可修改r1\ri=1;\t//正确：i不是常量\r 也就是说，常量引用只是对引用可参与的操作做出了限定，而对于引用的对象本身是否是const未作限定。\n指针和const 关于指针和const，可以分为指向常量的指针和常量指针。 对于指向常量的指针，可以类比常量引用，不能通过该指针修改所指对象的值，对于所指对象是否是常量也未作限定。\n\tconst int i=42;\tint *p1=\u0026amp;i;\t//错误：i是常量，p1是普通指针\rconst int *pi=\u0026amp;i;\t//正确：i是常量，pi是指向常量的指针\r*pi=1;\t//错误：不能给*pi赋值\rint j=42;\tconst *pj=\u0026amp;j;\t//正确：j不是常量，pj是指向常量的指针\r*pj=1;\t//错误：不能通过给*pj赋值来修改j的值\rj=1;\t//正确：j不是常量\r 对于常量指针，在定义时必须初始化，以后不可修改常量指针的值，即不能将该指针指向其他对象。\n\tint i=0,j=0;\tint *const pi=\u0026amp;i;\t//正确：pi是常量指针\r*pi=1;\t//正确：可以给*pi赋值来修改i的值\rpi=\u0026amp;j;\t//错误：pi是常量指针，不能给pi赋值\rdouble pi=3.14,x=0.0;\rconst double *const pip=\u0026amp;pi;\t//正确：pip是指向常量的常量指针\r*pip=1.1;\t//错误：不能给*pip赋值来修改pi的值\rpip=\u0026amp;x;\t//错误：不能给pip赋值来将pip指向x\r 其实，指向常量的常量指针和常量引用才是最为相似的。对于常量引用来讲，我们不能通过给引用赋值来修改所绑定的对象，而引用本身在定义时就必须初始化，之后便不能修改引用（不能将引用绑定到其他对象上）。这两个性质与指向常量的常量指针极为相似，就如上文const double *const pip=\u0026amp;pi; 我们不能通过pip来修改pi的值（给*pip赋值），也不能将pip指向其他对象（给pip赋值）。深入学习的话，是因为c++的引用本身就是由指针来实现的，只不过对外隐藏了自身的值。\n顶层const、底层const 介绍完上面的内容，对于顶层const、底层const也就很好理解了。因为指针本身是否是常量和指针所指的对象是否是常量是两个相互独立的问题，所以c++用顶层const表示指针本身是常量，而用底层const表示指针所指的对象是常量。更一般的是，顶层const可以表示任意对象是常量。\n\tint i=1;\rint *const p1=\u0026amp;i;\t//p1是顶层const\rconst int ci=1;\t//ci是顶层const\rconst int *p2=\u0026amp;ci;\t//p2是底层const\r const和类成员 const除了修饰一般变量，还可以修饰类中的成员，可以分为常成员函数和常数据成员。\n使用const修饰的函数为常成员函数，声明的格式为： 类型说明符 函数名(参数表) const; 常成员函数有以下特点：\n  常成员函数不能更新目的对象的数据成员。 如果一个类的对象是常对象，那么通过该常对象只能调用它的常成员函数，不能调用其他成员函数。 const可以用于对重载函数的区分。 void print();\rvoid print() const;\r 非const的对象调用该函数，两个重载的函数都可以匹配，但编译器会选择不带const的函数。   当类的数据成员是常量时，构造函数对该数据成员进行初始化，就只能通过初始化列表。\n","date":"2019-04-27","permalink":"https://example.com/post/cpp-const/","tags":["c++"],"title":"c++ const关键字"},{"content":"看《c++ primer》这本书已经很久了，也不敢说自己掌握了多少。之前过了一遍，这本书几乎覆盖了c++的全部知识点，很丰富，但也很杂。\n最近在重看这本书，顺便把每节的习题给做了，并把部分习题代码上传到了github。\n附github链接：https://github.com/keichw/cppprimer-ans\n","date":"2019-04-19","permalink":"https://example.com/post/cppprimer-ans/","tags":["c++"],"title":"c++ primer学习"}]